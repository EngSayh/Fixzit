/**
 * Security event monitoring middleware
 * Auto-generated by scripts/security/configure-monitoring.ts
 */

import { logger } from "@/lib/logger";
import { redactIdentifier } from "@/lib/otp-utils";

// Rate limit event tracking
const rateLimitHits = new Map<string, number[]>();
const corsViolations = new Map<string, number[]>();
const authFailures = new Map<string, number[]>();

const WINDOW_MS = 5 * 60 * 1000; // 5 minutes
const ALERT_THRESHOLDS = {
  rateLimit: {
    logLevel: "warn",
    alertThreshold: 100,
    destinations: ["console", "file", "webhook"],
  },
  cors: {
    logLevel: "warn",
    alertThreshold: 50,
    destinations: ["console", "file"],
  },
  auth: {
    logLevel: "error",
    alertThreshold: 10,
    destinations: ["console", "file", "webhook"],
  },
  mongodb: {
    logLevel: "error",
    alertThreshold: 5,
    destinations: ["console", "file", "webhook"],
  },
};

async function sendSentryAlert(eventType: string, payload: Record<string, unknown>): Promise<void> {
  // Only attempt in server context with Sentry configured (avoid client bundles)
  if (typeof window !== "undefined") return;
  if (!process.env.SENTRY_DSN || process.env.NODE_ENV !== "production") return;

  try {
    const Sentry = await import("@sentry/nextjs").catch(() => null);
    if (!Sentry) return;

    Sentry.captureMessage(`[Security] ${eventType}`, {
      level: "warning",
      extra: payload,
      tags: {
        security_event: eventType,
      },
    });
  } catch (error) {
    // Avoid throwing from monitoring path
    logger.error("[Security] Failed to send Sentry alert", {
      eventType,
      error: error instanceof Error ? error.message : error,
    });
  }
}

function cleanOldEntries(map: Map<string, number[]>, windowMs: number): void {
  const cutoff = Date.now() - windowMs;
  for (const [key, timestamps] of map.entries()) {
    const filtered = timestamps.filter((t) => t > cutoff);
    if (filtered.length === 0) {
      map.delete(key);
    } else {
      map.set(key, filtered);
    }
  }
}

function trackEvent(
  map: Map<string, number[]>,
  key: string,
  eventType: string,
  threshold: number,
): void {
  cleanOldEntries(map, WINDOW_MS);

  const timestamps = map.get(key) || [];
  timestamps.push(Date.now());
  map.set(key, timestamps);

  if (timestamps.length >= threshold) {
    logger.warn(`[${eventType}] Alert threshold exceeded`, {
      key,
      count: timestamps.length,
      windowMs: WINDOW_MS,
      threshold,
    });

    // Send to Sentry for centralized monitoring (non-blocking)
    void sendSentryAlert(eventType, {
      key,
      count: timestamps.length,
      threshold,
      windowMs: WINDOW_MS,
    });

    // Emit webhook if configured
    if (process.env.SECURITY_ALERT_WEBHOOK) {
      fetch(process.env.SECURITY_ALERT_WEBHOOK, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          event: eventType,
          key,
          count: timestamps.length,
          threshold,
          timestamp: new Date().toISOString(),
        }),
      }).catch((err) => logger.error("[Webhook] Failed to send alert", err));
    }
  }
}

export function trackRateLimitHit(identifier: string, endpoint: string): void {
  const redacted = redactIdentifier(identifier);
  const key = `${redacted}:${endpoint}`;
  trackEvent(
    rateLimitHits,
    key,
    "RateLimit",
    ALERT_THRESHOLDS.rateLimit.alertThreshold,
  );

  logger.warn("[RateLimit] Request blocked", {
    identifier: redacted,
    endpoint,
    timestamp: new Date().toISOString(),
  });
}

export function trackCorsViolation(origin: string, endpoint: string): void {
  const key = `${origin}:${endpoint}`;
  trackEvent(corsViolations, key, "CORS", ALERT_THRESHOLDS.cors.alertThreshold);

  logger.warn("[CORS] Origin blocked", {
    origin,
    endpoint,
    timestamp: new Date().toISOString(),
  });
}

export function trackAuthFailure(identifier: string, reason: string): void {
  const redacted = redactIdentifier(identifier);
  trackEvent(
    authFailures,
    redacted,
    "Auth",
    ALERT_THRESHOLDS.auth.alertThreshold,
  );

  logger.error("[Auth] Authentication failed", {
    identifier: redacted,
    reason,
    timestamp: new Date().toISOString(),
  });
}

export function getSecurityMetrics() {
  return {
    rateLimitHits: rateLimitHits.size,
    corsViolations: corsViolations.size,
    authFailures: authFailures.size,
    windowMs: WINDOW_MS,
  };
}
