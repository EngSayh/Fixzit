/**
 * Security event monitoring middleware
 * Auto-generated by scripts/security/configure-monitoring.ts
 * 
 * SECURITY: All identifiers are redacted before logging/alerting to prevent PII leakage.
 * Verbose logging is gated to threshold events only to reduce log noise.
 */

import { logger } from "@/lib/logger";
import { sanitizeValue } from "@/lib/security/log-sanitizer";
import { createHash } from "crypto";

// Helper to redact identifiers consistently
const redactIdentifier = (id: string): string => {
  const result = sanitizeValue(id, 'identifier');
  return typeof result === 'string' ? result : '[REDACTED]';
};

// Helper to hash identifiers for correlation (non-reversible)
const hashIdentifier = (id: string): string => {
  return createHash('sha256').update(id).digest('hex').substring(0, 16);
};

// Rate limit event tracking
const rateLimitHits = new Map<string, number[]>();
const corsViolations = new Map<string, number[]>();
const authFailures = new Map<string, number[]>();

const WINDOW_MS = 5 * 60 * 1000; // 5 minutes
const WEBHOOK_TIMEOUT_MS = 3000; // 3 second timeout for webhooks (prevent blocking)
const ALERT_THRESHOLDS = {
  rateLimit: {
    logLevel: "warn",
    alertThreshold: 100,
    destinations: ["console", "file", "webhook"],
  },
  cors: {
    logLevel: "warn",
    alertThreshold: 50,
    destinations: ["console", "file"],
  },
  auth: {
    logLevel: "error",
    alertThreshold: 10,
    destinations: ["console", "file", "webhook"],
  },
  mongodb: {
    logLevel: "error",
    alertThreshold: 5,
    destinations: ["console", "file", "webhook"],
  },
};

// Verbose logging threshold - only log individual events after this many hits
const VERBOSE_LOG_THRESHOLD = 5;

function cleanOldEntries(map: Map<string, number[]>, windowMs: number): void {
  const cutoff = Date.now() - windowMs;
  for (const [key, timestamps] of map.entries()) {
    const filtered = timestamps.filter((t) => t > cutoff);
    if (filtered.length === 0) {
      map.delete(key);
    } else {
      map.set(key, filtered);
    }
  }
}

function trackEvent(
  map: Map<string, number[]>,
  key: string,
  eventType: string,
  threshold: number,
  safeKey: string, // Redacted key for logging
): void {
  cleanOldEntries(map, WINDOW_MS);

  const timestamps = map.get(key) || [];
  timestamps.push(Date.now());
  map.set(key, timestamps);

  // Only log/alert when threshold is reached (reduces noise)
  if (timestamps.length >= threshold) {
    logger.warn(`[${eventType}] Alert threshold exceeded`, {
      key: safeKey, // Use redacted key in logs
      count: timestamps.length,
      windowMs: WINDOW_MS,
      threshold,
    });

    // Emit webhook if configured (with timeout to prevent hanging)
    if (process.env.SECURITY_ALERT_WEBHOOK) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), WEBHOOK_TIMEOUT_MS);

      fetch(process.env.SECURITY_ALERT_WEBHOOK, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          event: eventType,
          keyHash: hashIdentifier(key), // Use hash for correlation (not raw or redacted)
          count: timestamps.length,
          threshold,
          timestamp: new Date().toISOString(),
        }),
        signal: controller.signal,
      })
        .catch((err) => logger.error("[Webhook] Failed to send alert", err))
        .finally(() => clearTimeout(timeoutId));
    }
  }
}

export function trackRateLimitHit(identifier: string, endpoint: string): void {
  const key = `${identifier}:${endpoint}`;
  const safeKey = `${redactIdentifier(identifier)}:${endpoint}`;
  const count = (rateLimitHits.get(key)?.length ?? 0) + 1;

  trackEvent(
    rateLimitHits,
    key,
    "RateLimit",
    ALERT_THRESHOLDS.rateLimit.alertThreshold,
    safeKey,
  );

  // Only log individual events after threshold to reduce noise
  if (count >= VERBOSE_LOG_THRESHOLD) {
    logger.warn("[RateLimit] Request blocked", {
      identifier: redactIdentifier(identifier),
      endpoint,
      hitCount: count,
      timestamp: new Date().toISOString(),
    });
  }
}

export function trackCorsViolation(origin: string, endpoint: string): void {
  const key = `${origin}:${endpoint}`;
  const safeKey = `${redactIdentifier(origin)}:${endpoint}`;
  const count = (corsViolations.get(key)?.length ?? 0) + 1;

  trackEvent(
    corsViolations,
    key,
    "CORS",
    ALERT_THRESHOLDS.cors.alertThreshold,
    safeKey,
  );

  // Only log individual events after threshold to reduce noise
  if (count >= VERBOSE_LOG_THRESHOLD) {
    logger.warn("[CORS] Origin blocked", {
      origin: redactIdentifier(origin),
      endpoint,
      hitCount: count,
      timestamp: new Date().toISOString(),
    });
  }
}

export function trackAuthFailure(identifier: string, reason: string): void {
  const safeIdentifier = redactIdentifier(identifier);
  const count = (authFailures.get(identifier)?.length ?? 0) + 1;

  trackEvent(
    authFailures,
    identifier,
    "Auth",
    ALERT_THRESHOLDS.auth.alertThreshold,
    safeIdentifier,
  );

  // Only log individual events after threshold to reduce noise
  if (count >= VERBOSE_LOG_THRESHOLD) {
    logger.error("[Auth] Authentication failed", {
      identifier: safeIdentifier,
      reason,
      hitCount: count,
      timestamp: new Date().toISOString(),
    });
  }
}

export function getSecurityMetrics() {
  return {
    rateLimitHits: rateLimitHits.size,
    corsViolations: corsViolations.size,
    authFailures: authFailures.size,
    windowMs: WINDOW_MS,
  };
}
