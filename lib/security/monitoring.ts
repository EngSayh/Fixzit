/**
 * Security event monitoring middleware
 * Auto-generated by scripts/security/configure-monitoring.ts
 */

import { logger } from "@/lib/logger";
import { redactIdentifier, hashIdentifier } from "@/lib/otp-utils";

// Rate limit event tracking
const rateLimitHits = new Map<string, number[]>();
const corsViolations = new Map<string, number[]>();
const authFailures = new Map<string, number[]>();

const WINDOW_MS = 5 * 60 * 1000; // 5 minutes
const ALERT_THRESHOLDS = {
  rateLimit: {
    logLevel: "warn",
    alertThreshold: 100,
    destinations: ["console", "file", "webhook"],
  },
  cors: {
    logLevel: "warn",
    alertThreshold: 50,
    destinations: ["console", "file"],
  },
  auth: {
    logLevel: "error",
    alertThreshold: 10,
    destinations: ["console", "file", "webhook"],
  },
  mongodb: {
    logLevel: "error",
    alertThreshold: 5,
    destinations: ["console", "file", "webhook"],
  },
};

async function sendSentryAlert(eventType: string, payload: Record<string, unknown>): Promise<void> {
  // Only attempt in server context with Sentry configured (avoid client bundles)
  if (typeof window !== "undefined") return;
  if (!process.env.SENTRY_DSN || process.env.NODE_ENV !== "production") return;

  try {
    const Sentry = await import("@sentry/nextjs").catch(() => null);
    if (!Sentry) return;

    Sentry.captureMessage(`[Security] ${eventType}`, {
      level: "warning",
      extra: payload,
      tags: {
        security_event: eventType,
      },
    });
  } catch (error) {
    // Avoid throwing from monitoring path
    logger.error("[Security] Failed to send Sentry alert", {
      eventType,
      error: error instanceof Error ? error.message : error,
    });
  }
}

function cleanOldEntries(map: Map<string, number[]>, windowMs: number): void {
  const cutoff = Date.now() - windowMs;
  for (const [key, timestamps] of map.entries()) {
    const filtered = timestamps.filter((t) => t > cutoff);
    if (filtered.length === 0) {
      map.delete(key);
    } else {
      map.set(key, filtered);
    }
  }
}

function trackEvent(
  map: Map<string, number[]>,
  key: string,
  eventType: string,
  threshold: number,
): void {
  cleanOldEntries(map, WINDOW_MS);

  const timestamps = map.get(key) || [];
  timestamps.push(Date.now());
  map.set(key, timestamps);

  // Alert only on FIRST threshold crossing to prevent spam
  // (uses === instead of >= so alert fires exactly once per key per window)
  if (timestamps.length === threshold) {
    logger.warn(`[${eventType}] Alert threshold exceeded`, {
      key,
      count: timestamps.length,
      windowMs: WINDOW_MS,
      threshold,
    });

    // Send to Sentry for centralized monitoring (non-blocking)
    void sendSentryAlert(eventType, {
      key,
      count: timestamps.length,
      threshold,
      windowMs: WINDOW_MS,
    });

    // Emit webhook if configured
    if (process.env.SECURITY_ALERT_WEBHOOK) {
      fetch(process.env.SECURITY_ALERT_WEBHOOK, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          event: eventType,
          key,
          count: timestamps.length,
          threshold,
          timestamp: new Date().toISOString(),
        }),
      }).catch((err) => logger.error("[Webhook] Failed to send alert", err));
    }
  }
}

export function trackRateLimitHit(identifier: string, endpoint: string, orgId?: string): void {
  // Use hashIdentifier for tracking key (better cardinality than 3-char truncation)
  // This prevents collision issues where many users share same prefix (e.g., "use***")
  // Salt is automatically loaded from MONITORING_HASH_SALT or LOG_HASH_SALT env vars
  const hashedId = hashIdentifier(identifier);
  // Include orgId in key for multi-tenant isolation (prevents cross-tenant event collapse)
  const key = orgId 
    ? `${orgId}:${hashedId}:${endpoint}`
    : `global:${hashedId}:${endpoint}`;
  trackEvent(
    rateLimitHits,
    key,
    "RateLimit",
    ALERT_THRESHOLDS.rateLimit.alertThreshold,
  );

  // Use redactIdentifier for human-readable logs (PII protection)
  logger.warn("[RateLimit] Request blocked", {
    orgId: orgId ?? "global",
    identifier: redactIdentifier(identifier),
    endpoint,
    timestamp: new Date().toISOString(),
  });
}

export function trackCorsViolation(origin: string, endpoint: string, orgId?: string): void {
  // Include orgId in key for multi-tenant isolation
  const key = orgId
    ? `${orgId}:${origin}:${endpoint}`
    : `global:${origin}:${endpoint}`;
  trackEvent(corsViolations, key, "CORS", ALERT_THRESHOLDS.cors.alertThreshold);

  logger.warn("[CORS] Origin blocked", {
    orgId: orgId ?? "global",
    origin,
    endpoint,
    timestamp: new Date().toISOString(),
  });
}

export function trackAuthFailure(identifier: string, reason: string, orgId?: string): void {
  // Use hashIdentifier for tracking key (better cardinality than 3-char truncation)
  // This prevents collision issues where many users share same prefix (e.g., "use***")
  // Salt is automatically loaded from MONITORING_HASH_SALT or LOG_HASH_SALT env vars
  const hashedId = hashIdentifier(identifier);
  // Include orgId in key for multi-tenant isolation
  const key = orgId
    ? `${orgId}:${hashedId}`
    : `global:${hashedId}`;
  trackEvent(
    authFailures,
    key,
    "Auth",
    ALERT_THRESHOLDS.auth.alertThreshold,
  );

  // Use redactIdentifier for human-readable logs (PII protection)
  logger.error("[Auth] Authentication failed", {
    orgId: orgId ?? "global",
    identifier: redactIdentifier(identifier),
    reason,
    timestamp: new Date().toISOString(),
  });
}

export function getSecurityMetrics() {
  // Sum actual event counts, not just unique keys
  const sumEvents = (map: Map<string, number[]>): number =>
    [...map.values()].reduce((acc, timestamps) => acc + timestamps.length, 0);

  return {
    rateLimitHits: sumEvents(rateLimitHits),
    corsViolations: sumEvents(corsViolations),
    authFailures: sumEvents(authFailures),
    // Also expose unique key counts for cardinality analysis
    rateLimitUniqueKeys: rateLimitHits.size,
    corsUniqueKeys: corsViolations.size,
    authUniqueKeys: authFailures.size,
    windowMs: WINDOW_MS,
  };
}

export type RateLimitEndpointStats = {
  endpoint: string;
  hits: number;
  uniqueClients: number;
  orgs: string[];
};

/**
 * Summarize rate limit hits by endpoint for dashboards.
 * Does not expose identifiers; aggregates by endpoint and org.
 */
export function getRateLimitBreakdown(): RateLimitEndpointStats[] {
  const breakdown = new Map<
    string,
    { hits: number; uniqueClients: number; orgs: Set<string> }
  >();

  for (const [key, timestamps] of rateLimitHits.entries()) {
    const parts = key.split(":");
    const endpoint = parts.pop() || "unknown";
    const orgId = parts.shift() || "global";
    const current = breakdown.get(endpoint) ?? {
      hits: 0,
      uniqueClients: 0,
      orgs: new Set<string>(),
    };
    current.hits += timestamps.length;
    current.uniqueClients += 1;
    current.orgs.add(orgId);
    breakdown.set(endpoint, current);
  }

  return [...breakdown.entries()]
    .map(([endpoint, data]) => ({
      endpoint,
      hits: data.hits,
      uniqueClients: data.uniqueClients,
      orgs: Array.from(data.orgs),
    }))
    .sort((a, b) => b.hits - a.hits);
}

/**
 * Reset all monitoring state for test isolation.
 * 
 * ⚠️ TEST-ONLY: This function clears all tracking maps and should ONLY be used
 * in test environments to prevent cross-test contamination. The monitoring maps
 * are process-global, so without reset, tests can become order-dependent and flaky.
 * 
 * @example
 * // In test file:
 * import { __resetMonitoringStateForTests } from "@/lib/security/monitoring";
 * beforeEach(() => __resetMonitoringStateForTests());
 */
export function __resetMonitoringStateForTests(): void {
  // Allow vitest workers even if NODE_ENV toggled by framework
  const isTestHarness = process.env.VITEST_WORKER_ID || process.env.NODE_ENV === "test";
  if (!isTestHarness && process.env.NODE_ENV === "production") {
    logger.error("[Security] __resetMonitoringStateForTests called in production - ignoring");
    return;
  }
  rateLimitHits.clear();
  corsViolations.clear();
  authFailures.clear();
}
