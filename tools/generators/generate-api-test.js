#!/usr/bin/env node
/**
 * API Test Template Generator
 * 
 * Generates test files for API routes based on their structure.
 * 
 * Usage:
 *   node tools/generators/generate-api-test.js app/api/souq/catalog/products/route.ts
 *   node tools/generators/generate-api-test.js --module souq --dry-run
 * 
 * Options:
 *   --module <name>  Generate tests for all routes in a module (souq, fm, finance, hr, admin)
 *   --dry-run        Show what would be generated without creating files
 *   --force          Overwrite existing test files
 */

const fs = require('fs');
const path = require('path');

// Parse command line arguments
const args = process.argv.slice(2);
const flags = {
  dryRun: args.includes('--dry-run'),
  force: args.includes('--force'),
  module: args.find((a, i) => args[i - 1] === '--module'),
};
const routePath = args.find(a => !a.startsWith('--') && args[args.indexOf(a) - 1] !== '--module');

/**
 * Extract HTTP methods from route file content
 */
function extractMethods(content) {
  const methods = [];
  if (/export\s+(async\s+)?function\s+GET/m.test(content)) methods.push('GET');
  if (/export\s+(async\s+)?function\s+POST/m.test(content)) methods.push('POST');
  if (/export\s+(async\s+)?function\s+PUT/m.test(content)) methods.push('PUT');
  if (/export\s+(async\s+)?function\s+PATCH/m.test(content)) methods.push('PATCH');
  if (/export\s+(async\s+)?function\s+DELETE/m.test(content)) methods.push('DELETE');
  if (/export\s+const\s+\{\s*GET/.test(content)) methods.push('GET');
  if (/export\s+const\s+\{\s*POST/.test(content) || /export\s+const\s+\{[^}]*POST/.test(content)) methods.push('POST');
  return methods;
}

/**
 * Check if route uses Zod validation
 */
function hasZodValidation(content) {
  return /import\s+.*\s+from\s+['"]zod['"]/.test(content) || 
         /z\.(object|string|number|array|enum)/.test(content);
}

/**
 * Generate test template for a route
 */
function generateTestTemplate(routeFilePath, methods, hasZod) {
  const relativePath = routeFilePath.replace(/^app\//, '').replace(/\/route\.ts$/, '');
  const apiPath = '/' + relativePath.replace(/\[(\w+)\]/g, ':$1');
  const testPath = `tests/api/${relativePath.replace('api/', '')}.route.test.ts`;
  
  // Extract module and resource name
  const parts = relativePath.split('/');
  const moduleName = parts[1] || 'api';
  const resourceName = parts[parts.length - 1] || 'resource';
  const hasIdParam = routeFilePath.includes('[id]') || routeFilePath.includes('[');

  let template = `/**
 * @fileoverview API Tests for ${apiPath}
 * @generated by tools/generators/generate-api-test.js
 */
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NextRequest } from 'next/server';
${methods.map(m => `import { ${m} } from '@/${routeFilePath.replace('.ts', '')}';`).join('\n')}

// Mock dependencies
vi.mock('@/lib/mongodb-unified', () => ({
  connectToDatabase: vi.fn().mockResolvedValue(undefined),
}));

vi.mock('@/server/middleware/withAuthRbac', () => ({
  getSessionUser: vi.fn(),
}));

import { getSessionUser } from '@/server/middleware/withAuthRbac';
const mockGetSessionUser = vi.mocked(getSessionUser);

describe('${moduleName.toUpperCase()} ${resourceName} API', () => {
  const baseUrl = 'http://localhost:3000${apiPath.replace(/:(\w+)/g, 'test-$1')}';
  
  beforeEach(() => {
    vi.clearAllMocks();
  });

`;

  // Generate GET tests
  if (methods.includes('GET')) {
    template += `
  describe('GET ${apiPath}', () => {
    it('returns 401 for unauthenticated requests', async () => {
      mockGetSessionUser.mockRejectedValueOnce(new Error('Unauthorized'));
      
      const request = new NextRequest(baseUrl);
      const response = await GET(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect(response.status).toBe(401);
    });

    it('returns 401 when orgId is missing', async () => {
      mockGetSessionUser.mockResolvedValueOnce({ id: 'user-1', role: 'USER' } as never);
      
      const request = new NextRequest(baseUrl);
      const response = await GET(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect(response.status).toBe(401);
    });

    it('returns data for authenticated user with orgId', async () => {
      mockGetSessionUser.mockResolvedValueOnce({
        id: 'user-1',
        orgId: 'org-1',
        role: 'ADMIN',
      } as never);
      
      const request = new NextRequest(baseUrl);
      const response = await GET(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      // CUSTOMIZE: Mock the model to return test data
      expect([200, 404, 500]).toContain(response.status);
    });

    it('supports pagination parameters', async () => {
      mockGetSessionUser.mockResolvedValueOnce({
        id: 'user-1',
        orgId: 'org-1',
        role: 'ADMIN',
      } as never);
      
      const request = new NextRequest(\`\${baseUrl}?page=1&limit=10\`);
      const response = await GET(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect([200, 404, 500]).toContain(response.status);
    });
  });
`;
  }

  // Generate POST tests
  if (methods.includes('POST')) {
    template += `
  describe('POST ${apiPath}', () => {
    it('returns 401 for unauthenticated requests', async () => {
      mockGetSessionUser.mockRejectedValueOnce(new Error('Unauthorized'));
      
      const request = new NextRequest(baseUrl, {
        method: 'POST',
        body: JSON.stringify({}),
        headers: { 'Content-Type': 'application/json' },
      });
      const response = await POST(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect(response.status).toBe(401);
    });

    it('returns 401 when orgId is missing', async () => {
      mockGetSessionUser.mockResolvedValueOnce({ id: 'user-1', role: 'USER' } as never);
      
      const request = new NextRequest(baseUrl, {
        method: 'POST',
        body: JSON.stringify({}),
        headers: { 'Content-Type': 'application/json' },
      });
      const response = await POST(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect(response.status).toBe(401);
    });
${hasZod ? `
    it('validates required fields with Zod', async () => {
      mockGetSessionUser.mockResolvedValueOnce({
        id: 'user-1',
        orgId: 'org-1',
        role: 'ADMIN',
      } as never);
      
      const request = new NextRequest(baseUrl, {
        method: 'POST',
        body: JSON.stringify({}),
        headers: { 'Content-Type': 'application/json' },
      });
      const response = await POST(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      // Empty body should fail validation
      expect([400, 422]).toContain(response.status);
    });
` : ''}
    it('creates resource with valid data', async () => {
      mockGetSessionUser.mockResolvedValueOnce({
        id: 'user-1',
        orgId: 'org-1',
        role: 'ADMIN',
      } as never);
      
      // CUSTOMIZE: Add valid request body for this endpoint
      const validBody = {};
      
      const request = new NextRequest(baseUrl, {
        method: 'POST',
        body: JSON.stringify(validBody),
        headers: { 'Content-Type': 'application/json' },
      });
      const response = await POST(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      // CUSTOMIZE: Mock the model to verify creation
      expect([200, 201, 400, 500]).toContain(response.status);
    });
  });
`;
  }

  // Generate PUT/PATCH tests
  if (methods.includes('PUT') || methods.includes('PATCH')) {
    const method = methods.includes('PUT') ? 'PUT' : 'PATCH';
    template += `
  describe('${method} ${apiPath}', () => {
    it('returns 401 for unauthenticated requests', async () => {
      mockGetSessionUser.mockRejectedValueOnce(new Error('Unauthorized'));
      
      const request = new NextRequest(baseUrl, {
        method: '${method}',
        body: JSON.stringify({}),
        headers: { 'Content-Type': 'application/json' },
      });
      const response = await ${method}(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect(response.status).toBe(401);
    });

    it('updates resource with valid data', async () => {
      mockGetSessionUser.mockResolvedValueOnce({
        id: 'user-1',
        orgId: 'org-1',
        role: 'ADMIN',
      } as never);
      
      // CUSTOMIZE: Add valid update body for this endpoint
      const updateBody = {};
      
      const request = new NextRequest(baseUrl, {
        method: '${method}',
        body: JSON.stringify(updateBody),
        headers: { 'Content-Type': 'application/json' },
      });
      const response = await ${method}(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect([200, 400, 404, 500]).toContain(response.status);
    });
  });
`;
  }

  // Generate DELETE tests
  if (methods.includes('DELETE')) {
    template += `
  describe('DELETE ${apiPath}', () => {
    it('returns 401 for unauthenticated requests', async () => {
      mockGetSessionUser.mockRejectedValueOnce(new Error('Unauthorized'));
      
      const request = new NextRequest(baseUrl, { method: 'DELETE' });
      const response = await DELETE(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect(response.status).toBe(401);
    });

    it('deletes resource for authenticated user', async () => {
      mockGetSessionUser.mockResolvedValueOnce({
        id: 'user-1',
        orgId: 'org-1',
        role: 'ADMIN',
      } as never);
      
      const request = new NextRequest(baseUrl, { method: 'DELETE' });
      const response = await DELETE(request${hasIdParam ? ', { params: Promise.resolve({ id: "test-id" }) }' : ''});
      
      expect([200, 204, 404, 500]).toContain(response.status);
    });
  });
`;
  }

  template += `});
`;

  return { testPath, template };
}

/**
 * Find all routes in a module
 */
function findModuleRoutes(moduleName) {
  const modulePath = path.join(process.cwd(), 'app', 'api', moduleName);
  const routes = [];
  
  function scanDir(dir) {
    if (!fs.existsSync(dir)) return;
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        scanDir(fullPath);
      } else if (entry.name === 'route.ts') {
        routes.push(fullPath.replace(process.cwd() + '/', ''));
      }
    }
  }
  
  scanDir(modulePath);
  return routes;
}

/**
 * Main execution
 */
function main() {
  let routesToProcess = [];
  
  if (flags.module) {
    routesToProcess = findModuleRoutes(flags.module);
    console.log(`üìÇ Found ${routesToProcess.length} routes in module: ${flags.module}`);
  } else if (routePath) {
    routesToProcess = [routePath];
  } else {
    console.log(`
API Test Template Generator

Usage:
  node tools/generators/generate-api-test.js <route-file>
  node tools/generators/generate-api-test.js --module <name>

Examples:
  node tools/generators/generate-api-test.js app/api/souq/catalog/products/route.ts
  node tools/generators/generate-api-test.js --module souq --dry-run
  node tools/generators/generate-api-test.js --module fm --force

Options:
  --module <name>  Generate tests for all routes in a module
  --dry-run        Show what would be generated without creating files
  --force          Overwrite existing test files
`);
    process.exit(1);
  }

  let generated = 0;
  let skipped = 0;
  
  for (const route of routesToProcess) {
    const fullPath = path.join(process.cwd(), route);
    
    if (!fs.existsSync(fullPath)) {
      console.log(`‚ùå Route not found: ${route}`);
      skipped++;
      continue;
    }
    
    const content = fs.readFileSync(fullPath, 'utf8');
    const methods = extractMethods(content);
    const hasZod = hasZodValidation(content);
    
    if (methods.length === 0) {
      console.log(`‚è≠Ô∏è  Skipping ${route} (no HTTP methods found)`);
      skipped++;
      continue;
    }
    
    const { testPath, template } = generateTestTemplate(route, methods, hasZod);
    const fullTestPath = path.join(process.cwd(), testPath);
    
    if (fs.existsSync(fullTestPath) && !flags.force) {
      console.log(`‚è≠Ô∏è  Skipping ${testPath} (already exists, use --force to overwrite)`);
      skipped++;
      continue;
    }
    
    if (flags.dryRun) {
      console.log(`üìù Would generate: ${testPath}`);
      console.log(`   Methods: ${methods.join(', ')}`);
      console.log(`   Zod validation: ${hasZod ? 'Yes' : 'No'}`);
    } else {
      // Create directory if needed
      const testDir = path.dirname(fullTestPath);
      if (!fs.existsSync(testDir)) {
        fs.mkdirSync(testDir, { recursive: true });
      }
      
      fs.writeFileSync(fullTestPath, template);
      console.log(`‚úÖ Generated: ${testPath}`);
    }
    
    generated++;
  }
  
  console.log(`
üìä Summary:
   Generated: ${generated}
   Skipped: ${skipped}
   Total: ${routesToProcess.length}
`);
}

main();
