
You are the "Fixzit Memory Builder" for category: "components".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "components",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="components/ui/IconButton.tsx">
<![CDATA[
"use client";

import React, { forwardRef } from 'react';
import { cn } from '@/lib/utils';
import { SimpleTooltip } from '@/components/ui/tooltip';

export interface IconButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  /** Tooltip content - if provided, wraps button in Tooltip */
  tooltip?: string;
  /** Icon to display */
  icon: React.ReactNode;
  /** Size variant */
  size?: 'sm' | 'md' | 'lg';
  /** Visual variant */
  variant?: 'default' | 'ghost' | 'outline' | 'destructive' | 'primary';
  /** Whether the button is in a loading state */
  loading?: boolean;
  /** Badge count to show */
  badge?: number;
  /** Whether to show badge as a dot only */
  badgeDot?: boolean;
}

const sizeClasses = {
  sm: 'h-8 w-8',
  md: 'h-10 w-10',
  lg: 'h-12 w-12',
};

const iconSizeClasses = {
  sm: '[&>svg]:h-4 [&>svg]:w-4',
  md: '[&>svg]:h-5 [&>svg]:w-5',
  lg: '[&>svg]:h-6 [&>svg]:w-6',
};

const variantClasses = {
  default: 'bg-muted text-muted-foreground hover:bg-muted/80 hover:text-foreground',
  ghost: 'hover:bg-muted hover:text-foreground',
  outline: 'border border-border bg-background hover:bg-muted',
  destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
  primary: 'bg-primary text-primary-foreground hover:bg-primary/90',
};

/**
 * IconButton - A reusable icon button with optional tooltip.
 * 
 * Features:
 * - Built-in tooltip support
 * - Badge/notification dot
 * - Loading state
 * - Multiple size and variant options
 * - Accessible with aria-label
 * 
 * @example
 * ```tsx
 * <IconButton
 *   icon={<Bell />}
 *   tooltip="Notifications"
 *   aria-label="View notifications"
 *   badge={5}
 * />
 * ```
 */
const IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(
  (
    {
      tooltip,
      icon,
      size = 'md',
      variant = 'ghost',
      loading = false,
      badge,
      badgeDot = false,
      className,
      disabled,
      children,
      ...props
    },
    ref
  ) => {
    const button = (
      <button
        ref={ref}
        type="button"
        disabled={disabled || loading}
        className={cn(
          'relative inline-flex items-center justify-center rounded-full transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
          sizeClasses[size],
          iconSizeClasses[size],
          variantClasses[variant],
          className
        )}
        data-cursor-interactive
        {...props}
      >
        {loading ? (
          <span className="animate-spin">
            <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24">
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
              />
            </svg>
          </span>
        ) : (
          icon
        )}
        {children}
        
        {/* Badge */}
        {(badge !== undefined && badge > 0) && !badgeDot && (
          <span className="absolute -top-1 -end-1 flex h-5 min-w-5 items-center justify-center rounded-full bg-destructive px-1 text-[10px] font-bold text-destructive-foreground">
            {badge > 99 ? '99+' : badge}
          </span>
        )}
        
        {/* Badge Dot */}
        {badgeDot && (
          <span className="absolute -top-0.5 -end-0.5 h-2.5 w-2.5 rounded-full bg-destructive animate-pulse" />
        )}
      </button>
    );

    if (tooltip) {
      return (
        <SimpleTooltip content={tooltip}>
          {button}
        </SimpleTooltip>
      );
    }

    return button;
  }
);

IconButton.displayName = 'IconButton';

export { IconButton };
export default IconButton;

]]>
</file>

<file path="components/ui/ResponsiveContainer.tsx">
<![CDATA[
"use client";

import React from "react";
import { useResponsiveLayout } from "@/contexts/ResponsiveContext";

interface ResponsiveContainerProps {
  children: React.ReactNode;
  className?: string;
  size?: "mobile" | "tablet" | "desktop" | "large" | "auto";
  padding?: "none" | "small" | "medium" | "large";
  centered?: boolean;
}

export function ResponsiveContainer({
  children,
  className = "",
  size = "auto",
  padding = "medium",
  centered = true,
}: ResponsiveContainerProps) {
  const { responsiveClasses } = useResponsiveLayout();

  const getContainerClass = () => {
    if (size !== "auto") {
      switch (size) {
        case "mobile":
          return "max-w-sm mx-auto px-4";
        case "tablet":
          return "max-w-2xl mx-auto px-6";
        case "desktop":
          return "max-w-6xl mx-auto px-8";
        case "large":
          return "max-w-7xl mx-auto px-8";
        default:
          return responsiveClasses.container;
      }
    }
    return responsiveClasses.container;
  };

  const getPaddingClass = () => {
    switch (padding) {
      case "none":
        return "";
      case "small":
        return "p-2 sm:p-3";
      case "medium":
        return "p-4 sm:p-6";
      case "large":
        return "p-6 sm:p-8";
      default:
        return "p-4 sm:p-6";
    }
  };

  const containerClass = getContainerClass();
  const paddingClass = getPaddingClass();

  return (
    <div
      className={`${containerClass} ${paddingClass} ${centered ? "mx-auto" : ""} ${className}`}
    >
      {children}
    </div>
  );
}

// Responsive grid component
interface ResponsiveGridProps {
  children: React.ReactNode;
  cols?: {
    mobile?: number;
    tablet?: number;
    desktop?: number;
    large?: number;
  };
  gap?: "small" | "medium" | "large";
  className?: string;
}

export function ResponsiveGrid({
  children,
  cols = { mobile: 1, tablet: 2, desktop: 3, large: 4 },
  gap = "medium",
  className = "",
}: ResponsiveGridProps) {
  const { screenInfo } = useResponsiveLayout();

  const getGridCols = () => {
    const width = screenInfo.width || 1024;
    if (screenInfo.isMobile || width < 640) {
      return `grid-cols-${cols.mobile || 1}`;
    }
    if (screenInfo.isTablet || width < 1024) {
      return `grid-cols-${cols.tablet || 2}`;
    }
    // Fixed: Changed OR to AND - both conditions must be true for desktop
    if (screenInfo.isDesktop && width < 1280) {
      return `grid-cols-${cols.desktop || 3}`;
    }
    return `grid-cols-${cols.large || 4}`;
  };

  const getGapClass = () => {
    switch (gap) {
      case "small":
        return "gap-2";
      case "medium":
        return "gap-4";
      case "large":
        return "gap-6";
      default:
        return "gap-4";
    }
  };

  return (
    <div className={`grid ${getGridCols()} ${getGapClass()} ${className}`}>
      {children}
    </div>
  );
}

// Responsive text component
interface ResponsiveTextProps {
  children: React.ReactNode;
  size?: "small" | "medium" | "large" | "xlarge";
  weight?: "normal" | "medium" | "semibold" | "bold";
  className?: string;
}

export function ResponsiveText({
  children,
  size = "medium",
  weight = "normal",
  className = "",
}: ResponsiveTextProps) {
  const { screenInfo } = useResponsiveLayout();

  const getSizeClass = () => {
    const baseSizes = {
      small: "text-sm",
      medium: "text-base",
      large: "text-lg",
      xlarge: "text-xl",
    };

    if (screenInfo.isMobile) {
      const sizeMap = {
        small: "text-xs",
        medium: "text-sm",
        large: "text-base",
        xlarge: "text-lg",
      };
      return sizeMap[size];
    }

    return baseSizes[size];
  };

  const getWeightClass = () => {
    const weightMap = {
      normal: "font-normal",
      medium: "font-medium",
      semibold: "font-semibold",
      bold: "font-bold",
    };
    return weightMap[weight];
  };

  return (
    <span className={`${getSizeClass()} ${getWeightClass()} ${className}`}>
      {children}
    </span>
  );
}

// Responsive spacing component
interface ResponsiveSpacingProps {
  children: React.ReactNode;
  spacing?: "small" | "medium" | "large";
  direction?: "vertical" | "horizontal";
  className?: string;
}

export function ResponsiveSpacing({
  children,
  spacing = "medium",
  direction = "vertical",
  className = "",
}: ResponsiveSpacingProps) {
  const { screenInfo } = useResponsiveLayout();

  const getSpacingClass = () => {
    const baseSpacing = {
      small: direction === "vertical" ? "space-y-2" : "space-x-2",
      medium: direction === "vertical" ? "space-y-4" : "space-x-4",
      large: direction === "vertical" ? "space-y-6" : "space-x-6",
    };

    if (screenInfo.isMobile) {
      const mobileSpacing = {
        small: direction === "vertical" ? "space-y-1" : "space-x-1",
        medium: direction === "vertical" ? "space-y-2" : "space-x-2",
        large: direction === "vertical" ? "space-y-3" : "space-x-3",
      };
      return mobileSpacing[spacing];
    }

    return baseSpacing[spacing];
  };

  return <div className={`${getSpacingClass()} ${className}`}>{children}</div>;
}

]]>
</file>

<file path="components/ui/alert.tsx">
<![CDATA[
import * as React from "react";
import { cn } from "@/lib/utils";

type AlertVariant = "default" | "destructive" | "info";

const variantClasses: Record<AlertVariant, string> = {
  default: "bg-primary/10 border-primary/30 text-primary",
  destructive: "bg-destructive/10 border-destructive/30 text-destructive",
  info: "bg-muted border-border text-muted-foreground",
};

export interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: AlertVariant;
}

export const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant = "default", ...props }, ref) => (
    <div
      ref={ref}
      role="alert"
      className={cn(
        "w-full rounded-lg border p-4 text-sm",
        variantClasses[variant],
        className,
      )}
      {...props}
    />
  ),
);
Alert.displayName = "Alert";

export const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

export const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm leading-relaxed text-inherit", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

]]>
</file>

<file path="components/ui/badge.tsx">
<![CDATA[
import React from "react";

// FIX: Add new variants from design system
type BadgeVariant =
  | "default"
  | "secondary"
  | "destructive"
  | "outline"
  | "success"
  | "warning"
  | "info";

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: BadgeVariant;
}

// Helper function for class merging
function cn(...inputs: (string | undefined | null | false)[]): string {
  return inputs.filter(Boolean).join(" ");
}

export const Badge = ({
  className = "",
  variant = "default",
  ...props
}: BadgeProps) => {
  // FIX: Mapped variants to semantic tokens from tailwind.config.js
  const variants: Record<BadgeVariant, string> = {
    default: "bg-primary text-primary-foreground hover:bg-primary/90",
    secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
    destructive:
      "bg-destructive text-destructive-foreground hover:bg-destructive/90",
    outline:
      "border border-border text-foreground hover:bg-accent hover:text-accent-foreground",
    // FIX: Added missing status variants
    success: "bg-success text-success-foreground hover:bg-success/90",
    warning: "bg-warning text-warning-foreground hover:bg-warning/90",
    info: "bg-info text-info-foreground hover:bg-info/90",
  };

  return (
    <div
      className={cn(
        "inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2",
        variants[variant],
        className,
      )}
      {...props}
    />
  );
};

]]>
</file>

<file path="components/ui/button.tsx">
<![CDATA[
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

// Helper function for class merging
function cn(...inputs: (string | undefined | null | false)[]): string {
  return inputs.filter(Boolean).join(" ");
}

// FIX: Define variants using cva and semantic tokens from design system
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        success: "bg-success text-success-foreground hover:bg-success/90",
        outline:
          "border border-border bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };

]]>
</file>

<file path="components/ui/card.tsx">
<![CDATA[
import * as React from "react";

// Helper function for class merging
function cn(...inputs: (string | undefined | null | false)[]): string {
  return inputs.filter(Boolean).join(" ");
}

// --- Card ---
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    // FIX: Use rounded-2xl (16px) per Design System, semantic tokens for dark mode
    className={cn(
      "rounded-2xl border border-border bg-card text-card-foreground shadow-sm",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

// --- CardHeader ---
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

// --- CardTitle ---
const CardTitle = React.forwardRef<
  HTMLHeadingElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

// --- CardDescription ---
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

// --- CardContent ---
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

// --- CardFooter ---
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
  CardFooter,
};

]]>
</file>

<file path="components/ui/checkbox.tsx">
<![CDATA[
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";

export interface CheckboxProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  onCheckedChange?: (_checked: boolean) => void;
}

export const Checkbox = React.forwardRef<HTMLInputElement, CheckboxProps>(
  ({ className, onCheckedChange, onChange, ...props }, ref) => {
    return (
      <input
        ref={ref}
        type="checkbox"
        className={cn(
          "h-4 w-4 rounded border border-border text-primary focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70",
          className,
        )}
        onChange={(event) => {
          onChange?.(event);
          onCheckedChange?.(event.target.checked);
        }}
        {...props}
      />
    );
  },
);
Checkbox.displayName = "Checkbox";

]]>
</file>

<file path="components/ui/dialog.tsx">
<![CDATA[
import React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

// --- Dialog Root ---
export const Dialog = DialogPrimitive.Root;

// --- DialogTrigger ---
export const DialogTrigger = DialogPrimitive.Trigger;

// --- DialogPortal ---
export const DialogPortal = DialogPrimitive.Portal;

// --- DialogOverlay ---
export const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm",
      "data-[state=open]:animate-in data-[state=closed]:animate-out",
      "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

// --- DialogContent ---
export const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 translate-x-[-50%] translate-y-[-50%]",
        "w-full max-w-lg bg-popover text-popover-foreground",
        "border border-border shadow-lg rounded-2xl p-6",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "data-[state=closed]:slide-out-to-start-1/2 data-[state=closed]:slide-out-to-top-[48%]",
        "data-[state=open]:slide-in-from-start-1/2 data-[state=open]:slide-in-from-top-[48%]",
        "duration-200",
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute end-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

// --- DialogHeader ---
export const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("flex flex-col space-y-1.5 text-start", className)}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

// --- DialogFooter ---
export const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 mt-4",
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

// --- DialogTitle ---
export const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight text-foreground",
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

// --- DialogDescription ---
export const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

]]>
</file>

<file path="components/ui/feature-toggle-skeleton.tsx">
<![CDATA[
/**
 * Skeleton loader for FeatureToggle components
 * Provides better perceived performance during initial load
 */
export function FeatureToggleSkeleton() {
  return (
    <div className="flex items-center justify-between p-4 border-b border-border last:border-b-0 animate-pulse">
      <div className="flex-1">
        <div className="h-4 bg-muted rounded-2xl w-1/3 mb-2"></div>
        <div className="h-3 bg-muted rounded-2xl w-2/3"></div>
      </div>
      <div className="ms-4">
        <div className="w-11 h-6 bg-muted rounded-full"></div>
      </div>
    </div>
  );
}

interface FeatureToggleGroupSkeletonProps {
  /**
   * Number of skeleton toggle items to render (defaults to 3)
   */
  count?: number;
}

/**
 * Skeleton loader for FeatureToggleGroup
 */
export function FeatureToggleGroupSkeleton({
  count = 3,
}: FeatureToggleGroupSkeletonProps = {}) {
  return (
    <div className="bg-card rounded-2xl shadow-sm border border-border overflow-hidden">
      <div className="p-4 border-b border-border animate-pulse">
        <div className="h-5 bg-muted rounded-2xl w-1/4 mb-2"></div>
        <div className="h-3 bg-muted rounded-2xl w-1/2"></div>
      </div>
      <div>
        {Array.from({ length: count }).map((_, i) => (
          <FeatureToggleSkeleton key={i} />
        ))}
      </div>
    </div>
  );
}

]]>
</file>

<file path="components/ui/feature-toggle.tsx">
<![CDATA[
"use client";

import React from "react";

interface FeatureToggleProps {
  /**
   * Unique identifier for the feature
   */
  id: string;

  /**
   * Display name of the feature
   */
  label: string;

  /**
   * Optional description or help text
   */
  description?: string;

  /**
   * Current state of the toggle
   */
  enabled: boolean;

  /**
   * Callback when toggle state changes
   */
  onChange: (enabled: boolean) => void;

  /**
   * Whether the toggle is disabled
   */
  disabled?: boolean;

  /**
   * Show loading state
   */
  loading?: boolean;

  /**
   * Show warning badge (e.g., "Beta", "Experimental")
   */
  badge?: string;

  /**
   * Danger mode - shows red when enabled (for destructive features)
   */
  danger?: boolean;

  /**
   * Show lock icon (feature requires upgrade)
   */
  locked?: boolean;

  /**
   * Callback when locked feature is clicked
   */
  onLockedClick?: () => void;

  /**
   * Additional CSS classes
   */
  className?: string;
}

/**
 * iOS-style Feature Toggle Component
 *
 * Used for admin settings to enable/disable features across the platform.
 * Includes accessibility features, loading states, and premium indicators.
 *
 * @example
 * ```tsx
 * <FeatureToggle
 *   id="referral-program"
 *   label="Referral Program"
 *   description="Allow users to refer others and earn rewards"
 *   enabled={settings.referralProgram}
 *   onChange={(enabled) => updateSetting('referralProgram', enabled)}
 *   badge="New"
 * />
 * ```
 */
export const FeatureToggle: React.FC<FeatureToggleProps> = ({
  id,
  label,
  description,
  enabled,
  onChange,
  disabled = false,
  loading = false,
  badge,
  danger = false,
  locked = false,
  onLockedClick,
  className = "",
}) => {
  const handleToggle = (checked: boolean) => {
    if (locked && onLockedClick) {
      onLockedClick();
      return;
    }

    if (!locked && !loading && !disabled) {
      onChange(checked);
    }
  };

  // `toggleColor` was previously computed but unused; styling is handled inline in the JSX

  return (
    <div
      className={`flex items-center justify-between py-3 px-4 rounded-2xl hover:bg-muted dark:hover:bg-gray-800 transition-colors ${className}`}
      data-feature-id={id}
    >
      {/* Left Side: Label & Description */}
      <div className="flex-1 min-w-0 me-4">
        <div className="flex items-center gap-2">
          <label
            htmlFor={id}
            className="text-sm font-medium text-foreground dark:text-white cursor-pointer"
          >
            {label}
          </label>

          {/* Badge */}
          {badge && (
            <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-primary/10 text-primary dark:bg-primary dark:text-primary">
              {badge}
            </span>
          )}

          {/* Lock Icon */}
          {locked && (
            <svg
              className="w-4 h-4 text-muted-foreground"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
              />
            </svg>
          )}
        </div>

        {/* Description */}
        {description && (
          <p className="mt-1 text-sm text-muted-foreground dark:text-muted-foreground">
            {description}
          </p>
        )}
      </div>

      {/* Right Side: Toggle Switch */}
      <div className="flex-shrink-0">
        {loading ? (
          /* Loading Spinner */
          <div className="inline-flex h-6 w-11 items-center justify-center">
            <svg
              className="animate-spin h-5 w-5 text-muted-foreground"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              aria-hidden="true"
              focusable="false"
            >
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
          </div>
        ) : (
          <button
            id={id}
            type="button"
            role="switch"
            aria-checked={enabled}
            aria-label={`Toggle ${label}`}
            disabled={disabled}
            onClick={() => handleToggle(!enabled)}
            className={`
              relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2
              ${disabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}
              ${locked ? "cursor-help" : ""}
              ${danger && enabled ? "focus:ring-red-500 bg-destructive" : enabled ? "focus:ring-green-500 bg-success" : "focus:ring-gray-400 bg-muted"}
            `}
          >
            {/* Toggle Knob */}
            <span
              aria-hidden="true"
              className={`
                pointer-events-none inline-block h-5 w-5 transform rounded-full bg-card shadow ring-0 transition duration-200 ease-in-out
                ${enabled ? "translate-x-5" : "translate-x-0"}
              `}
            />
          </button>
        )}
      </div>
    </div>
  );
};

/**
 * Feature Toggle Group Component
 *
 * Groups related feature toggles with a section header
 */
interface FeatureToggleGroupProps {
  title: string;
  description?: string;
  children: React.ReactNode;
  className?: string;
}

export const FeatureToggleGroup: React.FC<FeatureToggleGroupProps> = ({
  title,
  description,
  children,
  className = "",
}) => {
  return (
    <div className={`space-y-2 ${className}`}>
      <div className="px-4 py-2">
        <h3 className="text-base font-semibold text-foreground dark:text-white">
          {title}
        </h3>
        {description && (
          <p className="mt-1 text-sm text-muted-foreground dark:text-muted-foreground">
            {description}
          </p>
        )}
      </div>
      <div className="bg-card dark:bg-gray-900 rounded-2xl border border-border dark:border-gray-700 divide-y divide-border dark:divide-gray-700">
        {children}
      </div>
    </div>
  );
};

export default FeatureToggle;

]]>
</file>

<file path="components/ui/input.tsx">
<![CDATA[
import React from "react";

type InputProps = React.InputHTMLAttributes<HTMLInputElement>;

export const Input: React.FC<InputProps> = ({ className = "", ...props }) => {
  return (
    <input
      className={`flex h-10 w-full rounded-2xl border border-border bg-card px-3 py-2 text-sm ring-offset-white file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${className}`}
      {...props}
    />
  );
};

]]>
</file>

<file path="components/ui/label.tsx">
<![CDATA[
import React from "react";

type LabelProps = React.LabelHTMLAttributes<HTMLLabelElement>;

export const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className = "", ...props }, ref) => {
    return (
      <label
        ref={ref}
        className={`text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 ${className}`}
        {...props}
      />
    );
  },
);

Label.displayName = "Label";

]]>
</file>

<file path="components/ui/navigation-buttons.tsx">
<![CDATA[
"use client";

import React from "react";
import { useRouter } from "next/navigation";
import { useTranslation } from "@/contexts/TranslationContext";
import { Button } from "@/components/ui/button";
import { ArrowLeft, ArrowRight, Home, Save, Loader2 } from "lucide-react";

interface NavigationButtonsProps {
  /**
   * Show Save button
   */
  showSave?: boolean;

  /**
   * Show Back button
   */
  showBack?: boolean;

  /**
   * Show Home button
   */
  showHome?: boolean;

  /**
   * Save button callback. May optionally accept the submit event.
   */
  onSave?: (e?: React.FormEvent) => void | Promise<void>;

  /**
   * Save button type: 'button' (default) or 'submit' (for forms)
   */
  saveType?: "button" | "submit";

  /**
   * Custom back URL (defaults to browser back)
   */
  backUrl?: string;

  /**
   * Custom home URL (defaults to /dashboard)
   */
  homeUrl?: string;

  /**
   * Save button loading state
   */
  saving?: boolean;

  /**
   * Save button disabled state
   */
  saveDisabled?: boolean;

  /**
   * Save button i18n key (defaults to 'common.save')
   */
  saveLabelKey?: string;

  /**
   * Position of the buttons
   */
  position?: "top" | "bottom" | "both";

  /**
   * Additional CSS classes
   */
  className?: string;
}

/**
 * Standardized Navigation Buttons Component
 *
 * Provides consistent Save/Back/Home buttons across all pages.
 * Follows the global UI/UX enhancement requirements.
 *
 * @example
 * ```tsx
 * <NavigationButtons
 *   showSave
 *   showBack
 *   showHome
 *   onSave={handleSave}
 *   saving={isSaving}
 * />
 * ```
 */
export const NavigationButtons: React.FC<NavigationButtonsProps> = ({
  showSave = false,
  showBack = true,
  showHome = true,
  onSave,
  saveType = "button",
  backUrl,
  homeUrl = "/dashboard",
  saving = false,
  saveDisabled = false,
  saveLabelKey = "common.save",
  position = "bottom",
  className = "",
}) => {
  const router = useRouter();
  const { t, isRTL } = useTranslation();

  // FIX: RTL-aware icons
  const BackIcon = isRTL ? ArrowRight : ArrowLeft;

  const handleBack = () => {
    if (backUrl) {
      router.push(backUrl);
    } else {
      router.back();
    }
  };

  const handleHome = () => {
    router.push(homeUrl);
  };

  const handleSave = async (e?: React.FormEvent) => {
    // Only preventDefault if type="button" and we have a click handler
    if (saveType === "button" && e) {
      e.preventDefault();
    }
    if (onSave && !saving && !saveDisabled) {
      await onSave(e);
    }
  };

  const buttons = (
    <div className={`flex items-center justify-between gap-3 ${className}`}>
      {/* Left side: Back & Home */}
      <div className="flex items-center gap-2">
        {showBack && (
          <Button onClick={handleBack} variant="outline" type="button">
            <BackIcon className="h-4 w-4 me-2" />
            {t("navigation.back", "Back")}
          </Button>
        )}

        {showHome && (
          <Button onClick={handleHome} variant="outline" type="button">
            <Home className="h-4 w-4 me-2" />
            {t("navigation.home", "Home")}
          </Button>
        )}
      </div>

      {/* Right side: Save */}
      {showSave && (
        <Button
          onClick={saveType === "button" ? handleSave : undefined}
          disabled={saving || saveDisabled}
          variant="default"
          type={saveType}
        >
          {saving ? (
            <>
              <Loader2 className="h-4 w-4 me-2 animate-spin" />
              {t("navigation.saving", "Saving...")}
            </>
          ) : (
            <>
              <Save className="h-4 w-4 me-2" />
              {t(saveLabelKey, "Save")}
            </>
          )}
        </Button>
      )}
    </div>
  );

  if (position === "both") {
    return (
      <>
        <div className="mb-6">{buttons}</div>
        <div className="mt-6 pt-6 border-t border-border">{buttons}</div>
      </>
    );
  }

  if (position === "top") {
    return <div className="mb-6">{buttons}</div>;
  }

  return <div className="mt-6 pt-6 border-t border-border">{buttons}</div>;
};

/**
 * Form Wrapper with Navigation Buttons
 *
 * Wraps a form with automatic navigation buttons
 */
interface FormWithNavigationProps {
  children: React.ReactNode;
  onSubmit: (e: React.FormEvent) => void | Promise<void>;
  showSave?: boolean;
  showBack?: boolean;
  showHome?: boolean;
  saving?: boolean;
  saveDisabled?: boolean;
  saveLabelKey?: string;
  className?: string;
  /**
   * Position of navigation buttons: 'top', 'bottom', or 'both'
   */
  position?: "top" | "bottom" | "both";
}

export const FormWithNavigation: React.FC<FormWithNavigationProps> = ({
  children,
  onSubmit,
  showSave = true,
  showBack = true,
  showHome = true,
  saving = false,
  saveDisabled = false,
  saveLabelKey = "common.save",
  className = "",
  position = "both",
}) => {
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Block submit while disabled or already saving
    if (saving || saveDisabled) {
      return;
    }
    await onSubmit(e);
  };

  // Define navigation buttons once to avoid duplication
  const navButtons = (pos: "top" | "bottom") => (
    <NavigationButtons
      position={pos}
      showSave={showSave}
      showBack={showBack}
      showHome={showHome}
      saveType="submit"
      saving={saving}
      saveDisabled={saveDisabled}
      saveLabelKey={saveLabelKey}
    />
  );

  return (
    <form onSubmit={handleSubmit} className={`space-y-6 ${className}`}>
      {(position === "top" || position === "both") && navButtons("top")}
      {children}
      {(position === "bottom" || position === "both") && navButtons("bottom")}
    </form>
  );
};

export default NavigationButtons;

]]>
</file>

<file path="components/ui/pagination.tsx">
<![CDATA[
"use client";

import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { useTranslation } from "@/contexts/TranslationContext";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  totalItems?: number;
  itemsPerPage?: number;
}

export function Pagination({
  currentPage,
  totalPages,
  onPageChange,
  totalItems,
  itemsPerPage,
}: PaginationProps) {
  const { t, isRTL } = useTranslation();

  const pages = [];
  const maxVisiblePages = 5;

  // Calculate which pages to show
  let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
  const endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

  if (endPage - startPage < maxVisiblePages - 1) {
    startPage = Math.max(1, endPage - maxVisiblePages + 1);
  }

  for (let i = startPage; i <= endPage; i++) {
    pages.push(i);
  }

  // Use consistent default for itemsPerPage
  const perPage = itemsPerPage || 10;
  const showingFrom = totalItems ? (currentPage - 1) * perPage + 1 : null;
  const showingTo = totalItems
    ? Math.min(currentPage * perPage, totalItems)
    : null;

  // RTL-aware icons
  const PrevIcon = isRTL ? ChevronRight : ChevronLeft;
  const NextIcon = isRTL ? ChevronLeft : ChevronRight;

  return (
    <div className="flex items-center justify-between px-2 py-4">
      {totalItems && (
        <div className="text-sm text-muted-foreground">
          {t("pagination.showing", "Showing")}{" "}
          <span className="font-medium text-foreground">{showingFrom}</span>{" "}
          {t("pagination.to", "to")}{" "}
          <span className="font-medium text-foreground">{showingTo}</span>{" "}
          {t("pagination.of", "of")}{" "}
          <span className="font-medium text-foreground">{totalItems}</span>{" "}
          {t("pagination.results", "results")}
        </div>
      )}

      <div className="flex items-center gap-2 ms-auto">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <PrevIcon className="h-4 w-4" />
          {t("common.previous", "Previous")}
        </Button>

        {startPage > 1 && (
          <>
            <Button variant="outline" size="sm" onClick={() => onPageChange(1)}>
              1
            </Button>
            {startPage > 2 && (
              <span className="px-2 text-muted-foreground">...</span>
            )}
          </>
        )}

        {pages.map((page) => (
          <Button
            key={page}
            variant={currentPage === page ? "default" : "outline"}
            size="sm"
            onClick={() => onPageChange(page)}
          >
            {page}
          </Button>
        ))}

        {endPage < totalPages && (
          <>
            {endPage < totalPages - 1 && (
              <span className="px-2 text-muted-foreground">...</span>
            )}
            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(totalPages)}
            >
              {totalPages}
            </Button>
          </>
        )}

        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          {t("common.next", "Next")}
          <NextIcon className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

]]>
</file>

<file path="components/ui/progress.tsx">
<![CDATA[
import * as React from "react";
import { cn } from "@/lib/utils";

export interface ProgressProps
  extends React.HTMLAttributes<HTMLDivElement> {
  value?: number; // 0-100
}

const Progress = React.forwardRef<HTMLDivElement, ProgressProps>(
  ({ className, value = 0, ...props }, ref) => {
    const clamped = Math.min(100, Math.max(0, value));

    return (
      <div
        ref={ref}
        role="progressbar"
        aria-valuemin={0}
        aria-valuemax={100}
        aria-valuenow={clamped}
        className={cn(
          "relative h-2 w-full overflow-hidden rounded-full bg-muted",
          className,
        )}
        {...props}
      >
        <div
          className="h-full bg-primary transition-all duration-200"
          style={{ width: `${clamped}%` }}
        />
      </div>
    );
  },
);

Progress.displayName = "Progress";

export { Progress };

]]>
</file>

<file path="components/ui/radio-group.tsx">
<![CDATA[
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";
import { cn } from "@/lib/utils";

export const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => (
  <RadioGroupPrimitive.Root
    ref={ref}
    className={cn("grid gap-2", className)}
    {...props}
  />
));
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

export const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <RadioGroupPrimitive.Item
    ref={ref}
    className={cn(
      "aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
      <Circle className="h-2.5 w-2.5 fill-current" />
    </RadioGroupPrimitive.Indicator>
    {children}
  </RadioGroupPrimitive.Item>
));
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

]]>
</file>

<file path="components/ui/select.tsx">
<![CDATA[
"use client";

import React from "react";
import { ChevronDown } from "lucide-react";
import { logger } from "@/lib/logger";
import type { ReactNode } from "react";

// Helper: detect placeholder passed via legacy <SelectValue placeholder="..."> usage
const SELECT_VALUE_DISPLAY_NAME = "SelectValue";

type SelectValuePlaceholderProps = {
  placeholder?: string;
  children?: ReactNode;
};

type SelectValueElement = React.ReactElement<SelectValuePlaceholderProps> & {
  type: { displayName?: string };
};

const isSelectValueElement = (node: ReactNode): node is SelectValueElement => {
  if (!React.isValidElement(node)) {
    return false;
  }
  const elementType = node.type as { displayName?: string };
  return elementType?.displayName === SELECT_VALUE_DISPLAY_NAME;
};

function extractPlaceholderFromNode(node: ReactNode): string | undefined {
  if (!node) {
    return undefined;
  }
  if (Array.isArray(node)) {
    for (const child of node) {
      const found = extractPlaceholderFromNode(child);
      if (found) {
        return found;
      }
    }
    return undefined;
  }
  if (isSelectValueElement(node)) {
    const maybe = node.props.placeholder;
    if (typeof maybe === "string" && maybe.trim().length > 0) {
      return maybe;
    }
  }
  if (React.isValidElement(node)) {
    const childNodes = (node.props as { children?: React.ReactNode })?.children;
    if (childNodes) {
      return extractPlaceholderFromNode(childNodes);
    }
  }
  return undefined;
}

// --- Main Select Component ---

interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {
  children: React.ReactNode;
  /** Provides the native `onChange` event. */
  onChange?: (e: React.ChangeEvent<HTMLSelectElement>) => void;
  /** (Optional) A simpler callback for just the new value. */
  onValueChange?: (value: string) => void;
  /** (Optional) A placeholder to display. Renders a disabled first option. */
  placeholder?: string;
  /** (Optional) Class name for the wrapper div. */
  wrapperClassName?: string;
}

/**
 * A styled, native HTML <select> component.
 * It provides basic styling and handles placeholder logic.
 *
 * It does NOT support rich content or custom popovers. For that,
 * use a dedicated Combobox component built with Radix UI.
 */
export const Select = React.forwardRef<HTMLSelectElement, SelectProps>(
  (
    {
      className = "",
      wrapperClassName = "",
      children,
      placeholder,
      onValueChange,
      onChange,
      value,
      defaultValue,
      ...props
    },
    ref,
  ) => {
    const derivedPlaceholder =
      placeholder ?? extractPlaceholderFromNode(children);

    const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
      // Propagate the original event
      if (onChange) {
        onChange(e);
      }
      // Propagate the simple value change
      if (onValueChange) {
        onValueChange(e.target.value);
      }
    };

    // Determine the select props to avoid controlled/uncontrolled conflict
    const selectProps: React.SelectHTMLAttributes<HTMLSelectElement> = {
      ...props,
    };

    if (value !== undefined) {
      selectProps.value = value;
    } else {
      selectProps.defaultValue =
        defaultValue ?? (derivedPlaceholder ? "" : undefined);
    }

    return (
      <div className={`relative w-full ${wrapperClassName}`}>
        <select
          ref={ref}
          className={`
            flex h-10 w-full items-center justify-between rounded-2xl border border-border
            bg-card px-3 py-2 text-sm appearance-none
            ring-offset-white 
            focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 
            disabled:cursor-not-allowed disabled:opacity-50
            ${className}
          `}
          onChange={handleChange}
          {...selectProps}
        >
          {/* If a placeholder is provided, render it as the first,
            disabled, and hidden-from-list option.
            The 'value=""' is crucial for the placeholder to work
            with 'required' and form validation.
          */}
          {derivedPlaceholder && (
            <option value="" disabled hidden>
              {derivedPlaceholder}
            </option>
          )}

          {children}
        </select>
        <ChevronDown
          className="absolute end-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400 pointer-events-none"
          aria-hidden="true"
        />
      </div>
    );
  },
);
Select.displayName = "Select";

// --- Select Item Component ---

interface SelectItemProps
  extends React.OptionHTMLAttributes<HTMLOptionElement> {
  children: React.ReactNode;
}

/**
 * A native HTML <option> component.
 * It MUST only be used as a child of <Select> or <SelectGroup>.
 * It does NOT support rich HTML children (divs, paragraphs, etc.).
 */
export const SelectItem: React.FC<SelectItemProps> = ({
  className = "",
  children,
  ...props
}) => {
  // We no longer need complex text extraction.
  // The native <option> element will render React children (like strings, numbers, or simple spans).
  // If a developer passes invalid HTML (like a <div>), React will correctly warn them.
  return (
    <option
      className={`
        cursor-pointer select-none py-1.5 text-sm outline-none
        bg-card text-foreground
        disabled:text-gray-400
        ${className}
      `}
      {...props}
    >
      {children}
    </option>
  );
};
SelectItem.displayName = "SelectItem";

// --- Select Group Component ---

interface SelectGroupProps
  extends React.OptgroupHTMLAttributes<HTMLOptGroupElement> {
  children: React.ReactNode;
  label: string;
}

/**
 * A native HTML <optgroup> component for grouping <SelectItem>s.
 */
export const SelectGroup: React.FC<SelectGroupProps> = ({
  className = "",
  children,
  label,
  ...props
}) => {
  return (
    <optgroup
      className={`font-semibold py-1.5 ${className}`}
      label={label}
      {...props}
    >
      {children}
    </optgroup>
  );
};
SelectGroup.displayName = "SelectGroup";

// --- BACKWARD COMPATIBILITY EXPORTS ---
// These components are provided for backward compatibility with the old API.
// They are thin wrappers that work with the new native select implementation.
// New code should use the `placeholder` prop on <Select> instead.

interface SelectTriggerProps extends React.HTMLAttributes<HTMLDivElement> {
  children?: React.ReactNode;
}

/**
 * @deprecated This component is provided for backward compatibility only.
 * With the new native select implementation, you don't need SelectTrigger.
 * Just use <Select> with the placeholder prop.
 */
export const SelectTrigger: React.FC<SelectTriggerProps> = ({ children }) => {
  // This component does nothing - it's just a passthrough for compatibility
  return <>{children}</>;
};
SelectTrigger.displayName = "SelectTrigger";

interface SelectContentProps extends React.HTMLAttributes<HTMLDivElement> {
  children?: React.ReactNode;
}

/**
 * @deprecated This component is provided for backward compatibility only.
 * With the new native select implementation, you don't need SelectContent.
 * Just put your SelectItem components directly inside <Select>.
 */
export const SelectContent: React.FC<SelectContentProps> = ({ children }) => {
  // This component does nothing - it's just a passthrough for compatibility
  return <>{children}</>;
};
SelectContent.displayName = "SelectContent";

interface SelectValueProps
  extends React.HTMLAttributes<HTMLSpanElement>,
    SelectValuePlaceholderProps {}

let hasLoggedSelectValueWarning = false;

/**
 * @deprecated This component is provided for backward compatibility only.
 * With the new native select implementation, you don't need SelectValue.
 * Use the `placeholder` prop on <Select> instead.
 */
export const SelectValue: React.FC<SelectValueProps> = () => {
  // Warn developers during development
  if (process.env.NODE_ENV !== "production" && !hasLoggedSelectValueWarning) {
    hasLoggedSelectValueWarning = true;
    import("../../lib/logger")
      .then(({ logWarn }) => {
        logWarn(
          "SelectValue is deprecated and non-functional with the new native Select. " +
            'Use the placeholder prop on <Select> instead: <Select placeholder="...">. ' +
            "See migration guide for details.",
          {
            component: "SelectValue",
            action: "deprecationWarning",
            context: "Use Select placeholder prop instead",
          },
        );
      })
      .catch((logErr) =>
        logger.error("Failed to load logger:", { error: logErr }),
      );
  }
  // This component does nothing - the native select handles its own value display
  return null;
};
SelectValue.displayName = "SelectValue";

]]>
</file>

<file path="components/ui/separator.tsx">
<![CDATA[
import React, { forwardRef } from "react";

interface SeparatorProps extends React.HTMLAttributes<HTMLDivElement> {
  orientation?: "horizontal" | "vertical";
}

/**
 * A purely decorative visual separator.
 * It is hidden from screen readers.
 * If you need a semantic separator (e.g., for a menu), you should
 * use role="separator" and add aria-orientation.
 */
export const Separator = forwardRef<HTMLDivElement, SeparatorProps>(
  ({ className = "", orientation = "horizontal", ...props }, ref) => {
    const orientationClasses = {
      horizontal: "h-[1px] w-full",
      vertical: "h-full w-[1px]",
    };

    return (
      <div
        ref={ref}
        role="presentation"
        aria-hidden="true"
        className={`
          shrink-0 
          bg-border
          ${orientationClasses[orientation]} 
          ${className}
        `}
        {...props}
      />
    );
  },
);

Separator.displayName = "Separator";

]]>
</file>

<file path="components/ui/skeleton.tsx">
<![CDATA[
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-2xl bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };

]]>
</file>

<file path="components/ui/switch.tsx">
<![CDATA[
import React from "react";

interface SwitchProps
  extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, "onChange"> {
  checked?: boolean;
  onCheckedChange?: (checked: boolean) => void;
}

export const Switch: React.FC<SwitchProps> = ({
  className = "",
  checked = false,
  onCheckedChange,
  ...props
}) => {
  const handleClick = () => {
    if (onCheckedChange) {
      onCheckedChange(!checked);
    }
  };

  return (
    <button
      type="button"
      role="switch"
      aria-checked={checked}
      className={`peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-gray-400 focus-visible:ring-offset-2 focus-visible:ring-offset-white disabled:cursor-not-allowed disabled:opacity-50 ${
        checked ? "bg-primary" : "bg-muted"
      } ${className}`}
      onClick={handleClick}
      {...props}
    >
      <span
        className={`pointer-events-none block h-5 w-5 rounded-full bg-card shadow-lg ring-0 transition-transform ${
          checked ? "translate-x-5" : "translate-x-0"
        }`}
      />
    </button>
  );
};

]]>
</file>

<file path="components/ui/table.tsx">
<![CDATA[
import * as React from "react";
import { cn } from "@/lib/utils";

export const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="w-full overflow-auto rounded-lg border border-gray-200">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm text-gray-900", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

export const TableHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLTableSectionElement>) => (
  <thead
    className={cn(
      "bg-gray-50 text-xs uppercase tracking-wide text-gray-600",
      className,
    )}
    {...props}
  />
);
TableHeader.displayName = "TableHeader";

export const TableBody = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLTableSectionElement>) => (
  <tbody className={cn("divide-y divide-gray-100", className)} {...props} />
);
TableBody.displayName = "TableBody";

export const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn("transition-colors hover:bg-gray-50", className)}
    {...props}
  />
));
TableRow.displayName = "TableRow";

export const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "px-4 py-3 text-start text-xs font-semibold text-gray-600",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

export const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("px-4 py-3 align-top text-sm text-gray-800", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

export const TableCaption = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLTableCaptionElement>) => (
  <caption className={cn("mt-4 text-sm text-gray-500", className)} {...props} />
);
TableCaption.displayName = "TableCaption";

]]>
</file>

<file path="components/ui/tabs.tsx">
<![CDATA[
"use client";

import React, { createContext, useContext, useState, useId } from "react";

// --- Types ---

interface TabsContextProps {
  value: string;
  onValueChange: (value: string) => void;
  /** A unique ID for this tabs instance to link triggers and content */
  baseId: string;
}

interface TabsProps extends React.HTMLAttributes<HTMLDivElement> {
  /** The value of the tab that should be active by default. */
  defaultValue?: string;
  /** The controlled value of the active tab. */
  value?: string;
  /** Event handler for when the active tab changes. */
  onValueChange?: (value: string) => void;
}

type TabsListProps = React.HTMLAttributes<HTMLDivElement>;

interface TabsTriggerProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  /** A unique value for this tab trigger. */
  value: string;
}

interface TabsContentProps extends React.HTMLAttributes<HTMLDivElement> {
  /** A unique value for this tab content, matching its trigger. */
  value: string;
}

// --- Context ---

const TabsContext = createContext<TabsContextProps | null>(null);

/** Custom hook to ensure context is used within a Tabs component */
const useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("Tabs components must be used within a <Tabs> provider.");
  }
  return context;
};

// --- Components ---

export const Tabs: React.FC<TabsProps> = ({
  className = "",
  defaultValue = "",
  value: controlledValue,
  onValueChange: controlledOnChange,
  children,
  ...props
}) => {
  const [internalValue, setInternalValue] = useState(defaultValue);

  // Generate a unique base ID for ARIA
  const baseId = useId();

  // Determine if the component is controlled or uncontrolled
  const value = controlledValue !== undefined ? controlledValue : internalValue;
  const onValueChange = controlledOnChange || setInternalValue;

  return (
    <TabsContext.Provider value={{ value, onValueChange, baseId }}>
      <div className={`w-full ${className}`} {...props}>
        {children}
      </div>
    </TabsContext.Provider>
  );
};
Tabs.displayName = "Tabs";

export const TabsList: React.FC<TabsListProps> = ({
  className = "",
  children,
  ...props
}) => {
  return (
    <div
      role="tablist"
      aria-orientation="horizontal"
      className={`
        inline-flex h-10 items-center justify-center rounded-2xl 
        bg-muted p-1 text-muted-foreground ${className}
      `}
      {...props}
    >
      {children}
    </div>
  );
};
TabsList.displayName = "TabsList";

export const TabsTrigger: React.FC<TabsTriggerProps> = ({
  className = "",
  value,
  children,
  ...props
}) => {
  const { value: selectedValue, onValueChange, baseId } = useTabsContext();
  const isActive = value === selectedValue;
  const triggerId = `${baseId}-trigger-${value}`;
  const contentId = `${baseId}-content-${value}`;

  const handleKeyDown = (e: React.KeyboardEvent<HTMLButtonElement>) => {
    const target = e.currentTarget;
    const tablist = target.closest('[role="tablist"]');
    if (!tablist) return;

    // Filter out disabled tabs from navigation
    const triggers = Array.from(
      tablist.querySelectorAll<HTMLButtonElement>(
        '[role="tab"]:not(:disabled)',
      ),
    );
    if (triggers.length === 0) return;

    const currentIndex = triggers.findIndex((el) => el === target);
    if (currentIndex === -1) return;

    let nextIndex = currentIndex;

    switch (e.key) {
      case "ArrowRight":
        e.preventDefault();
        nextIndex = (currentIndex + 1) % triggers.length;
        break;
      case "ArrowLeft":
        e.preventDefault();
        nextIndex = (currentIndex - 1 + triggers.length) % triggers.length;
        break;
      case "Home":
        e.preventDefault();
        nextIndex = 0;
        break;
      case "End":
        e.preventDefault();
        nextIndex = triggers.length - 1;
        break;
      default:
        return;
    }

    // Set focus and activate the new tab
    const nextTrigger = triggers[nextIndex];
    if (!nextTrigger) return;

    nextTrigger.focus();
    const nextValue = nextTrigger.dataset.value;
    if (nextValue !== undefined) {
      onValueChange(nextValue);
    }
  };

  return (
    <button
      id={triggerId}
      role="tab"
      aria-selected={isActive}
      aria-controls={contentId}
      tabIndex={isActive ? 0 : -1} // Only the active tab is in the tab sequence
      data-value={value} // Store value for keyboard navigation logic
      className={`
        inline-flex items-center justify-center whitespace-nowrap rounded-sm 
        px-3 py-1.5 text-sm font-medium ring-offset-white transition-all 
        focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 
        disabled:pointer-events-none disabled:opacity-50
        ${
          isActive
            ? "bg-card text-foreground shadow-sm"
            : "text-muted-foreground hover:text-foreground"
        } 
        ${className}
      `}
      onClick={() => onValueChange(value)}
      onKeyDown={handleKeyDown}
      {...props}
    >
      {children}
    </button>
  );
};
TabsTrigger.displayName = "TabsTrigger";

export const TabsContent: React.FC<TabsContentProps> = ({
  className = "",
  value,
  children,
  ...props
}) => {
  const { value: selectedValue, baseId } = useTabsContext();
  const isActive = value === selectedValue;
  const triggerId = `${baseId}-trigger-${value}`;
  const contentId = `${baseId}-content-${value}`;

  return (
    <div
      id={contentId}
      role="tabpanel"
      aria-labelledby={triggerId}
      // Use the 'hidden' attribute to hide/show.
      // This keeps the component mounted and preserves its state.
      hidden={!isActive}
      className={`mt-2 ring-offset-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 ${className}`}
      {...props}
    >
      {children}
    </div>
  );
};
TabsContent.displayName = "TabsContent";

]]>
</file>

<file path="components/ui/textarea.tsx">
<![CDATA[
"use client";

import React, { useRef, useEffect, useLayoutEffect, forwardRef } from "react";
import { logger } from "@/lib/logger";

// SSR-safe layout effect - prevents hydration warning
const useIsomorphicLayoutEffect =
  typeof window !== "undefined" ? useLayoutEffect : useEffect;

interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  /** Enables vertical auto-resizing as user types. */
  autoResize?: boolean;
}

export const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className = "", autoResize = false, onChange, ...props }, ref) => {
    // Internal ref to manage the element for resizing
    const internalRef = useRef<HTMLTextAreaElement>(null);

    // --- Ref Composition ---
    // This function merges the forwarded ref (from react-hook-form)
    // with our internal ref (for auto-sizing).
    const composedRef = (el: HTMLTextAreaElement | null) => {
      // Assign to our internal ref
      if (el) {
        (
          internalRef as React.MutableRefObject<HTMLTextAreaElement | null>
        ).current = el;
      }

      // Assign to the forwarded ref
      if (typeof ref === "function") {
        ref(el);
      } else if (ref) {
        (ref as React.MutableRefObject<HTMLTextAreaElement | null>).current =
          el;
      }
    };

    // --- Auto-Resize Logic ---
    const resize = () => {
      if (!autoResize || !internalRef.current) return;

      try {
        const el = internalRef.current;
        if (!el || !(el instanceof HTMLTextAreaElement)) {
          import("../../lib/logger")
            .then(({ logWarn }) => {
              logWarn("[Textarea] resize called with invalid ref", {
                component: "Textarea",
                action: "resize",
                autoResize,
              });
            })
            .catch((logErr) =>
              logger.error("Failed to load logger:", { error: logErr }),
            );
          return;
        }
        el.style.height = "auto"; // Reset height to calculate new scrollHeight
        el.style.height = `${el.scrollHeight}px`; // Set to new scrollHeight
      } catch (error) {
        import("../../lib/logger")
          .then(({ logError }) => {
            logError("[Textarea] Auto-resize failed", error as Error, {
              component: "Textarea",
              action: "resize",
              autoResize,
            });
          })
          .catch((logErr) =>
            logger.error("Failed to load logger:", { error: logErr }),
          );
        // Graceful degradation: disable auto-resize on error
      }
    };

    // Resize on initial render and when `value` prop changes
    // Using isomorphic layout effect for SSR safety
    useIsomorphicLayoutEffect(() => {
      resize();
    }, [props.value, autoResize]);

    const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      // Resize on user input
      if (autoResize) {
        resize();
      }
      // Pass the event up to the parent
      if (onChange) {
        onChange(e);
      }
    };

    return (
      <textarea
        ref={composedRef}
        className={`
          min-h-[80px] w-full rounded-2xl border border-border bg-card 
          px-3 py-2 text-sm ring-offset-white 
          placeholder:text-muted-foreground 
          focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 
          disabled:cursor-not-allowed disabled:opacity-50 
          ${autoResize ? "overflow-y-hidden resize-none" : ""} 
          ${className}
        `}
        onChange={handleChange}
        {...props}
      />
    );
  },
);

Textarea.displayName = "Textarea";

]]>
</file>

<file path="components/ui/tooltip.tsx">
<![CDATA[
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "@/lib/utils";

export const TooltipProvider = TooltipPrimitive.Provider;
export const Tooltip = TooltipPrimitive.Root;
export const TooltipTrigger = TooltipPrimitive.Trigger;

export const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 6, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md px-3 py-1.5 text-sm shadow-lg",
        // Light mode
        "border border-border bg-popover text-popover-foreground",
        // Animation
        "animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
        // Side-aware animations
        "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

/**
 * Simple tooltip wrapper for convenience.
 * Use this when you just need a basic tooltip on a single element.
 * Note: Requires TooltipProvider to be present in the component tree (see app/layout.tsx)
 *
 * @example
 * ```tsx
 * <SimpleTooltip content="Click to save">
 *   <button>Save</button>
 * </SimpleTooltip>
 * ```
 */
interface SimpleTooltipProps {
  content: React.ReactNode;
  children: React.ReactNode;
  side?: "top" | "right" | "bottom" | "left";
  delayDuration?: number;
  asChild?: boolean;
}

export const SimpleTooltip: React.FC<SimpleTooltipProps> = ({
  content,
  children,
  side = "top",
  delayDuration,
  asChild = true,
}) => {
  // Use global TooltipProvider from layout.tsx
  // Only wrap with local provider if delayDuration is explicitly set (overriding global)
  const tooltipContent = (
    <Tooltip>
      <TooltipTrigger asChild={asChild}>{children}</TooltipTrigger>
      <TooltipContent side={side}>{content}</TooltipContent>
    </Tooltip>
  );

  // If custom delay is specified, wrap with local provider to override
  if (delayDuration !== undefined) {
    return (
      <TooltipProvider delayDuration={delayDuration}>
        {tooltipContent}
      </TooltipProvider>
    );
  }

  return tooltipContent;
};


]]>
</file>

<file path="scripts/ui/ui_freeze_check.ts">
<![CDATA[
console.log("OK");

]]>
</file>

<file path="tests/components/admin/RBACMatrixTable.test.tsx">
<![CDATA[
import React from "react";
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { describe, it, expect, vi } from "vitest";
import RBACMatrixTable, { type RolePermission, type Module } from "@/components/admin/RBACMatrixTable";

const modules: Module[] = [
  { id: "work_orders", label: "Work Orders", description: "Maintenance and service requests" },
];

const baseRoles: RolePermission[] = [
  {
    role: "MANAGER",
    roleLabel: "Manager",
    permissions: {
      work_orders: { view: false, create: false, edit: false, delete: false },
    },
  },
];

const renderTable = (overrides: Partial<React.ComponentProps<typeof RBACMatrixTable>> = {}) => {
  const onChange = vi.fn();
  const onSave = vi.fn().mockResolvedValue(undefined);
  const props = {
    roles: baseRoles,
    modules,
    onChange,
    onSave,
    ...overrides,
  };
  const view = render(<RBACMatrixTable {...props} />);
  return { ...view, onChange, onSave };
};

describe("RBACMatrixTable", () => {
  it("calls onChange with updated roles and enables view when enabling create", async () => {
    const { onChange } = renderTable();
    const user = userEvent.setup();

    const createSwitch = screen.getByLabelText(/Manager create Work Orders/i);
    await user.click(createSwitch);

    expect(onChange).toHaveBeenCalledTimes(1);
    const updatedRoles = onChange.mock.calls[0][0] as RolePermission[];
    const perms = updatedRoles[0].permissions.work_orders;
    expect(perms.create).toBe(true);
    expect(perms.view).toBe(true); // auto-enables view
    expect(
      screen.getByText(/You have unsaved changes/i),
    ).toBeInTheDocument();
  });

  it("disables dependent permissions when view is turned off", async () => {
    const rolesWithView: RolePermission[] = [
      {
        role: "MANAGER",
        roleLabel: "Manager",
        permissions: {
          work_orders: { view: true, create: true, edit: true, delete: true },
        },
      },
    ];
    const { onChange } = renderTable({ roles: rolesWithView });
    const user = userEvent.setup();

    const viewSwitch = screen.getByLabelText(/Manager view Work Orders/i);
    await user.click(viewSwitch);

    const updatedRoles = onChange.mock.calls[0][0] as RolePermission[];
    const perms = updatedRoles[0].permissions.work_orders;
    expect(perms.view).toBe(false);
    expect(perms.create).toBe(false);
    expect(perms.edit).toBe(false);
    expect(perms.delete).toBe(false);
  });

  it("resets to initial roles and clears dirty state", async () => {
    const { onChange } = renderTable();
    const user = userEvent.setup();

    const createSwitch = screen.getByLabelText(/Manager create Work Orders/i);
    await user.click(createSwitch);
    expect(onChange).toHaveBeenCalledTimes(1);
    expect(screen.getByText(/You have unsaved changes/i)).toBeInTheDocument();

    const resetButton = screen.getByRole("button", { name: /Reset/i });
    await user.click(resetButton);

    expect(onChange).toHaveBeenCalledTimes(2);
    const resetRoles = onChange.mock.calls[1][0] as RolePermission[];
    expect(resetRoles).toEqual(baseRoles);
    expect(
      screen.queryByText(/You have unsaved changes/i),
    ).not.toBeInTheDocument();
  });

  it("saves updated roles, clears dirty state, and disables save after completion", async () => {
    const { onSave } = renderTable();
    const user = userEvent.setup();

    const createSwitch = screen.getByLabelText(/Manager create Work Orders/i);
    await user.click(createSwitch);

    const saveButton = screen.getByRole("button", { name: /Save Changes/i });
    await user.click(saveButton);

    await waitFor(() => expect(onSave).toHaveBeenCalledTimes(1));
    await waitFor(() =>
      expect(
        screen.queryByText(/You have unsaved changes/i),
      ).not.toBeInTheDocument(),
    );
    expect(saveButton).toBeDisabled();
  });
});

]]>
</file>

<file path="tests/components/admin/SubRoleSelector.test.tsx">
<![CDATA[
/**
 * SubRoleSelector Integration Tests
 * 
 * Tests:
 * - Component rendering based on role
 * - Sub-role selection and onChange callback
 * - Module access preview display
 * - Accessibility (ARIA labels, keyboard navigation)
 * - Error state display
 * - Disabled state
 */

import React from 'react';
import { render, screen, fireEvent, within } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import SubRoleSelector from '@/components/admin/SubRoleSelector';
import { Role, SubRole, Plan } from '@/lib/rbac/client-roles';

// Mock translation context
vi.mock('@/contexts/TranslationContext', () => ({
  useTranslation: () => ({
    t: (key: string, fallback?: string) => fallback || key,
  }),
}));

// Mock CurrentOrgContext for plan access
vi.mock('@/contexts/CurrentOrgContext', () => ({
  useCurrentOrg: () => ({
    org: { id: 'test-org', name: 'Test Org', plan: Plan.STANDARD },
    isLoading: false,
    error: null,
    refetch: vi.fn(),
  }),
}));

describe('SubRoleSelector', () => {
  describe('Rendering based on role', () => {
    it('renders for TEAM_MEMBER role', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
        />
      );
      
      expect(screen.getByLabelText(/Sub-Role/i)).toBeInTheDocument();
    });
    
    it('renders for FINANCE legacy string (normalized to TEAM_MEMBER)', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role="FINANCE"
          value={null}
          onChange={mockOnChange}
        />
      );
      
      expect(screen.getByLabelText(/Sub-Role/i)).toBeInTheDocument();
    });
    
    it('does not render for non-eligible roles', () => {
      const mockOnChange = vi.fn();
      const { container } = render(
        <SubRoleSelector
          role={Role.TENANT}
          value={null}
          onChange={mockOnChange}
        />
      );
      
      expect(container.firstChild).toBeNull();
    });
    
    it('does not render for ADMIN role', () => {
      const mockOnChange = vi.fn();
      const { container } = render(
        <SubRoleSelector
          role={Role.ADMIN}
          value={null}
          onChange={mockOnChange}
        />
      );
      
      expect(container.firstChild).toBeNull();
    });
  });
  
  describe('Sub-role selection', () => {
    it('displays all sub-role options', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      const options = within(select).getAllByRole('option');
      
      // Should have 5 options: "None" + 4 sub-roles
      expect(options).toHaveLength(5);
      expect(options[0]).toHaveTextContent(/No specialization/i);
      expect(options[1]).toHaveTextContent(/Finance Officer/i);
      expect(options[2]).toHaveTextContent(/HR Officer/i);
      expect(options[3]).toHaveTextContent(/Support Agent/i);
      expect(options[4]).toHaveTextContent(/Operations Manager/i);
    });
    
    it('selects the provided value', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={SubRole.FINANCE_OFFICER}
          onChange={mockOnChange}
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i) as HTMLSelectElement;
      expect(select.value).toBe(SubRole.FINANCE_OFFICER);
    });
    
    it('calls onChange when selection changes', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      fireEvent.change(select, { target: { value: SubRole.HR_OFFICER } });
      
      expect(mockOnChange).toHaveBeenCalledWith(SubRole.HR_OFFICER);
      expect(mockOnChange).toHaveBeenCalledTimes(1);
    });
    
    it('calls onChange with null when "None" is selected', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={SubRole.FINANCE_OFFICER}
          onChange={mockOnChange}
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      fireEvent.change(select, { target: { value: '' } });
      
      expect(mockOnChange).toHaveBeenCalledWith(null);
    });
  });
  
  describe('Module access preview', () => {
    it('shows module access description for selected sub-role', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={SubRole.FINANCE_OFFICER}
          onChange={mockOnChange}
        />
      );
      
      // Should show description for Finance Officer
      expect(screen.getByText(/Manages budgets, invoices/i)).toBeInTheDocument();
    });
    
    it('shows description for selected sub-role', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={SubRole.HR_OFFICER}
          onChange={mockOnChange}
        />
      );
      
      expect(screen.getByText(/Manages employee records/i)).toBeInTheDocument();
    });
  });
  
  describe('Accessibility', () => {
    it('has proper ARIA labels', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
          required
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      expect(select).toHaveAttribute('aria-describedby');
      expect(select).toHaveAttribute('aria-invalid', 'false');
    });
    
    it('shows required indicator when required', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
          required
        />
      );
      
      expect(screen.getByLabelText('required')).toBeInTheDocument();
      expect(screen.getByLabelText(/Sub-Role/i)).toBeRequired();
    });
    
    it('shows error state when error provided', () => {
      const mockOnChange = vi.fn();
      const errorMessage = 'Sub-role is required';
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
          error={errorMessage}
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      expect(select).toHaveAttribute('aria-invalid', 'true');
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
    
    it('is keyboard navigable', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      select.focus();
      expect(select).toHaveFocus();
    });
  });
  
  describe('Disabled state', () => {
    it('disables select when disabled prop is true', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
          disabled
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      expect(select).toBeDisabled();
    });
    
    it('applies disabled styling', () => {
      const mockOnChange = vi.fn();
      
      render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
          disabled
        />
      );
      
      const select = screen.getByLabelText(/Sub-Role/i);
      expect(select).toHaveClass('disabled:cursor-not-allowed');
    });
  });
  
  describe('Custom className', () => {
    it('applies custom className', () => {
      const mockOnChange = vi.fn();
      const customClass = 'my-custom-class';
      
      const { container } = render(
        <SubRoleSelector
          role={Role.TEAM_MEMBER}
          value={null}
          onChange={mockOnChange}
          className={customClass}
        />
      );
      
      expect(container.firstChild).toHaveClass(customClass);
    });
  });
});

]]>
</file>

<file path="tests/unit/app/fm/finance/budgets/new/page.test.tsx">
<![CDATA[
import React from "react";
import { describe, beforeEach, test, expect, vi } from "vitest";
import { render, screen, act } from "@testing-library/react";

import NewBudgetPage from "@/app/fm/finance/budgets/new/page";

const mockUseOrgGuard = vi.fn();

vi.mock("next/navigation", () => ({
  useRouter: () => ({ push: vi.fn(), back: vi.fn() }),
}));

vi.mock("@/contexts/FormStateContext", () => ({
  useFormState: () => ({
    registerForm: vi.fn(),
    unregisterForm: vi.fn(),
  }),
}));

vi.mock("@/contexts/TranslationContext", () => ({
  useTranslation: () => ({
    t: (_key: string, fallback?: string) => fallback ?? _key,
  }),
}));

vi.mock("@/components/fm/useFmOrgGuard", () => ({
  useFmOrgGuard: () => mockUseOrgGuard(),
}));

vi.mock("@/components/fm/ModuleViewTabs", () => ({
  __esModule: true,
  default: ({ moduleId }: { moduleId: string }) => (
    <div data-testid="module-tabs">{moduleId}</div>
  ),
}));

vi.mock("sonner", () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

vi.mock("@/lib/logger", () => ({
  logger: {
    error: vi.fn(),
  },
}));

describe("NewBudgetPage org guard", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockUseOrgGuard.mockReturnValue({
      hasOrgContext: true,
      orgId: "org-test",
      guard: null,
      supportBanner: <div data-testid="support-banner">banner</div>,
    });
  });

  test("renders ModuleViewTabs + guard when organization missing", async () => {
    mockUseOrgGuard.mockReturnValue({
      hasOrgContext: false,
      orgId: null,
      guard: <div data-testid="org-guard" />,
      supportBanner: null,
    });

    await act(async () => {
      render(<NewBudgetPage />);
    });

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("finance");
    expect(screen.getByTestId("org-guard")).toBeInTheDocument();
  });

  test("renders finance form when organization is available", async () => {
    await act(async () => {
      render(<NewBudgetPage />);
    });

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("finance");
    expect(screen.getByTestId("support-banner")).toBeInTheDocument();
    expect(screen.getByText(/Create Budget/i)).toBeInTheDocument();
  });
});

]]>
</file>

<file path="tests/unit/app/fm/finance/expenses/new/page.test.tsx">
<![CDATA[
import React from "react";
import { describe, beforeEach, test, expect, vi } from "vitest";
import { render, screen, act } from "@testing-library/react";

import NewExpensePage from "@/app/fm/finance/expenses/new/page";

const mockUseOrgGuard = vi.fn();

vi.mock("next/navigation", () => ({
  useRouter: () => ({ push: vi.fn(), back: vi.fn() }),
}));

vi.mock("@/contexts/FormStateContext", () => ({
  useFormState: () => ({
    registerForm: vi.fn(),
    unregisterForm: vi.fn(),
  }),
}));

vi.mock("@/contexts/TranslationContext", () => ({
  useTranslation: () => ({
    t: (_key: string, fallback?: string) => fallback ?? _key,
  }),
}));

vi.mock("@/components/fm/useFmOrgGuard", () => ({
  useFmOrgGuard: () => mockUseOrgGuard(),
}));

vi.mock("@/components/fm/ModuleViewTabs", () => ({
  __esModule: true,
  default: ({ moduleId }: { moduleId: string }) => (
    <div data-testid="module-tabs">{moduleId}</div>
  ),
}));

vi.mock("sonner", () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

vi.mock("@/lib/logger", () => ({
  logger: {
    error: vi.fn(),
  },
}));

describe("NewExpensePage org guard", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockUseOrgGuard.mockReturnValue({
      hasOrgContext: true,
      orgId: "org-test",
      guard: null,
      supportBanner: <div data-testid="support-banner">banner</div>,
    });
  });

  test("returns guard when no org context is present", async () => {
    mockUseOrgGuard.mockReturnValue({
      hasOrgContext: false,
      orgId: null,
      guard: <div data-testid="org-guard" />,
      supportBanner: null,
    });

    await act(async () => {
      render(<NewExpensePage />);
    });

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("finance");
    expect(screen.getByTestId("org-guard")).toBeInTheDocument();
  });

  test("renders expense form layout when org context exists", async () => {
    await act(async () => {
      render(<NewExpensePage />);
    });

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("finance");
    expect(screen.getByTestId("support-banner")).toBeInTheDocument();
    expect(screen.getByText(/New Expense/i)).toBeInTheDocument();
  });
});

]]>
</file>

<file path="tests/unit/app/fm/finance/payments/new/page.test.tsx">
<![CDATA[
import React from "react";
import { describe, beforeEach, test, expect, vi } from "vitest";
import { render, screen, act } from "@testing-library/react";

import NewPaymentPage from "@/app/fm/finance/payments/new/page";

const mockUseFmOrgGuard = vi.fn();

vi.mock("next/navigation", () => ({
  useRouter: () => ({ push: vi.fn(), back: vi.fn() }),
}));

vi.mock("@/contexts/FormStateContext", () => ({
  useFormState: () => ({
    registerForm: vi.fn(),
    unregisterForm: vi.fn(),
  }),
}));

vi.mock("@/contexts/TranslationContext", () => ({
  useTranslation: () => ({
    t: (_key: string, fallback?: string) => fallback ?? _key,
  }),
}));

vi.mock("@/components/fm/useFmOrgGuard", () => ({
  useFmOrgGuard: () => mockUseFmOrgGuard(),
}));

vi.mock("@/components/fm/ModuleViewTabs", () => ({
  __esModule: true,
  default: ({ moduleId }: { moduleId: string }) => (
    <div data-testid="module-tabs">{moduleId}</div>
  ),
}));

vi.mock("@/components/ClientDate", () => ({
  __esModule: true,
  default: ({ date }: { date: string }) => (
    <span data-testid="client-date">{date}</span>
  ),
}));

vi.mock("sonner", () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

vi.mock("@/lib/logger", () => ({
  logger: {
    error: vi.fn(),
  },
}));

describe("NewPaymentPage org guard", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockUseFmOrgGuard.mockReturnValue({
      hasOrgContext: true,
      orgId: "org-test",
      guard: null,
      supportBanner: <div data-testid="support-banner">banner</div>,
    });
  });

  test("renders guard content when organization is missing", async () => {
    mockUseFmOrgGuard.mockReturnValue({
      hasOrgContext: false,
      orgId: null,
      guard: <div data-testid="org-guard" />,
      supportBanner: null,
    });

    await act(async () => {
      render(<NewPaymentPage />);
    });

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("finance");
    expect(screen.getByTestId("org-guard")).toBeInTheDocument();
  });

  test("renders payment form when organization context is available", async () => {
    await act(async () => {
      render(<NewPaymentPage />);
    });

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("finance");
    expect(screen.getByTestId("support-banner")).toBeInTheDocument();
    expect(screen.getByText(/New Payment/i)).toBeInTheDocument();
  });
});

]]>
</file>

<file path="tests/unit/app/fm/invoices/new/page.test.tsx">
<![CDATA[
import React from 'react';
import { describe, beforeEach, beforeAll, test, expect, vi, afterEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';

import InvoiceCreationForOpsPage from '@/app/fm/invoices/new/page';

const mockUseFmOrgGuard = vi.fn();
const toastSuccess = vi.fn();
const toastError = vi.fn();

type InvoiceFormValues = Record<string, string | number | boolean | null | object | undefined>;
type SubmitHandler = (values: InvoiceFormValues, event?: Event) => Promise<void> | void;

let capturedSubmit: SubmitHandler | undefined;

vi.mock('@/components/fm/useFmOrgGuard', () => ({
  useFmOrgGuard: () => mockUseFmOrgGuard(),
}));

vi.mock('@/components/fm/ModuleViewTabs', () => ({
  __esModule: true,
  default: ({ moduleId }: { moduleId: string }) => <div data-testid="module-tabs">{moduleId}</div>,
}));

vi.mock('@/i18n/useAutoTranslator', () => ({
  useAutoTranslator:
    () =>
    (fallback: string) =>
      fallback,
}));

vi.mock('sonner', () => ({
  toast: {
    success: (...args: unknown[]) => toastSuccess(...args),
    error: (...args: unknown[]) => toastError(...args),
  },
}));

vi.mock('react-hook-form', () => ({
  useForm: () => ({
    register: vi.fn(),
    handleSubmit: (cb: SubmitHandler) => {
      capturedSubmit = cb;
      return vi.fn();
    },
    reset: vi.fn(),
    formState: {
      errors: {},
      isSubmitting: false,
    },
  }),
}));

beforeEach(() => {
  vi.clearAllMocks();
  capturedSubmit = undefined;
  mockUseFmOrgGuard.mockReturnValue({
    hasOrgContext: true,
    guard: null,
    supportBanner: <div data-testid="support-banner">support</div>,
    orgId: 'org-test',
  });
  global.fetch = vi.fn().mockResolvedValue({
    ok: true,
    json: async () => ({}),
  }) as typeof fetch;
});

afterEach(() => {
  vi.resetModules();
});

describe('InvoiceCreationForOpsPage org guard behavior', () => {
  test('renders guard when organization context missing', () => {
    mockUseFmOrgGuard.mockReturnValue({
      hasOrgContext: false,
      guard: <div data-testid="org-guard" />,
      supportBanner: null,
      orgId: null,
    });

    render(<InvoiceCreationForOpsPage />);

    expect(screen.getByTestId('org-guard')).toBeInTheDocument();
  });

  test('renders finance layout and submits using tenant header', async () => {
    render(<InvoiceCreationForOpsPage />);

    expect(screen.getByTestId('module-tabs')).toHaveTextContent('finance');
    expect(screen.getByTestId('support-banner')).toBeInTheDocument();
    expect(capturedSubmit).toBeDefined();

    await act(async () => {
      await capturedSubmit?.(
        {
          customer: 'ACME',
          project: 'Renewal',
          amount: '1000',
          billingContact: 'ops@acme.com',
          narrative: 'Monthly retainer',
        },
        {
          nativeEvent: {
            submitter: { dataset: { action: 'send' } },
          },
        },
      );
    });

    expect(global.fetch).toHaveBeenCalledWith('/api/invoices/send', expect.objectContaining({
      method: 'POST',
      headers: expect.objectContaining({
        'Content-Type': 'application/json',
        'x-tenant-id': 'org-test',
      }),
    }));
    expect(toastSuccess).toHaveBeenCalled();
    expect(toastError).not.toHaveBeenCalled();
  });
});

beforeAll(() => {
  (globalThis as unknown as Record<string, unknown>).React = React;
});

]]>
</file>

<file path="tests/unit/app/fm/tenants/page.test.tsx">
<![CDATA[
import React from "react";
import { vi, describe, beforeEach, test, expect, beforeAll } from "vitest";
import { render, screen } from "@testing-library/react";

import TenantsPage from "@/app/fm/tenants/page";

const mockUseSession = vi.fn();
const mockUseOrgGuard = vi.fn();
const mockUseSWR = vi.fn();

vi.mock("next-auth/react", () => ({
  useSession: () => mockUseSession(),
}));

vi.mock("swr", () => ({
  __esModule: true,
  default: (...args: Parameters<typeof mockUseSWR>) => mockUseSWR(...args),
}));

vi.mock("@/components/fm/useFmOrgGuard", () => ({
  useFmOrgGuard: () => mockUseOrgGuard(),
}));

vi.mock("@/components/fm/ModuleViewTabs", () => ({
  __esModule: true,
  default: ({ moduleId }: { moduleId: string }) => (
    <div data-testid="module-tabs">{moduleId}</div>
  ),
}));

vi.mock("@/components/fm/tenants/CreateTenantForm", () => ({
  CreateTenantForm: ({ orgId }: { orgId: string }) => (
    <div data-testid="create-tenant-form">{orgId}</div>
  ),
}));

beforeEach(() => {
  vi.clearAllMocks();
  mockUseSession.mockReturnValue({ data: { user: {} } });
  mockUseOrgGuard.mockReturnValue({
    hasOrgContext: true,
    orgId: "org-test",
    guard: null,
    supportBanner: null,
  });
  mockUseSWR.mockReturnValue({
    data: { items: [] },
    isLoading: false,
    mutate: vi.fn(),
    error: null,
  });
});

describe("TenantsPage org guard behavior", () => {
  test("renders guard when no organization selected", () => {
    mockUseOrgGuard.mockReturnValue({
      hasOrgContext: false,
      orgId: null,
      guard: <div data-testid="org-guard" />,
      supportBanner: null,
    });

    render(<TenantsPage />);

    expect(screen.getByTestId("org-guard")).toBeInTheDocument();
    expect(screen.queryByTestId("module-tabs")).not.toBeInTheDocument();
  });

  test("renders tenant layout when organization context exists", () => {
    mockUseOrgGuard.mockReturnValue({
      hasOrgContext: true,
      orgId: "org-123",
      guard: null,
      supportBanner: <div data-testid="support-banner">banner</div>,
    });

    mockUseSWR.mockReturnValue({
      data: { items: [] },
      isLoading: false,
      mutate: vi.fn(),
      error: null,
    });

    render(<TenantsPage />);

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("tenants");
    expect(screen.getByTestId("support-banner")).toBeInTheDocument();
    expect(screen.getByText(/Tenant Management/i)).toBeInTheDocument();
  });
});
beforeAll(() => {
  (globalThis as unknown as Record<string, unknown>).React = React;
});

]]>
</file>

<file path="tests/unit/app/fm/vendors/page.test.tsx">
<![CDATA[
import React from "react";
import { vi, describe, beforeEach, test, expect, beforeAll } from "vitest";
import { render, screen } from "@testing-library/react";

import VendorsPage from "@/app/fm/vendors/page";

const mockUseSession = vi.fn();
const mockUseFmOrgGuard = vi.fn();
const mockUseSWR = vi.fn();

vi.mock("next-auth/react", () => ({
  useSession: () => mockUseSession(),
}));

vi.mock("next/navigation", () => ({
  useRouter: () => ({ push: vi.fn() }),
}));

vi.mock("swr", () => ({
  __esModule: true,
  default: (...args: Parameters<typeof mockUseSWR>) => mockUseSWR(...args),
}));

vi.mock("@/components/fm/useFmOrgGuard", () => ({
  useFmOrgGuard: () => mockUseFmOrgGuard(),
}));

vi.mock("@/components/fm/ModuleViewTabs", () => ({
  __esModule: true,
  default: ({ moduleId }: { moduleId: string }) => (
    <div data-testid="module-tabs">{moduleId}</div>
  ),
}));

vi.mock("sonner", () => {
  const toastFn = vi.fn();
  toastFn.success = vi.fn();
  toastFn.error = vi.fn();
  toastFn.loading = vi.fn(() => "toast-id");
  return { toast: toastFn };
});

beforeEach(() => {
  vi.clearAllMocks();
  mockUseSession.mockReturnValue({ data: { user: {} } });
  mockUseFmOrgGuard.mockReturnValue({
    hasOrgContext: true,
    orgId: "org-test",
    guard: null,
    supportBanner: null,
  });
  mockUseSWR.mockReturnValue({
    data: { items: [], pages: 1 },
    isLoading: false,
    mutate: vi.fn(),
    error: null,
  });
});

describe("VendorsPage org guard behavior", () => {
  test("renders guard when org context missing", () => {
    mockUseFmOrgGuard.mockReturnValue({
      hasOrgContext: false,
      orgId: null,
      guard: <div data-testid="org-guard" />,
      supportBanner: null,
    });

    render(<VendorsPage />);

    expect(screen.getByTestId("org-guard")).toBeInTheDocument();
    expect(screen.queryByTestId("module-tabs")).not.toBeInTheDocument();
  });

  test("renders vendor list when org context available", () => {
    mockUseFmOrgGuard.mockReturnValue({
      hasOrgContext: true,
      orgId: "org-456",
      guard: null,
      supportBanner: <div data-testid="support-banner" />,
    });
    mockUseSWR.mockReturnValue({
      data: { items: [], pages: 1 },
      isLoading: false,
      mutate: vi.fn(),
      error: null,
    });

    render(<VendorsPage />);

    expect(screen.getByTestId("module-tabs")).toHaveTextContent("vendors");
    expect(screen.getByTestId("support-banner")).toBeInTheDocument();
  });
});
beforeAll(() => {
  (globalThis as unknown as Record<string, unknown>).React = React;
});

]]>
</file>

</batch_content>
