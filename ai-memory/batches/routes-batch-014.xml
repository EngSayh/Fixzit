
You are the "Fixzit Memory Builder" for category: "routes".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "routes",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="app/api/payments/paytabs/callback/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { logger } from "@/lib/logger";
import { validateCallback } from "@/lib/paytabs";
import { connectToDatabase } from "@/lib/mongodb-unified";
import {
  buildPaytabsIdempotencyKey,
  enforcePaytabsPayloadSize,
  extractPaytabsSignature,
  normalizePaytabsCallbackPayload,
  parsePaytabsJsonPayload,
  PaytabsCallbackValidationError,
  PAYTABS_CALLBACK_IDEMPOTENCY_TTL_MS,
  PAYTABS_CALLBACK_RATE_LIMIT,
} from "@/lib/payments/paytabs-callback.contract";
import { fetchWithRetry } from "@/lib/http/fetchWithRetry";
import { SERVICE_RESILIENCE } from "@/config/service-timeouts";
import { getCircuitBreaker } from "@/lib/resilience";
import { withIdempotency } from "@/server/security/idempotency";
import { smartRateLimit } from "@/server/security/rateLimit";
import {
  unauthorizedError,
  validationError,
  rateLimitError,
  handleApiError,
} from "@/server/utils/errorResponses";
import { createSecureResponse, getClientIP } from "@/server/security/headers";
import { Config } from "@/lib/config/constants";
import {
  clearTenantContext,
  setTenantContext,
} from "@/server/plugins/tenantIsolation";
import { Types } from "mongoose";

const PAYTABS_SERVER_KEY = Config.payment.paytabs.serverKey;
const PAYTABS_CONFIGURED = Boolean(
  PAYTABS_SERVER_KEY && Config.payment.paytabs.profileId,
);

/**
 * @openapi
 * /api/payments/paytabs/callback:
 *   post:
 *     summary: PayTabs payment callback webhook
 *     description: Handles payment gateway callbacks for transaction processing. Validates signature, updates payment status, generates ZATCA-compliant invoices for Saudi Arabia tax compliance.
 *     tags:
 *       - Payments
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               tran_ref:
 *                 type: string
 *               cart_id:
 *                 type: string
 *               resp_status:
 *                 type: string
 *               resp_message:
 *                 type: string
 *               amount:
 *                 type: number
 *     responses:
 *       200:
 *         description: Payment processed successfully
 *       401:
 *         description: Invalid signature
 *       400:
 *         description: Invalid amount
 *       429:
 *         description: Rate limit exceeded
 */
export async function POST(req: NextRequest) {
  try {
    const clientIp = getClientIP(req);
    const rl = await smartRateLimit(
      `payment-callback:${clientIp}`,
      PAYTABS_CALLBACK_RATE_LIMIT.requests,
      PAYTABS_CALLBACK_RATE_LIMIT.windowMs,
    );
    if (!rl.allowed) {
      return rateLimitError();
    }

    const raw = await req.text();
    try {
      enforcePaytabsPayloadSize(raw);
    } catch (error) {
      if (error instanceof PaytabsCallbackValidationError) {
        return createSecureResponse({ error: error.message }, 413, req);
      }
      throw error;
    }

    let payload;
    try {
      payload = parsePaytabsJsonPayload(raw);
    } catch (error) {
      if (error instanceof PaytabsCallbackValidationError) {
        logger.error("[PayTabs] Invalid marketplace callback payload", {
          message: error.message,
        });
        return createSecureResponse({ error: error.message }, 400, req);
      }
      throw error;
    }

    const signature = extractPaytabsSignature(req, payload);
    
    // SECURITY: Fail closed - reject callbacks without signature OR when PayTabs not configured
    // This prevents spoofed payment completions in misconfigured environments
    if (!signature) {
      logger.error("[PayTabs] Callback rejected - missing signature", {
        paytabsConfigured: PAYTABS_CONFIGURED,
      });
      return unauthorizedError("Invalid payment callback signature");
    }
    
    if (!PAYTABS_CONFIGURED) {
      logger.error("[PayTabs] Callback rejected - PayTabs not configured");
      return unauthorizedError("Payment gateway not configured");
    }

    const isValid = validateCallback(payload, signature || "");
    if (!isValid) {
      return unauthorizedError("Invalid payment callback signature");
    }

    let normalized;
    try {
      normalized = normalizePaytabsCallbackPayload(payload);
    } catch (error) {
      if (error instanceof PaytabsCallbackValidationError) {
        return createSecureResponse({ error: error.message }, 400, req);
      }
      throw error;
    }

    const success = normalized.respStatus === "A";

    // Validate cartId is a valid ObjectId before any DB operations
    // This prevents Mongoose cast errors from malformed webhook payloads
    if (!Types.ObjectId.isValid(normalized.cartId)) {
      logger.error("[PayTabs] Invalid cart_id format received", {
        cartId: normalized.cartId?.slice?.(0, 8) || "invalid",
      });
      return validationError("Invalid payment identifier format");
    }

    // Ensure DB connection is established (critical for serverless cold starts)
    await connectToDatabase();
    
    // CRITICAL: Verify payment record exists for all callbacks (success or failure)
    // Note: Initial lookup by _id only to get orgId, then we validate tenant context exists
    const { AqarPayment } = await import("@/server/models/aqar");
    const payment = await AqarPayment.findById(normalized.cartId)
      .select("status amount currency orgId")
      .lean();

    if (!payment) {
      logger.error("[PayTabs] Payment record not found", {
        cartId: normalized.cartId.slice(0, 8) + "...",
        respStatus: normalized.respStatus,
      });
      return validationError("Payment record not found");
    }

    // Get orgId for tenant-scoped updates
    const orgId = (payment as { orgId?: unknown }).orgId;
    const normalizedOrgId = orgId ? String(orgId) : undefined;

    // SECURITY: Fail closed when orgId is missing - prevents unscoped updates
    // All payments MUST have tenant attribution for multi-tenancy compliance
    if (!normalizedOrgId) {
      logger.error("[PayTabs] Payment record missing tenant context (orgId)", {
        cartId: normalized.cartId.slice(0, 8) + "...",
        respStatus: normalized.respStatus,
      });
      return validationError("Payment record missing tenant context");
    }

    // SECURITY: Build org-scoped filter to prevent cross-tenant updates
    // Using shared utility to avoid duplication and ensure consistent ObjectId handling
    const { buildOrgScopedFilter } = await import("@/lib/utils/org-scope");
    const orgScopedFilter = buildOrgScopedFilter(normalized.cartId, normalizedOrgId);

    // Handle non-success callbacks - mark payment as FAILED
    if (!success) {
      const currentStatus = (payment as { status?: string }).status;
      if (currentStatus === "PENDING" || currentStatus === "PROCESSING") {
        // normalizedOrgId is guaranteed to exist (fail-closed validation above)
        setTenantContext({ orgId: normalizedOrgId, userId: "paytabs-webhook" });
        try {
          await AqarPayment.findOneAndUpdate(
            orgScopedFilter,
            {
              $set: {
                status: "FAILED",
                failedAt: new Date(),
                gatewayTransactionId: normalized.tranRef,
                "gatewayResponse.respStatus": normalized.respStatus,
                "gatewayResponse.respMessage": normalized.respMessage,
              },
            },
            { runValidators: true },
          );
          logger.info("[PayTabs] Payment marked as FAILED", {
            cartId: normalized.cartId.slice(0, 8) + "...",
            respStatus: normalized.respStatus,
            respMessage: normalized.respMessage,
          });
        } finally {
          clearTenantContext();
        }
      }
      return createSecureResponse(
        { ok: true, status: "FAILED", message: normalized.respMessage },
        200,
        req,
      );
    }

    // Success path continues below
    if (success) {
      const total = normalized.amount;
      if (!Number.isFinite(total) || (total as number) <= 0) {
        return validationError("Invalid payment amount");
      }

      // Prevent duplicate processing - only PENDING payments can be completed
      if ((payment as { status?: string }).status !== "PENDING") {
        logger.warn("[PayTabs] Payment already processed", {
          cartId: normalized.cartId.slice(0, 8) + "...",
          currentStatus: (payment as { status?: string }).status,
        });
        // Return success to acknowledge callback - idempotent behavior
        return createSecureResponse(
          { ok: true, status: "ALREADY_PROCESSED", message: "Payment already processed" },
          200,
          req,
        );
      }

      // Validate amount integrity - prevent tampered callbacks with lower amounts
      const paymentAmount = (payment as { amount?: number }).amount;
      const paymentCurrency = (payment as { currency?: string }).currency || "SAR";
      if (paymentAmount !== total) {
        logger.error("[PayTabs] Amount mismatch - possible tampering", {
          cartId: normalized.cartId.slice(0, 8) + "...",
          expected: paymentAmount,
          received: total,
        });
        // Mark as FAILED to close out PENDING record and prevent retry loops
        // normalizedOrgId is guaranteed to exist (fail-closed validation above)
        setTenantContext({ orgId: normalizedOrgId, userId: "paytabs-webhook" });
        try {
          await AqarPayment.findOneAndUpdate(
            orgScopedFilter,
            {
              $set: {
                status: "FAILED",
                failedAt: new Date(),
                failureReason: "AMOUNT_MISMATCH",
                "gatewayResponse.respStatus": normalized.respStatus,
                "gatewayResponse.amountReceived": total,
                "gatewayResponse.amountExpected": paymentAmount,
              },
            },
            { runValidators: true },
          );
        } finally {
          clearTenantContext();
        }
        return validationError("Payment amount mismatch");
      }

      if (normalized.currency && normalized.currency !== paymentCurrency) {
        logger.error("[PayTabs] Currency mismatch - possible tampering", {
          cartId: normalized.cartId.slice(0, 8) + "...",
          expected: paymentCurrency,
          received: normalized.currency,
        });
        // Mark as FAILED to close out PENDING record and prevent retry loops
        // normalizedOrgId is guaranteed to exist (fail-closed validation above)
        setTenantContext({ orgId: normalizedOrgId, userId: "paytabs-webhook" });
        try {
          await AqarPayment.findOneAndUpdate(
            orgScopedFilter,
            {
              $set: {
                status: "FAILED",
                failedAt: new Date(),
                failureReason: "CURRENCY_MISMATCH",
                "gatewayResponse.respStatus": normalized.respStatus,
                "gatewayResponse.currencyReceived": normalized.currency,
                "gatewayResponse.currencyExpected": paymentCurrency,
              },
            },
            { runValidators: true },
          );
        } finally {
          clearTenantContext();
        }
        return validationError("Payment currency mismatch");
      }

      try {
        await withIdempotency(
          buildPaytabsIdempotencyKey(normalized, { route: "marketplace" }),
          async () => {
            // Set tenant context for all operations
            // normalizedOrgId is guaranteed to exist (fail-closed validation above)
            setTenantContext({ orgId: normalizedOrgId, userId: "paytabs-webhook" });

            // Update payment status to PROCESSING first (reversible state)
            // Only mark COMPLETED after successful ZATCA clearance
            const { AqarPayment: PaymentModel } = await import("@/server/models/aqar");
            await PaymentModel.findOneAndUpdate(
              orgScopedFilter,
              {
                $set: {
                  status: "PROCESSING",
                  gatewayTransactionId: normalized.tranRef,
                  method: normalized.paymentMethod || "CREDIT_CARD",
                },
              },
              { runValidators: true },
            );
            logger.info("[PayTabs] Payment marked as PROCESSING", {
              cartId: normalized.cartId.slice(0, 8) + "...",
            });

            try {
              await handleSuccessfulMarketplacePayment({
                cartId: normalized.cartId,
                amount: total as number,
                currency: paymentCurrency,
                orgId: normalizedOrgId,
                orgScopedFilter,
              });
              logger.info("Payment successful", {
                order: normalized.cartId.slice(0, 8) + "...",
              });
            } catch (innerError) {
              // COMPENSATION: Revert PROCESSING to FAILED on non-ZATCA errors
              // This prevents payments from being stuck in PROCESSING forever
              if (!(innerError instanceof ZatcaClearanceError)) {
                logger.error("[PayTabs] Non-ZATCA error during payment processing - reverting to FAILED", {
                  cartId: normalized.cartId.slice(0, 8) + "...",
                  error: innerError instanceof Error ? innerError.message : String(innerError),
                });
                try {
                  await PaymentModel.findOneAndUpdate(
                    orgScopedFilter,
                    {
                      $set: {
                        status: "FAILED",
                        failedAt: new Date(),
                        failureReason: "PROCESSING_ERROR",
                        lastError: innerError instanceof Error ? innerError.message : String(innerError),
                      },
                    },
                    { runValidators: true },
                  );
                } catch (rollbackError) {
                  logger.error("[PayTabs] Failed to rollback PROCESSING status", {
                    cartId: normalized.cartId.slice(0, 8) + "...",
                    rollbackError: rollbackError instanceof Error ? rollbackError.message : String(rollbackError),
                  });
                }
              }
              throw innerError;
            }
          },
          PAYTABS_CALLBACK_IDEMPOTENCY_TTL_MS,
        );
      } catch (error) {
        if (error instanceof ZatcaClearanceError) {
          logger.error("[ZATCA] Fatoora clearance FAILED - marking payment as ZATCA_PENDING", {
            cartId: normalized.cartId.slice(0, 8) + "...",
            error: error.message,
          });
          
          // Rollback: Mark payment as COMPLETED but with ZATCA pending status
          // This allows retry of ZATCA clearance without losing payment info
          try {
            const { AqarPayment: PaymentModel } = await import("@/server/models/aqar");
            // normalizedOrgId is guaranteed to exist (fail-closed validation above)
            setTenantContext({ orgId: normalizedOrgId, userId: "paytabs-webhook" });
            await PaymentModel.findOneAndUpdate(
              orgScopedFilter,
              {
                $set: {
                  status: "COMPLETED",
                  paidAt: new Date(),
                  "zatca.complianceStatus": "PENDING_RETRY",
                  "zatca.lastError": error.message,
                  "zatca.lastAttemptAt": new Date(),
                },
              },
              { runValidators: true },
            );
            logger.info("[PayTabs] Payment marked as COMPLETED with ZATCA_PENDING_RETRY", {
              cartId: normalized.cartId.slice(0, 8) + "...",
            });
          } catch (updateError) {
            logger.error("[PayTabs] Failed to update payment status after ZATCA failure", {
              cartId: normalized.cartId.slice(0, 8) + "...",
              error: updateError instanceof Error ? updateError.message : String(updateError),
            });
          }
          
          // Use createSecureResponse for consistent security headers on error responses
          return createSecureResponse(error.body, error.status, req);
        }
        throw error;
      }
    }

    return createSecureResponse(
      {
        ok: true,
        status: success ? "PAID" : "FAILED",
        message: normalized.respMessage,
      },
      200,
      req,
    );
  } catch (error: unknown) {
    return handleApiError(error);
  } finally {
    // Ensure any tenant context set during webhook handling is cleared
    clearTenantContext();
  }
}

type ZatcaClearanceResponse = {
  clearanceStatus?: string;
  clearanceId?: string;
  uuid?: string;
  qrCode?: string;
  invoiceHash?: string;
};

class ZatcaClearanceError extends Error {
  public readonly body: {
    ok: false;
    status: string;
    message: string;
    error: string;
  };

  constructor(
    reason: string,
    public readonly status: number = 500,
  ) {
    super(reason);
    this.name = "ZatcaClearanceError";
    this.body = {
      ok: false,
      status: "ZATCA_CLEARANCE_FAILED",
      message:
        "Payment received but ZATCA/Fatoora clearance failed. Invoice non-compliant.",
      error: reason,
    };
  }
}

async function handleSuccessfulMarketplacePayment({
  cartId,
  amount,
  currency = "SAR",
  orgId,
  orgScopedFilter,
}: {
  cartId: string;
  amount: number;
  currency?: string;
  orgId?: string;
  orgScopedFilter: Record<string, unknown>;
}): Promise<void> {
  // Tenant context is set by caller (POST handler) and cleared in its finally block.
  // Do NOT set context here to avoid nested context ownership ambiguity.

  if (process.env.NODE_ENV !== "production") {
    // In non-production, mark as COMPLETED immediately (no ZATCA)
    const { AqarPayment: PaymentModel } = await import("@/server/models/aqar");
    await PaymentModel.findOneAndUpdate(
      orgScopedFilter,
      {
        $set: {
          status: "COMPLETED",
          paidAt: new Date(),
          "zatca.complianceStatus": "NOT_REQUIRED",
        },
      },
      { runValidators: true },
    );
    logger.warn(
      "[ZATCA] Skipping Fatoora clearance in non-production environment",
      {
        cartId,
        amount,
      },
    );
    
    // Still try to activate package (pass orgId for tenant isolation)
    // Use retry-safe version that enqueues on failure instead of throwing
    await tryActivatePackageWithRetry(cartId, orgId);
    return;
  }

  // ZATCA COMPLIANCE: Require all seller identity envs - no production fallbacks
  const zatcaSellerName = process.env.ZATCA_SELLER_NAME;
  const zatcaVatNumber = process.env.ZATCA_VAT_NUMBER;
  const zatcaSellerAddress = process.env.ZATCA_SELLER_ADDRESS;
  const clearanceApiKey = process.env.ZATCA_API_KEY;

  if (!clearanceApiKey || !zatcaSellerName || !zatcaVatNumber || !zatcaSellerAddress) {
    const missingEnvs = [
      !clearanceApiKey && "ZATCA_API_KEY",
      !zatcaSellerName && "ZATCA_SELLER_NAME",
      !zatcaVatNumber && "ZATCA_VAT_NUMBER",
      !zatcaSellerAddress && "ZATCA_SELLER_ADDRESS",
    ].filter(Boolean);
    
    throw new ZatcaClearanceError(
      `ZATCA configuration incomplete - missing: ${missingEnvs.join(", ")}`
    );
  }

  const invoicePayload = {
    invoiceType: "SIMPLIFIED",
    invoiceNumber: `PAY-${cartId}`,
    issueDate: new Date().toISOString(),
    seller: {
      name: zatcaSellerName,
      vatNumber: zatcaVatNumber,
      address: zatcaSellerAddress,
    },
    total: String(amount),
    currency,
    vatAmount: String(+(amount * 0.15).toFixed(2)),
    items: [
      {
        description: "Payment via PayTabs",
        quantity: 1,
        unitPrice: amount,
        vatRate: 0.15,
      },
    ],
  };

  // Use centralized ZATCA config URL (avoids duplication)
  const clearanceApiUrl = SERVICE_RESILIENCE.zatca.clearanceApiUrl;

  const zatcaResilience = SERVICE_RESILIENCE.zatca;
  const zatcaBreaker = getCircuitBreaker("zatca");

  const clearanceHttpResponse = await fetchWithRetry(
    clearanceApiUrl,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${clearanceApiKey}`,
        Accept: "application/json",
      },
      body: JSON.stringify(invoicePayload),
    },
    {
      timeoutMs: zatcaResilience.timeouts.clearanceMs,
      maxAttempts: zatcaResilience.retries.maxAttempts,
      retryDelayMs: zatcaResilience.retries.baseDelayMs,
      label: "zatca-clearance",
      circuitBreaker: zatcaBreaker,
      shouldRetry: ({ response, error }) => {
        if (error) return true;
        if (!response) return false;
        return response.status >= 500 || response.status === 429;
      },
    },
  );

  if (!clearanceHttpResponse.ok) {
    const errorData = await clearanceHttpResponse.json().catch(() => ({}));
    throw new ZatcaClearanceError(
      `ZATCA clearance API returned ${clearanceHttpResponse.status}: ${JSON.stringify(errorData)}`,
      clearanceHttpResponse.status >= 400 ? clearanceHttpResponse.status : 500,
    );
  }

  const clearanceResponse =
    (await clearanceHttpResponse.json()) as ZatcaClearanceResponse;
  if (!clearanceResponse || typeof clearanceResponse !== "object") {
    throw new ZatcaClearanceError("Invalid ZATCA clearance response structure");
  }
  if (
    !clearanceResponse.clearanceStatus ||
    clearanceResponse.clearanceStatus !== "CLEARED"
  ) {
    throw new ZatcaClearanceError(
      `ZATCA clearance not approved: ${clearanceResponse.clearanceStatus || "UNKNOWN"}`,
    );
  }

  const clearanceId = clearanceResponse.clearanceId || clearanceResponse.uuid;
  const zatcaQR = clearanceResponse.qrCode;
  const invoiceHash = clearanceResponse.invoiceHash;
  if (!clearanceId || !zatcaQR) {
    throw new ZatcaClearanceError(
      "ZATCA clearance response missing required fields (clearanceId or qrCode)",
    );
  }

  try {
    await updatePaymentRecord(cartId, orgId, {
      zatcaQR,
      zatcaInvoiceHash: invoiceHash,
      fatooraClearanceId: clearanceId,
      fatooraClearedAt: new Date(),
      zatcaSubmittedAt: new Date(),
      invoicePayload,
      complianceStatus: "CLEARED",
    });
  } catch (error) {
    const reason =
      error instanceof Error
        ? error.message
        : `Payment record persistence failed: ${String(error)}`;
    throw new ZatcaClearanceError(
      `Payment cleared by ZATCA but failed to persist evidence: ${reason}`,
    );
  }

  logger.info("[ZATCA] Fatoora clearance successful", {
    cartId: cartId.slice(0, 8) + "...",
    clearanceId: clearanceId ? String(clearanceId).slice(0, 16) + "..." : "N/A",
  });

  // Pass orgId for tenant-scoped package activation
  // If activation fails, enqueue for retry instead of failing the webhook
  await tryActivatePackageWithRetry(cartId, orgId);
}

/**
 * Attempt package activation with automatic retry queue fallback.
 * If activation fails, enqueue a retry job instead of failing the webhook.
 * This ensures paid tenants are provisioned even if activation has transient failures.
 */
async function tryActivatePackageWithRetry(cartId: string, orgId?: string): Promise<void> {
  // SECURITY: Fail-closed - if orgId missing, log error but don't block webhook
  if (!orgId) {
    logger.error("[PayTabs] Package activation skipped: orgId required for tenant isolation", {
      cart_id: cartId.slice(0, 8) + "...",
    });
    // Don't throw - webhook should succeed to acknowledge PayTabs
    return;
  }

  try {
    const { activatePackageAfterPayment } = await import(
      "@/lib/aqar/package-activation"
    );
    const activated = await activatePackageAfterPayment(String(cartId), orgId);

    if (!activated) {
      // Activation returned false - validation failure, enqueue for retry
      throw new Error(`Package activation returned false for cart_id=${cartId.slice(0, 8)}...`);
    }

    logger.info("[PayTabs] Package activated successfully", {
      cart_id: cartId.slice(0, 8) + "...",
    });
  } catch (err) {
    logger.warn("[PayTabs] Package activation failed, enqueueing retry", {
      cart_id: cartId.slice(0, 8) + "...",
      error: err instanceof Error ? err.message : String(err),
    });

    // Enqueue for background retry instead of failing webhook
    try {
      // Get invoiceId from payment record for retry tracking
      const { AqarPayment } = await import("@/server/models/aqar");
      const { buildOrgScopedFilter } = await import("@/lib/utils/org-scope");
      const payment = await AqarPayment.findOne(buildOrgScopedFilter(cartId, orgId))
        .select("invoiceId")
        .lean();

      const invoiceId = payment?.invoiceId?.toString() || cartId; // Fallback to cartId if no invoiceId

      const { enqueueActivationRetry } = await import("@/jobs/package-activation-queue");
      const jobId = await enqueueActivationRetry(cartId, invoiceId, orgId);

      if (jobId) {
        logger.info("[PayTabs] Activation retry enqueued", {
          cart_id: cartId.slice(0, 8) + "...",
          jobId,
        });
      } else {
        logger.error("[PayTabs] Failed to enqueue activation retry (Redis unavailable?)", {
          cart_id: cartId.slice(0, 8) + "...",
        });
      }
    } catch (queueErr) {
      logger.error("[PayTabs] Failed to enqueue activation retry", {
        cart_id: cartId.slice(0, 8) + "...",
        error: queueErr instanceof Error ? queueErr.message : String(queueErr),
      });
    }
    // Don't re-throw - webhook should succeed to acknowledge PayTabs
  }
}

// NOTE: _tryActivatePackage is kept as a reference for strict fail-closed behavior
// Use tryActivatePackageWithRetry for production webhooks (enqueues retries on failure)
async function _tryActivatePackage(cartId: string, orgId?: string): Promise<void> {
  // SECURITY: Fail-closed - throw if orgId missing to surface upstream issues
  if (!orgId) {
    const msg = "Package activation BLOCKED: orgId required for tenant isolation";
    logger.error(`[PayTabs] ${msg}`, {
      cart_id: cartId.slice(0, 8) + "...",
    });
    throw new Error(msg);
  }
  try {
    const { activatePackageAfterPayment } = await import(
      "@/lib/aqar/package-activation"
    );
    const activated = await activatePackageAfterPayment(String(cartId), orgId);
    // SECURITY: Fail-closed if activation returned false (validation failure)
    if (!activated) {
      throw new Error(`Package activation returned false for cart_id=${cartId.slice(0, 8)}... - validation failure`);
    }
  } catch (err) {
    logger.error("[PayTabs] Package activation failed", {
      cart_id: cartId.slice(0, 8) + "...",
      error: err instanceof Error ? err.message : String(err),
    });
    // Re-throw to propagate failure to caller
    throw err;
  }
}

async function updatePaymentRecord(
  cartId: string,
  callerOrgId: string | undefined,
  evidence: {
    zatcaQR: string;
    zatcaInvoiceHash?: string;
    fatooraClearanceId: string;
    fatooraClearedAt: Date;
    zatcaSubmittedAt: Date;
    invoicePayload: Record<string, unknown>;
    complianceStatus: string;
  },
) {
  const { AqarPayment } = await import("@/server/models/aqar");
  const { buildOrgScopedFilter } = await import("@/lib/utils/org-scope");

  // SECURITY: Use org-scoped lookup from the start to prevent cross-tenant reads
  // Caller provides orgId from already-validated context (main POST handler)
  // NOTE: Tenant context is managed by the caller (POST handler) - we rely on that
  // to avoid nested context ownership ambiguity. The caller's finally block clears context.
  if (!callerOrgId) {
    throw new Error(`Payment update requires orgId for cart_id: ${cartId}`);
  }

  // Build org-scoped filter using shared helper (includes ObjectId variants)
  const orgScopedFilter = buildOrgScopedFilter(cartId, callerOrgId);

  // Verify payment exists with org-scoped query (no unscoped read)
  const existing = await AqarPayment.findOne(orgScopedFilter)
    .select("_id orgId org_id")
    .lean()
    .exec();

  if (!existing) {
    throw new Error(`Payment record not found for cart_id: ${cartId} (org-scoped)`);
  }

  // NOTE: No setTenantContext here - caller already manages tenant context
  // This avoids nested context ownership ambiguity
  const result = await AqarPayment.findOneAndUpdate(
    orgScopedFilter,
    {
      $set: {
        // Mark as COMPLETED only after successful ZATCA clearance
        status: "COMPLETED",
        paidAt: new Date(),
        "zatca.qrCode": evidence.zatcaQR,
        "zatca.invoiceHash": evidence.zatcaInvoiceHash,
        "zatca.clearanceId": evidence.fatooraClearanceId,
        "zatca.clearedAt": evidence.fatooraClearedAt,
        "zatca.submittedAt": evidence.zatcaSubmittedAt,
        "zatca.invoicePayload": evidence.invoicePayload,
        "zatca.complianceStatus": evidence.complianceStatus,
        updatedAt: new Date(),
      },
    },
    {
      new: true,
      upsert: false,
      runValidators: true,
    },
  );

  if (!result) {
    throw new Error(
      `Payment record not found for cart_id: ${cartId} (org scoped)`,
    );
  }

  return result;
}

// Exported for testing to validate tenant alias handling
export { updatePaymentRecord };

]]>
</file>

<file path="app/api/payments/paytabs/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { logger } from "@/lib/logger";
import { z } from "zod";

import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
import { createSecureResponse } from "@/server/security/headers";
import { getClientIP } from "@/server/security/headers";
import { fetchWithRetry } from "@/lib/http/fetchWithRetry";
import { SERVICE_RESILIENCE } from "@/config/service-timeouts";
import { getCircuitBreaker } from "@/lib/resilience";
import { Config } from "@/lib/config/constants";

const PaymentSchema = z.object({
  orderId: z.string(),
  amount: z.number().positive(),
  currency: z.string().default("SAR"),
  customerEmail: z.string().email(),
  customerName: z.string(),
  customerPhone: z.string(),
});

/**
 * Create a PayTabs payment page for an incoming POST request and return a JSON response.
 *
 * Validates the request body against `PaymentSchema`, builds a PayTabs payload, and POSTs it
 * to the PayTabs payment request endpoint with a 15-second timeout. On success returns
 * `{ ok: true, paymentUrl, tranRef }`. Returns structured error responses for missing server key
 * (500), upstream PayTabs failures (502 with status and body), payment initialization failures (400
 * with details), or unexpected errors (500).
 *
 * @returns A NextResponse containing a JSON object describing success or failure and appropriate HTTP status codes.
 */
/**
 * @openapi
 * /api/payments/paytabs:
 *   get:
 *     summary: payments/paytabs operations
 *     tags: [payments]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function POST(req: NextRequest) {
  // Rate limiting
  const clientIp = getClientIP(req);
  const rl = await smartRateLimit(`${new URL(req.url).pathname}:${clientIp}`, 10, 300000);
  if (!rl.allowed) {
    return rateLimitError();
  }

  try {
    const body = await req.json();
    const data = PaymentSchema.parse(body);

    const serverKey = Config.payment.paytabs.serverKey;
    if (!serverKey) {
      return createSecureResponse(
        { error: "PAYTABS server key not configured" },
        500,
        req,
      );
    }

    const payload = {
      profile_id: Config.payment.paytabs.profileId,
      tran_type: "sale",
      tran_class: "ecom",
      cart_id: data.orderId,
      cart_currency: data.currency,
      cart_amount: data.amount.toFixed(2),
      cart_description: `Fixzit Order ${data.orderId}`,
      customer_details: {
        name: data.customerName,
        email: data.customerEmail,
        phone: data.customerPhone,
        country: "SA",
      },
      callback: `${Config.auth.url}/api/payments/paytabs/callback`,
      return: `${Config.auth.url}/marketplace/order-success`,
    };

    const paytabsResilience = SERVICE_RESILIENCE.paytabs;
    const paytabsBreaker = getCircuitBreaker("paytabs");

    const response = await fetchWithRetry(
      "https://secure.paytabs.sa/payment/request",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: serverKey,
        },
        body: JSON.stringify(payload),
      },
      {
        timeoutMs: paytabsResilience.timeouts.paymentMs,
        maxAttempts: paytabsResilience.retries.maxAttempts,
        retryDelayMs: paytabsResilience.retries.baseDelayMs,
        label: "paytabs-payment-request",
        circuitBreaker: paytabsBreaker,
        shouldRetry: ({ response, error }) => {
          if (error) return true;
          if (!response) return false;
          return response.status >= 500 || response.status === 429;
        },
      },
    );

    if (!response.ok) {
      const text = await response.text().catch(() => "");
      return createSecureResponse(
        {
          error: "PayTabs request failed",
          status: response.status,
          body: text,
        },
        502,
        req,
      );
    }

    const result = await response.json();

    if (result.redirect_url) {
      return NextResponse.json({
        ok: true,
        paymentUrl: result.redirect_url,
        tranRef: result.tran_ref,
      });
    } else {
      return NextResponse.json(
        { ok: false, error: "Payment initialization failed", details: result },
        { status: 400 },
      );
    }
  } catch (error) {
    logger.error(
      "PayTabs error:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return NextResponse.json(
      { ok: false, error: "Payment processing failed" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/payments/tap/checkout/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { randomUUID } from "crypto";
import { Types } from "mongoose";
import { z } from "zod";
import { logger } from "@/lib/logger";
import {
  tapPayments,
  buildTapCustomer,
  buildRedirectUrls,
  buildWebhookConfig,
  type TapChargeRequest,
  type TapChargeResponse,
} from "@/lib/finance/tap-payments";
import { getSessionUser } from "@/server/middleware/withAuthRbac";
import { connectToDatabase } from "@/lib/mongodb-unified";
import { TapTransaction } from "@/server/models/finance/TapTransaction";
import { Invoice } from "@/server/models/Invoice";

interface SessionUser {
  id: string;
  email: string;
  orgId: string;
  [key: string]: unknown;
}

interface InvoiceRecipient {
  name?: string;
  customerId?: string;
  [key: string]: unknown;
}

interface InvoiceDocument {
  _id: Types.ObjectId;
  recipient?: InvoiceRecipient;
  [key: string]: unknown;
}

// SECURITY: Explicit non-empty string validation (not just truthy check)
const TAP_PAYMENTS_CONFIGURED =
  typeof process.env.TAP_SECRET_KEY === "string" &&
  process.env.TAP_SECRET_KEY.trim() !== "" &&
  typeof process.env.TAP_PUBLIC_KEY === "string" &&
  process.env.TAP_PUBLIC_KEY.trim() !== "";

type ChargeResult = Pick<
  TapChargeResponse,
  | "id"
  | "status"
  | "transaction"
  | "metadata"
  | "reference"
  | "currency"
  | "amount"
>;

function buildMockCharge(params: {
  correlationId: string;
  amountHalalas: number;
  currency: string;
  baseUrl: string;
  metadata?: TapChargeRequest["metadata"];
  reference?: TapChargeRequest["reference"];
}): ChargeResult {
  const createdAtIso = new Date().toISOString();
  return {
    id: `chg_mock_${params.correlationId}`, // Use Tap-valid format (starts with chg_)
    status: "INITIATED",
    currency: params.currency,
    amount: params.amountHalalas,
    transaction: {
      timezone: "UTC",
      created: createdAtIso,
      url: `${params.baseUrl}/payments/mock/${params.correlationId}`,
      expiry: { period: 15, type: "MINUTES" },
      asynchronous: false,
    },
    metadata: params.metadata,
    reference: params.reference,
  };
}

const CheckoutRequestSchema = z.object({
  amount: z.number().positive(),
  currency: z.string().optional(),
  description: z.string().optional(),
  orderId: z.string().optional(),
  invoiceId: z.string().optional(),
  metadata: z
    .record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
    .optional(),
  successPath: z.string().optional(),
  errorPath: z.string().optional(),
  paymentContext: z
    .object({
      partyType: z
        .enum(["TENANT", "CUSTOMER", "VENDOR", "SUPPLIER", "OWNER", "OTHER"])
        .optional(),
      partyId: z.string().optional(),
      partyName: z.string().optional(),
      propertyId: z.string().optional(),
      unitId: z.string().optional(),
      notes: z.string().optional(),
    })
    .optional(),
});

/**
 * POST /api/payments/tap/checkout
 *
 * Create a Tap payment checkout session
 *
 * Body:
 * {
 *   amount: number;        // Amount in SAR (will be converted to halalas)
 *   description?: string;  // Payment description
 *   orderId?: string;      // Your internal order ID
 *   metadata?: object;     // Additional metadata
 * }
 *
 * Returns:
 * {
 *   chargeId: string;      // Tap charge ID
 *   transactionUrl: string; // Redirect user to this URL to complete payment
 *   status: string;        // Charge status
 * }
 */
export async function POST(req: NextRequest) {
  const correlationId = randomUUID();

  try {
    // Authenticate user
    let user: SessionUser;
    try {
      user = (await getSessionUser(req)) as unknown as SessionUser;
    } catch (_error) {
      logger.warn("[POST /api/payments/tap/checkout] Unauthenticated request", {
        correlationId,
      });
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    await connectToDatabase();

    const body = CheckoutRequestSchema.parse(await req.json());
    const {
      amount,
      currency = "SAR",
      description,
      orderId,
      invoiceId,
      metadata = {},
      successPath,
      errorPath,
      paymentContext,
    } = body;

    const orgObjectId = Types.ObjectId.isValid(user.orgId)
      ? new Types.ObjectId(user.orgId)
      : null;
    if (!orgObjectId) {
      logger.error(
        "[POST /api/payments/tap/checkout] Invalid orgId on session",
        {
          correlationId,
          orgId: user.orgId,
        },
      );
      return NextResponse.json(
        { error: "Invalid organization context" },
        { status: 400 },
      );
    }

    let invoiceDoc: Awaited<ReturnType<typeof Invoice.findById>> | null = null;
    let invoiceObjectId: Types.ObjectId | undefined;
    if (invoiceId) {
      if (!Types.ObjectId.isValid(invoiceId)) {
        return NextResponse.json(
          { error: "Invalid invoiceId" },
          { status: 400 },
        );
      }
      invoiceObjectId = new Types.ObjectId(invoiceId);
      // SECURITY: Org-scoped filter prevents cross-tenant invoice access
      const orgScopedInvoiceFilter = {
        _id: invoiceObjectId,
        $or: [{ orgId: orgObjectId }, { org_id: orgObjectId }, { orgId: user.orgId }, { org_id: user.orgId }],
      };
      invoiceDoc = await Invoice.findOne(orgScopedInvoiceFilter).lean();
      if (!invoiceDoc) {
        return NextResponse.json(
          { error: "Invoice not found" },
          { status: 404 },
        );
      }
    }

    logger.info("[POST /api/payments/tap/checkout] Creating checkout session", {
      correlationId,
      userId: user.id,
      email: user.email,
      amount,
      orderId,
      invoiceId,
    });

    const amountInHalalas = tapPayments.sarToHalalas(amount);

    // Build customer object
    type InvoiceWithRecipient = typeof invoiceDoc & {
      recipient?: {
        name?: string;
        email?: string;
        phone?: string;
      };
    };
    const invoice = invoiceDoc as InvoiceWithRecipient;

    const invoiceRecipientName = invoice?.recipient?.name;
    const defaultNameParts = user.email ? user.email.split("@") : ["User"];
    const tapCustomer = buildTapCustomer({
      firstName:
        invoiceRecipientName?.split(" ")[0] || defaultNameParts[0] || "User",
      lastName: invoiceRecipientName?.split(" ").slice(1).join(" ") || "",
      email: invoice?.recipient?.email || user.email,
      phone: invoice?.recipient?.phone,
    });

    // Build redirect URLs (user will be sent here after payment)
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
    const redirectUrls = buildRedirectUrls(
      baseUrl,
      successPath || "/payments/success",
      errorPath || "/payments/error",
    );

    // Build webhook config (Tap will send payment events here)
    const webhookConfig = buildWebhookConfig(baseUrl);

    // Create Tap charge request
    const chargeRequest: TapChargeRequest = {
      amount: amountInHalalas,
      currency,
      customer: tapCustomer,
      redirect: redirectUrls,
      post: webhookConfig,
      description: description || "FixZit Payment",
      metadata: {
        ...metadata,
        userId: user.id,
        userEmail: user.email,
        organizationId: user.orgId || undefined,  // ORGID-FIX: Payment system should track orgId for reconciliation
        orderId: orderId || "",
        invoiceId: invoiceId || "",
      },
      reference: {
        transaction: correlationId,
        order: orderId || undefined,
      },
      receipt: {
        email: true,
        sms: Boolean(user.phone),
      },
    };

    // Create charge with Tap API
    const charge: ChargeResult = TAP_PAYMENTS_CONFIGURED
      ? await tapPayments.createCharge(chargeRequest)
      : buildMockCharge({
          correlationId,
          amountHalalas: amountInHalalas,
          currency,
          baseUrl,
          metadata: chargeRequest.metadata,
          reference: chargeRequest.reference,
        });

    logger.info(
      "[POST /api/payments/tap/checkout] Charge created successfully",
      {
        correlationId,
        chargeId: charge.id,
        status: charge.status,
        transactionUrl: charge.transaction.url,
        tapConfigured: TAP_PAYMENTS_CONFIGURED,
      },
    );

    const expiresAt = charge.transaction.expiry
      ? new Date(Date.now() + (charge.transaction.expiry.period ?? 0) * 60000)
      : null;

    const resolvedPartyName =
      paymentContext?.partyName ||
      invoice?.recipient?.name ||
      `${tapCustomer.first_name} ${tapCustomer.last_name}`.trim() ||
      user.email;
    const resolvedPartyType = paymentContext?.partyType || "CUSTOMER";
    const invoiceTyped = invoice as InvoiceDocument | null;
    const resolvedPartyId =
      paymentContext?.partyId || invoiceTyped?.recipient?.customerId;

    await TapTransaction.create({
      orgId: orgObjectId,
      userId: user.id,
      chargeId: charge.id,
      correlationId,
      orderId: orderId || undefined,
      invoiceId: invoiceObjectId,
      paymentContext: {
        partyType: resolvedPartyType,
        partyId: resolvedPartyId,
        partyName: resolvedPartyName,
        propertyId: paymentContext?.propertyId,
        unitId: paymentContext?.unitId,
        notes: paymentContext?.notes || description,
      },
      status: charge.status,
      currency: charge.currency,
      amountHalalas: amountInHalalas,
      amountSAR: amount,
      redirectUrl: charge.transaction.url,
      expiresAt,
      metadata,
      tapMetadata: charge.metadata,
      rawCharge: charge,
      requestContext: {
        successPath: successPath || "/payments/success",
        errorPath: errorPath || "/payments/error",
      },
      events: [
        {
          type: "charge.created",
          status: charge.status,
          at: new Date(),
          payload: {
            transactionUrl: charge.transaction.url,
          },
        },
      ],
    });

    return NextResponse.json({
      success: true,
      chargeId: charge.id,
      transactionUrl: charge.transaction.url,
      status: charge.status,
      expiresAt: expiresAt ? expiresAt.toISOString() : null,
    });
  } catch (error) {
    logger.error(
      "[POST /api/payments/tap/checkout] Error creating checkout session",
      {
        correlationId,
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      },
    );

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request payload", issues: error.issues },
        { status: 400 },
      );
    }

    return NextResponse.json(
      {
        error: "Failed to create payment session",
        message: error instanceof Error ? error.message : "Unknown error",
        correlationId,
      },
      { status: 500 },
    );
  }
}

/**
 * GET /api/payments/tap/checkout/:chargeId
 *
 * Retrieve charge status
 */
export async function GET(req: NextRequest) {
  const correlationId = randomUUID();

  try {
    // Authenticate user
    let user: SessionUser;
    try {
      user = (await getSessionUser(req)) as unknown as SessionUser;
    } catch (_error) {
      logger.warn("[GET /api/payments/tap/checkout] Unauthenticated request", {
        correlationId,
      });
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Extract charge ID from URL
    const url = new URL(req.url);
    const pathParts = url.pathname.split("/");
    const chargeId = pathParts[pathParts.length - 1];

    if (!chargeId || !chargeId.startsWith("chg_")) {
      return NextResponse.json({ error: "Invalid charge ID" }, { status: 400 });
    }

    logger.info("[GET /api/payments/tap/checkout] Retrieving charge", {
      correlationId,
      chargeId,
      userId: user.id,
    });

    // Retrieve charge from Tap
    const charge = await tapPayments.getCharge(chargeId);

    logger.info("[GET /api/payments/tap/checkout] Charge retrieved", {
      correlationId,
      chargeId,
      status: charge.status,
    });

    return NextResponse.json({
      success: true,
      charge: {
        id: charge.id,
        amount: charge.amount,
        currency: charge.currency,
        status: charge.status,
        customer: charge.customer,
        metadata: charge.metadata,
        reference: charge.reference,
        createdAt: charge.transaction.created,
      },
    });
  } catch (error) {
    logger.error("[GET /api/payments/tap/checkout] Error retrieving charge", {
      correlationId,
      error: error instanceof Error ? error.message : String(error),
    });

    return NextResponse.json(
      {
        error: "Failed to retrieve charge",
        message: error instanceof Error ? error.message : "Unknown error",
        correlationId,
      },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/payments/tap/webhook/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { randomUUID } from "crypto";
import { Types } from "mongoose";
import { logger } from "@/lib/logger";
import {
  tapPayments,
  type TapWebhookEvent,
  type TapChargeResponse,
  type TapRefundResponse,
} from "@/lib/finance/tap-payments";
import { connectToDatabase } from "@/lib/mongodb-unified";
import {
  TapTransaction,
  type TapTransactionDoc,
} from "@/server/models/finance/TapTransaction";
import { Payment } from "@/server/models/finance/Payment";
import { Invoice } from "@/server/models/Invoice";
import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
import { getClientIP } from "@/server/security/headers";
import { withIdempotency } from "@/server/security/idempotency";

interface TransactionEvent {
  type: string;
  status: string;
  at: Date;
  payload: unknown;
}

interface InvoicePayment {
  transactionId?: string;
  status?: string;
  notes?: string;
  [key: string]: unknown;
}

/**
 * POST /api/payments/tap/webhook
 *
 * Receive and process Tap payment webhooks
 *
 * Webhook Events:
 * - charge.created: Charge was created
 * - charge.captured: Payment was successful
 * - charge.authorized: Payment was authorized (requires capture)
 * - charge.declined: Payment was declined
 * - charge.failed: Payment failed
 * - refund.created: Refund was created
 * - refund.succeeded: Refund was successful
 * - refund.failed: Refund failed
 *
 * Security:
 * - Verifies webhook signature using TAP_WEBHOOK_SECRET
 * - Logs all events for audit trail
 * - Idempotent processing based on event ID
 */
const TAP_WEBHOOK_MAX_BYTES = Number(
  process.env.TAP_WEBHOOK_MAX_BYTES ?? 64_000,
);
const TAP_WEBHOOK_RATE_LIMIT = {
  requests: Number(process.env.TAP_WEBHOOK_RATE_LIMIT ?? 60),
  windowMs: Number(process.env.TAP_WEBHOOK_RATE_WINDOW_MS ?? 60_000),
};
const TAP_WEBHOOK_IDEMPOTENCY_TTL_MS = Number(
  process.env.TAP_WEBHOOK_IDEMPOTENCY_TTL_MS ?? 5 * 60_000,
);

export async function POST(req: NextRequest) {
  const correlationId = randomUUID();

  try {
    const clientIp = getClientIP(req);
    const rl = await smartRateLimit(
      `tap-webhook:${clientIp}`,
      TAP_WEBHOOK_RATE_LIMIT.requests,
      TAP_WEBHOOK_RATE_LIMIT.windowMs,
    );
    if (!rl.allowed) {
      return rateLimitError();
    }

    // Get raw body for signature verification
    const rawBody = await req.text();
    const bodyBytes = Buffer.byteLength(rawBody, "utf8");
    if (
      Number.isFinite(TAP_WEBHOOK_MAX_BYTES) &&
      TAP_WEBHOOK_MAX_BYTES > 0 &&
      bodyBytes > TAP_WEBHOOK_MAX_BYTES
    ) {
      logger.warn(
        "[POST /api/payments/tap/webhook] Payload exceeds size limit",
        {
          correlationId,
          bodyBytes,
          limit: TAP_WEBHOOK_MAX_BYTES,
          clientIp,
        },
      );
      return NextResponse.json({ error: "Payload too large" }, { status: 413 });
    }

    const signature = req.headers.get("x-tap-signature") || "";

    logger.info("[POST /api/payments/tap/webhook] Received webhook", {
      correlationId,
      signature: signature.substring(0, 10) + "...",
      bodyLength: rawBody.length,
    });

    // Parse and verify webhook event
    let event: TapWebhookEvent;
    try {
      event = tapPayments.parseWebhookEvent(rawBody, signature);
    } catch (error) {
      logger.error(
        "[POST /api/payments/tap/webhook] Invalid webhook signature or payload",
        {
          correlationId,
          error: error instanceof Error ? error.message : String(error),
        },
      );
      return NextResponse.json(
        { error: "Invalid webhook signature" },
        { status: 401 },
      );
    }

    logger.info("[POST /api/payments/tap/webhook] Processing webhook event", {
      correlationId,
      eventId: event.id,
      eventType: event.type,
      liveMode: event.live_mode,
    });

    await withIdempotency(
      `tap:webhook:${event.id}`,
      async () => {
        await connectToDatabase();

        // Process event based on type
        switch (event.type) {
          case "charge.created":
            await handleChargeCreated(event, correlationId);
            break;

          case "charge.captured":
            await handleChargeCaptured(event, correlationId);
            break;

          case "charge.authorized":
            await handleChargeAuthorized(event, correlationId);
            break;

          case "charge.declined":
          case "charge.failed":
            await handleChargeFailed(event, correlationId);
            break;

          case "refund.created":
            await handleRefundCreated(event, correlationId);
            break;
          case "refund.succeeded":
            await handleRefundSucceeded(event, correlationId);
            break;

          case "refund.failed":
            await handleRefundFailed(event, correlationId);
            break;

          default:
            logger.warn(
              "[POST /api/payments/tap/webhook] Unhandled event type",
              {
                correlationId,
                eventType: event.type,
              },
            );
        }
      },
      TAP_WEBHOOK_IDEMPOTENCY_TTL_MS,
    );

    // Return 200 OK to acknowledge receipt
    return NextResponse.json({ received: true, eventId: event.id });
  } catch (error) {
    logger.error("[POST /api/payments/tap/webhook] Error processing webhook", {
      correlationId,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });

    // Return 500 to signal Tap to retry
    return NextResponse.json(
      {
        error: "Webhook processing failed",
        correlationId,
      },
      { status: 500 },
    );
  }
}

// ============================================================================
// Webhook Event Handlers
// ============================================================================

/**
 * Handle charge.created event
 * Log the charge creation for audit trail
 */
async function handleChargeCreated(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const charge = event.data.object as TapChargeResponse;

  logger.info("[Webhook] Charge created", {
    correlationId,
    chargeId: charge.id,
    amount: charge.amount,
    currency: charge.currency,
    customerEmail: charge.customer.email,
    metadata: charge.metadata,
  });

  await upsertTransactionFromCharge(event.type, charge, correlationId, {
    responseCode: charge.response?.code,
    responseMessage: charge.response?.message,
  });
}

/**
 * Handle charge.captured event
 * Payment was successfully captured - mark as paid
 */
async function handleChargeCaptured(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const charge = event.data.object as TapChargeResponse;

  logger.info("[Webhook] Charge captured - payment successful", {
    correlationId,
    chargeId: charge.id,
    amount: charge.amount,
    currency: charge.currency,
    customerEmail: charge.customer.email,
    orderId: charge.reference?.order,
    metadata: charge.metadata,
  });

  const transaction = await upsertTransactionFromCharge(
    event.type,
    charge,
    correlationId,
    {
      responseCode: charge.response?.code,
      responseMessage: charge.response?.message,
    },
  );
  if (transaction) {
    await ensurePaymentForCharge(transaction, charge, correlationId);
  }
}

/**
 * Handle charge.authorized event
 * Payment was authorized but not captured yet
 * (typically used for pre-authorization flows)
 */
async function handleChargeAuthorized(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const charge = event.data.object as TapChargeResponse;

  logger.info("[Webhook] Charge authorized - awaiting capture", {
    correlationId,
    chargeId: charge.id,
    amount: charge.amount,
    customerEmail: charge.customer.email,
  });

  await upsertTransactionFromCharge(event.type, charge, correlationId, {
    responseCode: charge.response?.code,
    responseMessage: charge.response?.message,
  });
}

/**
 * Handle charge.declined or charge.failed events
 * Payment was declined or failed
 */
async function handleChargeFailed(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const charge = event.data.object as TapChargeResponse;

  logger.warn("[Webhook] Charge failed or declined", {
    correlationId,
    chargeId: charge.id,
    status: charge.status,
    amount: charge.amount,
    customerEmail: charge.customer.email,
    responseCode: charge.response?.code,
    responseMessage: charge.response?.message,
  });

  const transaction = await upsertTransactionFromCharge(
    event.type,
    charge,
    correlationId,
    {
      responseCode: charge.response?.code,
      responseMessage: charge.response?.message,
    },
  );
  if (transaction) {
    await markInvoicePaymentStatus(
      transaction,
      charge,
      "FAILED",
      charge.response?.message,
    );
  }
}

/**
 * Handle refund.created or refund.succeeded events
 * Refund was successfully processed
 */
async function handleRefundSucceeded(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const refund = event.data.object as TapRefundResponse;

  logger.info("[Webhook] Refund succeeded", {
    correlationId,
    refundId: refund.id,
    chargeId: refund.charge,
    amount: refund.amount,
    currency: refund.currency,
    reason: refund.reason,
  });

  await updateRefundRecord(refund, "SUCCEEDED", correlationId);
}

async function handleRefundCreated(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const refund = event.data.object as TapRefundResponse;

  logger.info("[Webhook] Refund created", {
    correlationId,
    refundId: refund.id,
    chargeId: refund.charge,
    amount: refund.amount,
  });

  await updateRefundRecord(refund, "PENDING", correlationId);
}

/**
 * Handle refund.failed event
 * Refund failed to process
 */
async function handleRefundFailed(
  event: TapWebhookEvent,
  correlationId: string,
) {
  const refund = event.data.object as TapRefundResponse;

  logger.error("[Webhook] Refund failed", {
    correlationId,
    refundId: refund.id,
    chargeId: refund.charge,
    amount: refund.amount,
    responseCode: refund.response?.code,
    responseMessage: refund.response?.message,
  });

  await updateRefundRecord(refund, "FAILED", correlationId);
}

/**
 * GET /api/payments/tap/webhook
 *
 * Webhook configuration endpoint (for testing/debugging)
 * Returns webhook URL that should be configured in Tap dashboard
 */
export async function GET(req: NextRequest) {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || req.nextUrl.origin;
  const webhookUrl = `${baseUrl}/api/payments/tap/webhook`;

  return NextResponse.json({
    webhookUrl,
    instructions:
      "Configure this URL in your Tap dashboard under Webhooks settings",
    events: [
      "charge.created",
      "charge.captured",
      "charge.authorized",
      "charge.declined",
      "charge.failed",
      "refund.created",
      "refund.succeeded",
      "refund.failed",
    ],
  });
}

// ============================================================================
// Persistence Helpers
// ============================================================================

async function upsertTransactionFromCharge(
  eventType: string,
  charge: TapChargeResponse,
  correlationId: string,
  payload: Record<string, unknown>,
): Promise<TapTransactionDoc | null> {
  let transaction = await TapTransaction.findOne({ chargeId: charge.id });

  if (!transaction) {
    const orgId = extractOrgId(charge.metadata);
    if (!orgId) {
      logger.error("[Webhook] Missing organizationId metadata on Tap charge", {
        correlationId,
        chargeId: charge.id,
      });
      return null;
    }

    transaction = new TapTransaction({
      orgId,
      userId:
        typeof charge.metadata?.userId === "string"
          ? charge.metadata?.userId
          : undefined,
      chargeId: charge.id,
      orderId: charge.reference?.order,
      correlationId,
      status: charge.status,
      currency: charge.currency || "SAR",
      amountHalalas: charge.amount,
      amountSAR: tapPayments.halalasToSAR(charge.amount || 0),
      paymentContext: transactionContextFromCharge(charge),
      metadata: {},
      tapMetadata: charge.metadata,
      rawCharge: charge,
      events: [],
    });
  }

  transaction.status = charge.status;
  transaction.currency = charge.currency || transaction.currency;
  transaction.amountHalalas = charge.amount || transaction.amountHalalas;
  transaction.amountSAR = tapPayments.halalasToSAR(
    transaction.amountHalalas || 0,
  );
  transaction.orderId = transaction.orderId || charge.reference?.order;
  transaction.tapMetadata = charge.metadata;
  transaction.rawCharge = charge;
  transaction.lastEventAt = new Date();
  transaction.redirectUrl = charge.transaction?.url || transaction.redirectUrl;
  if (charge.transaction?.expiry?.period) {
    transaction.expiresAt = new Date(
      Date.now() + (charge.transaction.expiry.period ?? 0) * 60000,
    );
  }

  transaction.events = transaction.events || [];
  const events = transaction.events as unknown as TransactionEvent[];
  events.push({
    type: eventType,
    status: charge.status,
    at: new Date(),
    payload,
  });
  if (events.length > 25) {
    transaction.events = events.slice(
      events.length - 25,
    ) as typeof transaction.events;
  }

  await transaction.save();
  return transaction;
}

async function ensurePaymentForCharge(
  transaction: TapTransactionDoc,
  charge: TapChargeResponse,
  correlationId: string,
) {
  if (transaction.paymentId) {
    return;
  }

  const amountSAR = tapPayments.halalasToSAR(
    charge.amount || transaction.amountHalalas || 0,
  );
  const partyName =
    transaction.paymentContext?.partyName ||
    `${charge.customer?.first_name || ""} ${charge.customer?.last_name || ""}`.trim() ||
    charge.customer?.email ||
    "Customer";
  const partyType = transaction.paymentContext?.partyType || "CUSTOMER";

  const paymentPayload: Record<string, unknown> = {
    orgId: transaction.orgId,
    paymentDate: new Date(),
    paymentType: "RECEIVED",
    paymentMethod: "ONLINE",
    amount: amountSAR,
    currency: charge.currency || "SAR",
    status: "POSTED",
    partyType,
    partyName,
    referenceNumber: charge.id,
    notes: transaction.paymentContext?.notes,
    receiptUrl: charge.transaction?.url,
    cardDetails: {
      transactionId: charge.id,
      authorizationCode: charge.response?.code,
    },
    createdBy: transaction.userId,
  };

  if (
    transaction.paymentContext?.partyId &&
    Types.ObjectId.isValid(transaction.paymentContext.partyId)
  ) {
    paymentPayload.partyId = new Types.ObjectId(
      transaction.paymentContext.partyId,
    );
  }

  const payment = await Payment.create(
    paymentPayload as Record<string, unknown>,
  );
  transaction.paymentId = payment._id;
  await transaction.save();

  await allocateInvoicePayment(
    transaction,
    payment,
    charge,
    amountSAR,
    correlationId,
  );
}

async function allocateInvoicePayment(
  transaction: TapTransactionDoc,
  payment: typeof Payment.prototype,
  charge: TapChargeResponse,
  amountSar: number,
  correlationId: string,
) {
  if (!transaction.invoiceId) {
    return;
  }

  // SECURITY: Org-scoped filter prevents cross-tenant invoice access
  const orgId = transaction.orgId?.toString();
  if (!orgId) {
    logger.warn("[Webhook] No orgId on TapTransaction, skipping invoice allocation", {
      correlationId,
      invoiceId: transaction.invoiceId?.toString(),
    });
    return;
  }
  const orgScopedInvoiceFilter = {
    _id: transaction.invoiceId,
    $or: [{ orgId }, { org_id: orgId }],
  };
  const invoice = await Invoice.findOne(orgScopedInvoiceFilter);
  if (!invoice) {
    logger.warn("[Webhook] Invoice not found for Tap payment allocation (org-scoped)", {
      correlationId,
      invoiceId: transaction.invoiceId?.toString(),
      chargeId: charge.id,
      orgId,
    });
    return;
  }

  try {
    await payment.allocateToInvoice(
      transaction.invoiceId,
      invoice.number || transaction.invoiceId.toString(),
      amountSar,
    );
    await payment.save();
  } catch (allocationError) {
    logger.warn("[Webhook] Failed to allocate Tap payment to invoice", {
      correlationId,
      invoiceId: invoice._id.toString(),
      error:
        allocationError instanceof Error
          ? allocationError.message
          : allocationError,
    });
  }

  invoice.payments = invoice.payments || [];
  const paymentsTyped = invoice.payments as unknown as InvoicePayment[];
  const existing = paymentsTyped.find((p) => p.transactionId === charge.id);
  if (existing) {
    existing.status = "COMPLETED";
    existing.notes = "Paid via Tap";
  } else {
    invoice.payments.push({
      date: new Date(),
      amount: amountSar,
      method: "TAP_PAYMENTS",
      reference: charge.id,
      status: "COMPLETED",
      transactionId: charge.id,
      notes: "Paid via Tap",
    });
  }
  invoice.status = "PAID";
  invoice.history = invoice.history || [];
  invoice.history.push({
    action: "PAID",
    performedBy: transaction.userId || "tap-webhook",
    performedAt: new Date(),
    details: "Payment captured via Tap webhook",
    ipAddress: "tap-webhook",
    userAgent: "tap-webhook",
  });
  invoice.updatedBy = transaction.userId || invoice.updatedBy;
  await invoice.save();
}

async function markInvoicePaymentStatus(
  transaction: TapTransactionDoc,
  charge: TapChargeResponse,
  status: string,
  message?: string,
) {
  if (!transaction.invoiceId) {
    return;
  }
  // SECURITY: Org-scoped filter prevents cross-tenant invoice access
  const orgId = transaction.orgId?.toString();
  if (!orgId) {
    return;
  }
  const orgScopedInvoiceFilter = {
    _id: transaction.invoiceId,
    $or: [{ orgId }, { org_id: orgId }],
  };
  const invoice = await Invoice.findOne(orgScopedInvoiceFilter);
  if (!invoice) {
    return;
  }

  invoice.payments = invoice.payments || [];
  const amount = tapPayments.halalasToSAR(
    charge.amount || transaction.amountHalalas || 0,
  );
  const paymentsTyped = invoice.payments as unknown as InvoicePayment[];
  const existing = paymentsTyped.find((p) => p.transactionId === charge.id);
  if (existing) {
    existing.status = status;
    existing.notes = message;
  } else {
    invoice.payments.push({
      date: new Date(),
      amount,
      method: "TAP_PAYMENTS",
      reference: charge.id,
      status,
      transactionId: charge.id,
      notes: message,
    });
  }
  await invoice.save();
}

async function updateRefundRecord(
  refund: TapRefundResponse,
  status: "PENDING" | "SUCCEEDED" | "FAILED",
  correlationId: string,
) {
  const transaction = await TapTransaction.findOne({ chargeId: refund.charge });
  if (!transaction) {
    logger.warn("[Webhook] Refund received for unknown Tap transaction", {
      correlationId,
      refundId: refund.id,
      chargeId: refund.charge,
    });
    return;
  }

  transaction.refunds = transaction.refunds || [];
  const existingRefund = transaction.refunds.find(
    (r) => r.refundId === refund.id,
  );
  const amountSar = tapPayments.halalasToSAR(refund.amount || 0);
  if (existingRefund) {
    existingRefund.status = status;
    existingRefund.reason = refund.reason;
    existingRefund.processedAt = new Date();
  } else {
    transaction.refunds.push({
      refundId: refund.id,
      status,
      amountHalalas: refund.amount,
      amountSAR: amountSar,
      currency: refund.currency,
      reason: refund.reason,
      processedAt: new Date(),
    });
  }
  transaction.events = transaction.events || [];
  const eventsTyped = transaction.events as unknown as TransactionEvent[];
  eventsTyped.push({
    type:
      status === "SUCCEEDED"
        ? "refund.succeeded"
        : status === "FAILED"
          ? "refund.failed"
          : "refund.created",
    status,
    at: new Date(),
    payload: {
      refundId: refund.id,
      responseCode: refund.response?.code,
      responseMessage: refund.response?.message,
    },
  });
  if (eventsTyped.length > 25) {
    transaction.events = eventsTyped.slice(
      eventsTyped.length - 25,
    ) as unknown as typeof transaction.events;
  }
  await transaction.save();

  if (transaction.paymentId) {
    const payment = await Payment.findById(transaction.paymentId);
    if (payment) {
      if (status === "SUCCEEDED") {
        payment.status = "REFUNDED";
        payment.isRefund = true;
      }
      if (status === "FAILED" && payment.status === "REFUNDED") {
        payment.status = "POSTED";
      }
      payment.refundReason = refund.reason;
      await payment.save();
    }
  }

  if (transaction.invoiceId) {
    // SECURITY: Org-scoped filter prevents cross-tenant invoice access
    const orgId = transaction.orgId?.toString();
    if (orgId) {
      const orgScopedInvoiceFilter = {
        _id: transaction.invoiceId,
        $or: [{ orgId }, { org_id: orgId }],
      };
      const invoice = await Invoice.findOne(orgScopedInvoiceFilter);
      if (invoice) {
        const paymentsTyped = invoice.payments as unknown as
          | InvoicePayment[]
          | undefined;
        const entry = paymentsTyped?.find(
          (p) => p.transactionId === refund.charge,
        );
        if (entry) {
          entry.status = status === "SUCCEEDED" ? "REFUNDED" : status;
          entry.notes = refund.reason || entry.notes;
        }
        await invoice.save();
      }
    }
  }
}

function extractOrgId(
  metadata?: Record<string, unknown>,
): Types.ObjectId | null {
  const orgValue = metadata?.organizationId || metadata?.orgId;
  if (typeof orgValue === "string" && Types.ObjectId.isValid(orgValue)) {
    return new Types.ObjectId(orgValue);
  }
  if (orgValue instanceof Types.ObjectId) {
    return orgValue;
  }
  return null;
}

function transactionContextFromCharge(charge: TapChargeResponse) {
  return {
    partyType: "CUSTOMER",
    partyName:
      `${charge.customer?.first_name || ""} ${charge.customer?.last_name || ""}`.trim() ||
      charge.customer?.email,
  };
}

]]>
</file>

<file path="app/api/paytabs/callback/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { dbConnect } from "@/db/mongoose";
import {
  finalizePayTabsTransaction,
  normalizePayTabsPayload,
} from "@/lib/finance/paytabs-subscription";
import { validateCallback } from "@/lib/paytabs";
import {
  buildPaytabsIdempotencyKey,
  enforcePaytabsPayloadSize,
  extractPaytabsSignature,
  parsePaytabsJsonPayload,
  PaytabsCallbackValidationError,
  PAYTABS_CALLBACK_IDEMPOTENCY_TTL_MS,
  PAYTABS_CALLBACK_RATE_LIMIT,
} from "@/lib/payments/paytabs-callback.contract";
import { logger } from "@/lib/logger";
import { withIdempotency } from "@/server/security/idempotency";
import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError, handleApiError } from "@/server/utils/errorResponses";
import { createSecureResponse, getClientIP } from "@/server/security/headers";
/**
 * @openapi
 * /api/paytabs/callback:
 *   get:
 *     summary: paytabs/callback operations
 *     tags: [paytabs]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function POST(req: NextRequest) {
  // Rate limiting
  const clientIp = getClientIP(req);
  const rl = await smartRateLimit(
    `paytabs:subscription:${clientIp}`,
    PAYTABS_CALLBACK_RATE_LIMIT.requests,
    PAYTABS_CALLBACK_RATE_LIMIT.windowMs,
  );
  if (!rl.allowed) {
    return rateLimitError();
  }

  const rawBody = await req.text();
  try {
    enforcePaytabsPayloadSize(rawBody);
  } catch (error) {
    if (error instanceof PaytabsCallbackValidationError) {
      return createSecureResponse({ error: error.message }, 413, req);
    }
    throw error;
  }

  try {
    const payload = parsePaytabsJsonPayload(rawBody);

    const signature = extractPaytabsSignature(req, payload);
    if (!signature) {
      logger.error("PayTabs callback rejected: Missing signature");
      return createSecureResponse(
        { error: "Payment verification failed: Missing signature" },
        400,
        req,
      );
    }

    // Validate the signature using HMAC-SHA256
    const isValid = validateCallback(payload, signature);
    if (!isValid) {
      logger.error("PayTabs callback rejected: Invalid signature", {
        cart_id: payload.cart_id,
        tran_ref: payload.tran_ref,
        timestamp: new Date().toISOString(),
      });
      return createSecureResponse(
        { error: "Payment verification failed: Invalid signature" },
        403,
        req,
      );
    }

    await dbConnect();

    let normalized;
    try {
      normalized = normalizePayTabsPayload(payload);
    } catch (error) {
      if (error instanceof PaytabsCallbackValidationError) {
        logger.error("PayTabs callback rejected: Invalid payload shape", {
          message: error.message,
        });
        return createSecureResponse({ error: error.message }, 400, req);
      }
      throw error;
    }

    try {
      const result = await withIdempotency(
        buildPaytabsIdempotencyKey(normalized, { route: "subscription" }),
        () => finalizePayTabsTransaction(normalized),
        PAYTABS_CALLBACK_IDEMPOTENCY_TTL_MS,
      );
      return createSecureResponse(result, 200, req);
    } catch (error: unknown) {
      return handleApiError(error);
    }
  } catch (error) {
    if (
      error instanceof PaytabsCallbackValidationError ||
      error instanceof SyntaxError
    ) {
      logger.error("PayTabs callback rejected: Invalid JSON payload");
      const msg =
        error instanceof PaytabsCallbackValidationError
          ? error.message
          : "Invalid JSON payload";
      const errorMessage = `Payment verification failed: ${msg}`;
      return createSecureResponse(
        { error: errorMessage },
        /exceeds limit/.test(msg) ? 413 : 400,
        req,
      );
    }
    throw error;
  }
}

]]>
</file>

<file path="app/api/paytabs/return/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";

import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
import { getClientIP } from "@/server/security/headers";
/**
 * @openapi
 * /api/paytabs/return:
 *   get:
 *     summary: paytabs/return operations
 *     tags: [paytabs]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function GET(req: NextRequest) {
  // Rate limiting
  const clientIp = getClientIP(req);
  const rl = await smartRateLimit(`${new URL(req.url).pathname}:${clientIp}`, 60, 60_000);
  if (!rl.allowed) {
    return rateLimitError();
  }

  const url = new URL(req.url);
  const cartId =
    url.searchParams.get("cart_id") || url.searchParams.get("cartId");
  const status =
    url.searchParams.get("respStatus") || url.searchParams.get("status");

  const base = process.env.APP_URL || `${url.protocol}//${url.host}`;
  const redirectUrl = new URL("/billing/complete", base);
  if (cartId) redirectUrl.searchParams.set("cart_id", cartId);
  if (status) redirectUrl.searchParams.set("status", status);

  return NextResponse.redirect(redirectUrl.toString());
}

]]>
</file>

<file path="app/api/performance/metrics/route.ts">
<![CDATA[
/**
 * Performance Metrics API Endpoint
 *
 * GET /api/performance/metrics
 *
 * Returns current performance statistics and recent metrics
 * 
 * SECURITY: Restricted to SUPER_ADMIN only - exposes internal system metrics
 */

import { NextRequest, NextResponse } from "next/server";
import {
  getPerformanceStats,
  getRecentMetrics,
  getExceededMetrics,
} from "@/lib/performance";
import { getSessionUser, UnauthorizedError } from "@/server/middleware/withAuthRbac";

export async function GET(req: NextRequest) {
  // SEC-001: Restrict to SUPER_ADMIN - performance metrics expose internal system info
  try {
    const session = await getSessionUser(req);
    if (session.role !== "SUPER_ADMIN") {
      return NextResponse.json(
        { error: "Forbidden - SUPER_ADMIN access required" },
        { status: 403 }
      );
    }
  } catch (error) {
    if (error instanceof UnauthorizedError) {
      return NextResponse.json(
        { error: "Authentication required" },
        { status: 401 }
      );
    }
    throw error;
  }

  try {
    const { searchParams } = new URL(req.url);
    const type = searchParams.get("type") || "stats";
    const limit = Math.min(
      parseInt(searchParams.get("limit") || "100", 10),
      1000,
    );

    switch (type) {
      case "stats":
        return NextResponse.json({
          success: true,
          data: getPerformanceStats(),
        });

      case "recent":
        return NextResponse.json({
          success: true,
          data: getRecentMetrics(limit),
        });

      case "exceeded":
        return NextResponse.json({
          success: true,
          data: getExceededMetrics(),
        });

      default:
        return NextResponse.json(
          {
            success: false,
            error: "Invalid type parameter. Use: stats, recent, or exceeded",
          },
          { status: 400 },
        );
    }
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
      },
      { status: 500 },
    );
  }
}

export const runtime = "nodejs";

]]>
</file>

<file path="app/api/pm/generate-wos/route.ts">
<![CDATA[
import crypto from "crypto";
import { NextRequest, NextResponse } from "next/server";
import { FMPMPlan } from "@/server/models/FMPMPlan";
import { Config } from "@/lib/config/constants";
import { createSecureResponse } from "@/server/security/headers";
import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
import { getClientIP } from "@/server/security/headers";
import { verifySecretHeader } from "@/lib/security/verify-secret-header";

import { logger } from "@/lib/logger";

interface PMPlanWithMethods extends PMPlanDocument {
  recordGeneration?: (
    id: unknown,
    woNumber: string,
    status: string,
  ) => Promise<unknown>;
}

interface PMPlanDocument {
  _id: unknown;
  planNumber?: string;
  title?: string;
  propertyId?: string;
  nextScheduledDate: Date;
  woLeadTimeDays: number;
  lastGeneratedDate?: Date;
  woTitle?: string;
  estimatedCost?: number;
  [key: string]: unknown;
}
/**
 * POST /api/pm/generate-wos
 * Auto-generate work orders from PM plans that are due
 *
 * This endpoint should be called by a cron job (e.g., daily at midnight)
 * It checks all ACTIVE PM plans and generates WOs for those due
 * 
 * SECURITY: Protected by CRON_SECRET header - not accessible to regular users
 * NOTE: System-wide query across all tenants is intentional for cron job
 * Each generated WO inherits orgId from its parent PM plan
 */
export async function POST(req: NextRequest) {
  // Rate limiting
  const clientIp = getClientIP(req);
  const rl = await smartRateLimit(`${new URL(req.url).pathname}:${clientIp}`, 10, 60_000);
  if (!rl.allowed) {
    return rateLimitError();
  }

  //  CRON AUTH: Only allow calls with valid cron secret
  if (!verifySecretHeader(req, "x-cron-secret", Config.security.cronSecret)) {
    return createSecureResponse({ error: "Unauthorized" }, 401, req);
  }

  try {
    // NOTE: System-wide query is intentional - cron job processes ALL tenants
    // Each PM plan has its own orgId which is inherited by generated WOs
    // This is secured by CRON_SECRET authentication above
    const plans = await FMPMPlan.find({
      status: "ACTIVE",
      nextScheduledDate: { $exists: true },
    }).lean();

    const results = {
      checked: plans.length,
      generated: 0,
      skipped: 0,
      failed: 0,
      workOrders: [] as Array<{
        planId: string;
        planNumber: string;
        woNumber: string;
        scheduledFor: Date;
      }>,
    };

    for (const plan of plans) {
      // Check if plan should generate WO now (considering lead time)
      const shouldGenerate = (
        plan as unknown as { shouldGenerateNow?: () => boolean }
      ).shouldGenerateNow?.();
      if (!shouldGenerate) {
        results.skipped++;
        continue;
      }

      try {
        // In a real implementation, this would call WorkOrder.create()
        // For now, we simulate WO creation and just record it
        // SECURITY: Use crypto-random UUID instead of predictable Date.now() + Math.random()
        const woNumber = `WO-PM-${crypto.randomUUID()}`;
        const workOrderData = {
          title: plan.woTitle,
          description:
            plan.woDescription || `Preventive maintenance: ${plan.title}`,
          category: plan.woCategory,
          priority: plan.woPriority,
          propertyId: plan.propertyId,
          unitId: plan.unitId,
          type: "MAINTENANCE",
          status: "SCHEDULED",
          scheduledDate: plan.nextScheduledDate,
          pmPlanId: plan._id,
          pmPlanNumber: plan.planNumber,
          estimatedCost: plan.estimatedCost,
          budgetCode: plan.budgetCode,
          checklist: plan.checklist,
        };

        // Log the WO that would be created
        logger.info(
          `[PM] Generated WO: ${woNumber} from plan ${plan.planNumber}`,
        );
        logger.info(`[PM] WO Data:`, { workOrderData });

        // Record generation in plan
        const planWithMethods = plan as unknown as PMPlanWithMethods;
        if (planWithMethods.recordGeneration) {
          await planWithMethods.recordGeneration(
            plan._id, // In real impl, this would be the actual WorkOrder._id
            woNumber,
            "SUCCESS",
          );
        }

        results.generated++;
        results.workOrders.push({
          planId: plan._id.toString(),
          planNumber: plan.planNumber,
          woNumber,
          scheduledFor: plan.nextScheduledDate,
        });
      } catch (error) {
        logger.error(
          `[PM] Failed to generate WO for plan ${plan.planNumber}`,
          error,
        );
        results.failed++;
      }
    }

    logger.info(`[PM] Generation complete:`, { results });

    return NextResponse.json({
      success: true,
      data: results,
    });
  } catch (error) {
    logger.error(`[API] PM generation failed:`, error);
    return NextResponse.json(
      { success: false, error: "PM generation failed" },
      { status: 500 },
    );
  }
}

/**
 * GET /api/pm/generate-wos
 * Preview which PM plans would generate WOs if run now
 * 
 * SECURITY: Protected by CRON_SECRET header - not accessible to regular users
 * NOTE: System-wide query across all tenants is intentional for cron preview
 */
export async function GET(req: NextRequest) {
  // Rate limiting
  const clientIp = getClientIP(req);
  const rl = await smartRateLimit(`${new URL(req.url).pathname}:${clientIp}`, 30, 60_000);
  if (!rl.allowed) {
    return rateLimitError();
  }

  //  CRON AUTH: Only allow calls with valid cron secret
  if (!verifySecretHeader(req, "x-cron-secret", Config.security.cronSecret)) {
    return createSecureResponse({ error: "Unauthorized" }, 401, req);
  }

  try {
    // NOTE: System-wide query is intentional - cron preview for ALL tenants
    // Secured by CRON_SECRET authentication above
    const plans = await FMPMPlan.find({
      status: "ACTIVE",
      nextScheduledDate: { $exists: true },
    }).lean();

    const plansTyped = plans as unknown as PMPlanDocument[];
    const preview = plansTyped
      .filter((plan) => {
        // Manually check shouldGenerateNow logic
        const now = new Date();
        const leadTime = plan.woLeadTimeDays * 24 * 60 * 60 * 1000;
        const generateByDate = new Date(
          plan.nextScheduledDate.getTime() - leadTime,
        );

        return (
          now >= generateByDate &&
          (!plan.lastGeneratedDate || plan.lastGeneratedDate < generateByDate)
        );
      })
      .map((plan) => ({
        planId: plan._id,
        planNumber: plan.planNumber,
        title: plan.title,
        propertyId: plan.propertyId,
        nextScheduledDate: plan.nextScheduledDate,
        woLeadTimeDays: plan.woLeadTimeDays,
        woTitle: plan.woTitle,
        estimatedCost: plan.estimatedCost,
      }));

    return NextResponse.json({
      success: true,
      data: {
        total: plans.length,
        readyToGenerate: preview.length,
        plans: preview,
      },
    });
  } catch (error) {
    logger.error(`[API] PM preview failed:`, error);
    return NextResponse.json(
      { success: false, error: "PM preview failed" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/pm/plans/[id]/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { logger } from "@/lib/logger";
import { FMPMPlan } from "@/server/models/FMPMPlan";
import { getSessionUser } from "@/server/middleware/withAuthRbac";
import { createSecureResponse } from "@/server/security/headers";
import { UserRole } from "@/types/user";

const PM_ALLOWED_ROLES = [
  UserRole.SUPER_ADMIN,
  UserRole.CORPORATE_ADMIN,
  UserRole.ADMIN,
  UserRole.MANAGER,
  UserRole.FM_MANAGER,
  UserRole.PROPERTY_MANAGER,
  UserRole.TECHNICIAN,
  UserRole.OPERATIONS_MANAGER,
] as const;

/**
 * GET /api/pm/plans/[id]
 * Get single PM plan by ID (tenant-scoped)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  let orgId: string;
  try {
    const user = await getSessionUser(request);
    const isAllowed = PM_ALLOWED_ROLES.some((role) => role === user.role);
    if (!isAllowed) {
      return createSecureResponse({ error: "Forbidden" }, 403, request);
    }
    orgId = user.orgId;
  } catch {
    return createSecureResponse({ error: "Unauthorized" }, 401, request);
  }

  try {
    const { id } = await params;
    //  TENANT-SCOPED: Use findOne with orgId filter instead of findById
    const plan = await FMPMPlan.findOne({ _id: id, orgId });

    if (!plan) {
      return NextResponse.json(
        { success: false, error: "PM plan not found" },
        { status: 404 },
      );
    }

    return NextResponse.json({
      success: true,
      data: plan,
    });
  } catch (error) {
    logger.error(
      "[API] Failed to fetch PM plan:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return NextResponse.json(
      { success: false, error: "Failed to fetch PM plan" },
      { status: 500 },
    );
  }
}

/**
 * PATCH /api/pm/plans/[id]
 * Update PM plan (tenant-scoped)
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  let orgId: string;
  try {
    const user = await getSessionUser(request);
    const isAllowed = PM_ALLOWED_ROLES.some((role) => role === user.role);
    if (!isAllowed) {
      return createSecureResponse({ error: "Forbidden" }, 403, request);
    }
    orgId = user.orgId;
  } catch {
    return createSecureResponse({ error: "Unauthorized" }, 401, request);
  }

  try {
    const { id } = await params;
    const body = await request.json();

    // Whitelist approach: only allow updating specific fields
    const allowedFields = [
      "title",
      "description",
      "category",
      "recurrencePattern",
      "startDate",
      "status",
      "assignedTo",
      "estimatedDuration",
      "instructions",
      "nextScheduledDate",
    ];

    const updateData: Record<string, unknown> = {};
    for (const key of Object.keys(body)) {
      if (allowedFields.includes(key)) {
        updateData[key] = body[key];
      }
    }

    // Validate that at least one field is being updated
    if (Object.keys(updateData).length === 0) {
      return NextResponse.json(
        { success: false, error: "No valid fields to update" },
        { status: 400 },
      );
    }

    //  TENANT-SCOPED: Use findOneAndUpdate with orgId filter
    const plan = await FMPMPlan.findOneAndUpdate(
      { _id: id, orgId },
      { $set: updateData },
      { new: true, runValidators: true },
    );

    if (!plan) {
      return NextResponse.json(
        { success: false, error: "PM plan not found" },
        { status: 404 },
      );
    }

    return NextResponse.json({
      success: true,
      data: plan,
    });
  } catch (error) {
    logger.error(
      "[API] Failed to update PM plan:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return NextResponse.json(
      { success: false, error: "Failed to update PM plan" },
      { status: 500 },
    );
  }
}

/**
 * DELETE /api/pm/plans/[id]
 * Delete PM plan (soft delete - set status to INACTIVE) (tenant-scoped)
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  let orgId: string;
  try {
    const user = await getSessionUser(request);
    const isAllowed = PM_ALLOWED_ROLES.some((role) => role === user.role);
    if (!isAllowed) {
      return createSecureResponse({ error: "Forbidden" }, 403, request);
    }
    orgId = user.orgId;
  } catch {
    return createSecureResponse({ error: "Unauthorized" }, 401, request);
  }

  try {
    const { id } = await params;
    //  TENANT-SCOPED: Use findOneAndUpdate with orgId filter
    const plan = await FMPMPlan.findOneAndUpdate(
      { _id: id, orgId },
      { $set: { status: "INACTIVE" } },
      { new: true },
    );

    if (!plan) {
      return NextResponse.json(
        { success: false, error: "PM plan not found" },
        { status: 404 },
      );
    }

    return NextResponse.json({
      success: true,
      message: "PM plan deactivated",
    });
  } catch (error) {
    logger.error(
      "[API] Failed to delete PM plan:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return NextResponse.json(
      { success: false, error: "Failed to delete PM plan" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/pm/plans/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { logger } from "@/lib/logger";
import { FMPMPlan } from "@/server/models/FMPMPlan";
import { getSessionUser } from "@/server/middleware/withAuthRbac";
import { createSecureResponse } from "@/server/security/headers";

/**
 * GET /api/pm/plans
 * List all PM plans with optional filters (tenant-scoped)
 */
export async function GET(request: NextRequest) {
  let orgId: string;
  try {
    const user = await getSessionUser(request);
    orgId = user.orgId;
  } catch {
    return createSecureResponse({ error: "Unauthorized" }, 401, request);
  }

  try {
    const { searchParams } = new URL(request.url);
    const propertyId = searchParams.get("propertyId");
    const status = searchParams.get("status");
    const category = searchParams.get("category");

    //  TENANT-SCOPED: Always include orgId in query
    const query: Record<string, string> = { orgId };
    if (propertyId) query.propertyId = propertyId;
    if (status) query.status = status;
    if (category) query.category = category;

    const plans = await FMPMPlan.find(query)
      .sort({ nextScheduledDate: 1 })
      .lean();

    return NextResponse.json({
      success: true,
      data: plans,
      count: plans.length,
    });
  } catch (error) {
    logger.error(
      "[API] Failed to fetch PM plans:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return NextResponse.json(
      { success: false, error: "Failed to fetch PM plans" },
      { status: 500 },
    );
  }
}

/**
 * POST /api/pm/plans
 * Create new PM plan (tenant-scoped)
 */
export async function POST(request: NextRequest) {
  let orgId: string;
  try {
    const user = await getSessionUser(request);
    orgId = user.orgId;
  } catch {
    return createSecureResponse({ error: "Unauthorized" }, 401, request);
  }

  try {
    const body = await request.json();

    // Validate required fields
    if (!body.title || !body.propertyId || !body.recurrencePattern) {
      return NextResponse.json(
        { success: false, error: "Missing required fields" },
        { status: 400 },
      );
    }

    // Whitelist editable fields only
    const whitelistedData = {
      title: body.title,
      description: body.description,
      propertyId: body.propertyId,
      category: body.category,
      recurrencePattern: body.recurrencePattern,
      startDate: body.startDate,
      status: body.status || "ACTIVE",
      assignedTo: body.assignedTo,
      estimatedDuration: body.estimatedDuration,
      instructions: body.instructions,
    };

    //  TENANT-SCOPED: Always include orgId when creating
    const plan = await FMPMPlan.create({
      ...whitelistedData,
      orgId, // Enforce tenant scope
      nextScheduledDate: body.startDate || new Date(),
    });

    return NextResponse.json(
      {
        success: true,
        data: plan,
      },
      { status: 201 },
    );
  } catch (error) {
    logger.error(
      "[API] Failed to create PM plan:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return NextResponse.json(
      { success: false, error: "Failed to create PM plan" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/projects/[id]/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { logger } from "@/lib/logger";
import { connectToDatabase } from "@/lib/mongodb-unified";
import { Project } from "@/server/models/Project";
import { z } from "zod";
import { getSessionUser } from "@/server/middleware/withAuthRbac";

import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError, handleApiError } from "@/server/utils/errorResponses";
import { createSecureResponse } from "@/server/security/headers";
import { buildOrgAwareRateLimitKey } from "@/server/security/rateLimitKey";

const updateProjectSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  type: z
    .enum([
      "NEW_CONSTRUCTION",
      "RENOVATION",
      "MAINTENANCE",
      "FIT_OUT",
      "DEMOLITION",
    ])
    .optional(),
  status: z
    .enum([
      "PLANNING",
      "APPROVED",
      "IN_PROGRESS",
      "ON_HOLD",
      "COMPLETED",
      "CANCELLED",
      "CLOSED",
    ])
    .optional(),
  timeline: z
    .object({
      startDate: z.string().optional(),
      endDate: z.string().optional(),
      duration: z.number().optional(),
    })
    .optional(),
  budget: z
    .object({
      total: z.number().optional(),
      allocated: z.number().optional(),
      spent: z.number().optional(),
      remaining: z.number().optional(),
    })
    .optional(),
  progress: z
    .object({
      overall: z.number().min(0).max(100).optional(),
      schedule: z.number().min(0).max(100).optional(),
      quality: z.number().min(0).max(100).optional(),
      cost: z.number().min(0).max(100).optional(),
    })
    .optional(),
  tags: z.array(z.string()).optional(),
});

/**
 * @openapi
 * /api/projects/[id]:
 *   get:
 *     summary: projects/[id] operations
 *     tags: [projects]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function GET(
  req: NextRequest,
  props: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await props.params;
    const user = await getSessionUser(req);
    const rl = await smartRateLimit(buildOrgAwareRateLimitKey(req, user.orgId, user.id), 60, 60_000);
    if (!rl.allowed) {
      return rateLimitError();
    }
    await connectToDatabase();

    const project = await Project.findOne({
      _id: id,
      tenantId: user.tenantId,
    });

    if (!project) {
      return createSecureResponse({ error: "Project not found" }, 404, req);
    }

    return createSecureResponse(project, 200, req);
  } catch (error: unknown) {
    logger.error(
      "GET /api/projects/[id] error:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return handleApiError(error);
  }
}

export async function PATCH(
  req: NextRequest,
  props: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await props.params;
    const user = await getSessionUser(req);
    const rl = await smartRateLimit(buildOrgAwareRateLimitKey(req, user.orgId, user.id), 30, 60_000);
    if (!rl.allowed) {
      return rateLimitError();
    }
    await connectToDatabase();

    const data = updateProjectSchema.parse(await req.json());

    const project = await Project.findOneAndUpdate(
      { _id: id, tenantId: user.tenantId },
      {
        $set: {
          ...data,
          updatedBy: user.id,
          "progress.lastUpdated": new Date(),
        },
      },
      { new: true },
    );

    if (!project) {
      return createSecureResponse({ error: "Project not found" }, 404, req);
    }

    return createSecureResponse(project, 200, req);
  } catch (error: unknown) {
    return handleApiError(error);
  }
}

export async function DELETE(
  req: NextRequest,
  props: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await props.params;
    const user = await getSessionUser(req);
    const rl = await smartRateLimit(buildOrgAwareRateLimitKey(req, user.orgId, user.id), 60, 60_000);
    if (!rl.allowed) {
      return rateLimitError();
    }
    await connectToDatabase();

    const project = await Project.findOneAndUpdate(
      { _id: id, tenantId: user.tenantId },
      { $set: { status: "CANCELLED", updatedBy: user.id } },
      { new: true },
    );

    if (!project) {
      return createSecureResponse({ error: "Project not found" }, 404, req);
    }

    return createSecureResponse({ success: true }, 200, req);
  } catch (error: unknown) {
    return handleApiError(error);
  }
}

]]>
</file>

</batch_content>
