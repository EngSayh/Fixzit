
You are the "Fixzit Memory Builder" for category: "models".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "models",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="server/models/TestingUser.ts">
<![CDATA[
/**
 * Testing User Model
 *
 * Superadmin-managed testing users for production system testing.
 * These are NOT demo users - they are real testing accounts with
 * credentials managed by superadmin.
 *
 * Key differences from demo users:
 * - Created and managed by superadmin via API/UI
 * - Credentials stored encrypted
 * - Full audit trail of access
 * - Can be enabled/disabled on demand
 * - Supports expiry dates
 *
 * @module server/models/TestingUser
 */

import { Schema, model, models, HydratedDocument, Types } from "mongoose";
import { MModel } from "@/types/mongoose-compat";
import { auditPlugin } from "../plugins/auditPlugin";
import bcrypt from "bcryptjs";
import { randomBytes } from "crypto";

// ---------- Enums ----------
export const TestingUserStatus = ["ACTIVE", "DISABLED", "EXPIRED"] as const;
export type TTestingUserStatus = (typeof TestingUserStatus)[number];

export const TestingUserRole = [
  "SUPER_ADMIN",
  "ADMIN",
  "MANAGER",
  "USER",
  "VENDOR",
  "TENANT",
] as const;
export type TTestingUserRole = (typeof TestingUserRole)[number];

// ---------- Interfaces ----------
export interface ITestingUserLoginLog {
  timestamp: Date;
  ip: string;
  userAgent?: string;
  success: boolean;
  failureReason?: string;
}

export interface ITestingUser {
  _id: Types.ObjectId;

  // Identity
  email: string;
  username: string;
  displayName: string;
  role: TTestingUserRole;

  // Credentials (hashed)
  passwordHash: string;
  passwordLastChanged: Date;
  requirePasswordChange: boolean;

  // Status
  status: TTestingUserStatus;
  statusReason?: string;
  statusChangedAt?: Date;
  statusChangedBy?: string;

  // Access control
  expiresAt?: Date;
  allowedIPs?: string[];
  allowedEnvironments?: string[]; // e.g., ["production", "staging"]
  maxSessionsPerDay?: number;

  // Usage tracking
  lastLoginAt?: Date;
  loginCount: number;
  loginHistory: ITestingUserLoginLog[];

  // Organization context
  orgId?: string;
  accessibleOrgIds?: string[];

  // Metadata
  purpose: string; // Why this testing user exists
  createdBy: string;
  notes?: string;

  createdAt: Date;
  updatedAt: Date;
}

// ---------- Schema ----------
const TestingUserLoginLogSchema = new Schema<ITestingUserLoginLog>(
  {
    timestamp: { type: Date, required: true },
    ip: { type: String, required: true },
    userAgent: { type: String },
    success: { type: Boolean, required: true },
    failureReason: { type: String },
  },
  { _id: false }
);

const TestingUserSchema = new Schema<ITestingUser>(
  {
    email: {
      type: String,
      required: true,
      unique: true, // unique implies index
      lowercase: true,
      trim: true,
    },
    username: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
    },
    displayName: { type: String, required: true },
    role: {
      type: String,
      enum: TestingUserRole,
      required: true,
      default: "USER",
    },

    passwordHash: { type: String, required: true },
    passwordLastChanged: { type: Date, required: true },
    requirePasswordChange: { type: Boolean, default: false },

    status: {
      type: String,
      enum: TestingUserStatus,
      required: true,
      default: "ACTIVE",
      // index via compounds { status: 1, expiresAt: 1 }, { orgId: 1, status: 1 }
    },
    statusReason: { type: String },
    statusChangedAt: { type: Date },
    statusChangedBy: { type: String },

    expiresAt: { type: Date }, // index via compound { status: 1, expiresAt: 1 }
    allowedIPs: { type: [String] },
    allowedEnvironments: { type: [String] },
    maxSessionsPerDay: { type: Number },

    lastLoginAt: { type: Date },
    loginCount: { type: Number, default: 0 },
    loginHistory: {
      type: [TestingUserLoginLogSchema],
      default: [],
      // Keep only last 100 entries
      validate: {
        validator: function (v: ITestingUserLoginLog[]) {
          return v.length <= 100;
        },
        message: "Login history limited to 100 entries",
      },
    },

    orgId: { type: String }, // index via compound { orgId: 1, status: 1 }
    accessibleOrgIds: { type: [String] },

    purpose: { type: String, required: true },
    createdBy: { type: String, required: true },
    notes: { type: String },
  },
  {
    timestamps: true,
    collection: "testing_users",
  }
);

// ---------- Indexes ----------
TestingUserSchema.index({ status: 1, expiresAt: 1 });
TestingUserSchema.index({ orgId: 1, status: 1 });

// ---------- Pre-save middleware ----------
TestingUserSchema.pre("save", async function (next) {
  // Check expiry and update status
  if (this.expiresAt && new Date() > this.expiresAt && this.status === "ACTIVE") {
    this.status = "EXPIRED";
    this.statusReason = "Expired automatically";
    this.statusChangedAt = new Date();
  }
  next();
});

// ---------- Instance Methods ----------
TestingUserSchema.methods.verifyPassword = async function (
  password: string
): Promise<boolean> {
  return bcrypt.compare(password, this.passwordHash);
};

TestingUserSchema.methods.setPassword = async function (
  password: string
): Promise<void> {
  this.passwordHash = await bcrypt.hash(password, 12);
  this.passwordLastChanged = new Date();
  this.requirePasswordChange = false;
};

TestingUserSchema.methods.recordLogin = async function (
  ip: string,
  userAgent: string | undefined,
  success: boolean,
  failureReason?: string
): Promise<void> {
  const logEntry: ITestingUserLoginLog = {
    timestamp: new Date(),
    ip,
    userAgent,
    success,
    failureReason,
  };

  // Add to history (limited to 100 entries)
  if (this.loginHistory.length >= 100) {
    this.loginHistory.shift();
  }
  this.loginHistory.push(logEntry);

  if (success) {
    this.lastLoginAt = new Date();
    this.loginCount += 1;
  }

  await this.save();
};

TestingUserSchema.methods.isAccessible = function (
  ip?: string,
  environment?: string
): { allowed: boolean; reason?: string } {
  // Check status
  if (this.status !== "ACTIVE") {
    return { allowed: false, reason: `Account is ${this.status}` };
  }

  // Check expiry
  if (this.expiresAt && new Date() > this.expiresAt) {
    return { allowed: false, reason: "Account has expired" };
  }

  // Check IP allowlist
  if (this.allowedIPs?.length && ip && !this.allowedIPs.includes(ip)) {
    return { allowed: false, reason: "IP not in allowlist" };
  }

  // Check environment
  if (
    this.allowedEnvironments?.length &&
    environment &&
    !this.allowedEnvironments.includes(environment)
  ) {
    return { allowed: false, reason: "Environment not allowed" };
  }

  return { allowed: true };
};

// ---------- Statics ----------
TestingUserSchema.statics.createTestingUser = async function (
  data: {
    email: string;
    username: string;
    displayName: string;
    role: TTestingUserRole;
    password: string;
    purpose: string;
    createdBy: string;
    orgId?: string;
    expiresAt?: Date;
    allowedIPs?: string[];
    allowedEnvironments?: string[];
    notes?: string;
  }
): Promise<ITestingUser> {
  const passwordHash = await bcrypt.hash(data.password, 12);

  return this.create({
    email: data.email.toLowerCase(),
    username: data.username.toLowerCase(),
    displayName: data.displayName,
    role: data.role,
    passwordHash,
    passwordLastChanged: new Date(),
    status: "ACTIVE",
    purpose: data.purpose,
    createdBy: data.createdBy,
    orgId: data.orgId,
    expiresAt: data.expiresAt,
    allowedIPs: data.allowedIPs,
    allowedEnvironments: data.allowedEnvironments,
    notes: data.notes,
  });
};

TestingUserSchema.statics.findByEmail = async function (
  email: string
): Promise<ITestingUser | null> {
  return this.findOne({ email: email.toLowerCase() }).lean();
};

TestingUserSchema.statics.findActive = async function (
  orgId?: string
): Promise<ITestingUser[]> {
  const query: Record<string, unknown> = { status: "ACTIVE" };
  if (orgId) query.orgId = orgId;
  return this.find(query).sort({ createdAt: -1 }).lean();
};

TestingUserSchema.statics.expireOldUsers = async function (): Promise<number> {
  const result = await this.updateMany(
    {
      status: "ACTIVE",
      expiresAt: { $lt: new Date() },
    },
    {
      $set: {
        status: "EXPIRED",
        statusReason: "Expired automatically",
        statusChangedAt: new Date(),
      },
    }
  );
  return result.modifiedCount;
};

TestingUserSchema.statics.generateSecurePassword = function (): string {
  // Generate a secure random password
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789!@#$%^&*";
  const bytes = randomBytes(16);
  let password = "";
  for (let i = 0; i < 16; i++) {
    password += chars[bytes[i] % chars.length];
  }
  return password;
};

// ---------- Plugins ----------
TestingUserSchema.plugin(auditPlugin);

// ---------- Type Extensions ----------
interface TestingUserMethods {
  verifyPassword(password: string): Promise<boolean>;
  setPassword(password: string): Promise<void>;
  recordLogin(
    ip: string,
    userAgent: string | undefined,
    success: boolean,
    failureReason?: string
  ): Promise<void>;
  isAccessible(
    ip?: string,
    environment?: string
  ): { allowed: boolean; reason?: string };
}

interface TestingUserStatics {
  createTestingUser(data: {
    email: string;
    username: string;
    displayName: string;
    role: TTestingUserRole;
    password: string;
    purpose: string;
    createdBy: string;
    orgId?: string;
    expiresAt?: Date;
    allowedIPs?: string[];
    allowedEnvironments?: string[];
    notes?: string;
  }): Promise<ITestingUser>;
  findByEmail(email: string): Promise<ITestingUser | null>;
  findActive(orgId?: string): Promise<ITestingUser[]>;
  expireOldUsers(): Promise<number>;
  generateSecurePassword(): string;
}

type TestingUserModel = MModel<ITestingUser> & TestingUserStatics;
export type TestingUserDocument = HydratedDocument<ITestingUser>;

// ---------- Export ----------
export const TestingUser = (models.TestingUser ||
  model<ITestingUser>("TestingUser", TestingUserSchema)) as unknown as TestingUserModel;

]]>
</file>

<file path="server/models/User.ts">
<![CDATA[
import { Schema, Model, models, InferSchemaType } from "mongoose";
import { getModel } from "@/types/mongoose-compat";
import { tenantIsolationPlugin } from "../plugins/tenantIsolation";
import { auditPlugin } from "../plugins/auditPlugin";
import { UserRole, UserStatus } from "@/types/user";
import { encryptField, decryptField, isEncrypted } from "@/lib/security/encryption";
import { logger } from "@/lib/logger";

// Re-export for backward compatibility
export { UserRole };

const UserSchema = new Schema(
  {
    // Multi-tenancy key - will be added by tenantIsolationPlugin
    // orgId: { type: String, required: true, index: true },

    // Basic Information
    code: { type: String, required: true },
    username: { type: String, required: true },
    email: { type: String, required: true },
    password: { type: String, required: true }, // Hashed password
    phone: String,
    mobile: String,
    emailVerifiedAt: { type: Date },
    employeeId: String, // Top-level for unique compound index {orgId, employeeId}

    // Personal Information
    personal: {
      firstName: String,
      lastName: String,
      middleName: String,
      nationalId: String, // National ID number
      passport: String,
      dateOfBirth: Date,
      gender: String,
      nationality: String,
      maritalStatus: String,
      address: {
        street: String,
        city: String,
        region: String,
        postalCode: String,
        country: { type: String, default: "SA" },
      },
    },

    // Professional Information
    professional: {
      role: { type: String, enum: UserRole, required: true },
      subRole: { 
        type: String, 
        enum: ["FINANCE_OFFICER", "HR_OFFICER", "SUPPORT_AGENT", "OPERATIONS_MANAGER"],
        description: "STRICT v4.1 Team Member specialization (Finance/HR/Support/Operations)",
      },
      title: String,
      department: String,
      manager: String, // user ID of manager
      reportsTo: String, // user ID of supervisor
      skills: [
        {
          category: String, // ELECTRICAL, PLUMBING, HVAC, etc.
          skill: String, // Wiring, Installation, Repair, etc.
          level: {
            type: String,
            enum: ["BEGINNER", "INTERMEDIATE", "ADVANCED", "EXPERT"],
          },
          certified: Boolean,
          certification: String,
          expiry: Date,
          experience: Number, // years
        },
      ],
      certifications: [
        {
          name: String,
          issuer: String,
          issued: Date,
          expires: Date,
          status: String, // VALID, EXPIRED, PENDING
        },
      ],
      licenses: [
        {
          type: String, // Driver's License, Trade License, etc.
          number: String,
          issued: Date,
          expires: Date,
          status: String,
        },
      ],
      // STRICT v4.1: Assigned properties for Property Managers (data scope)
      assignedProperties: [{ type: Schema.Types.ObjectId, ref: "Property" }],
    },

    // Workload & Capacity
    workload: {
      maxAssignments: Number,
      currentAssignments: Number,
      available: Boolean,
      location: {
        city: String,
        region: String,
        radius: Number, // km service area
      },
      workingHours: {
        start: String, // HH:MM
        end: String, // HH:MM
        days: [String], // ["monday", "tuesday", etc.]
        timezone: { type: String, default: "Asia/Riyadh" },
      },
      availability: [
        {
          date: Date,
          start: String,
          end: String,
          status: String, // AVAILABLE, BUSY, OFF
        },
      ],
    },

    // Performance Metrics
    performance: {
      rating: { type: Number, min: 0, max: 5 },
      completedJobs: Number,
      ongoingJobs: Number,
      successRate: Number, // percentage
      averageResponseTime: Number, // hours
      averageResolutionTime: Number, // hours
      customerSatisfaction: Number, // percentage
      reviews: [
        {
          workOrderId: String,
          rating: Number,
          comment: String,
          date: Date,
          reviewer: String,
        },
      ],
    },

    // Security & Access
    security: {
      accessLevel: { type: String, enum: ["READ", "WRITE", "ADMIN"] },
      permissions: [String], // Specific permissions (deprecated - use RBAC roles)
      lastLogin: Date,
      loginAttempts: Number,
      locked: Boolean,
      lockReason: String,
      passwordChanged: Date,
      mfa: {
        enabled: Boolean,
        type: String, // SMS, APP, EMAIL
        secret: String,
      },
    },

    // RBAC - Role-Based Access Control
    roles: [{ type: Schema.Types.ObjectId, ref: "Role", index: true }],
    isSuperAdmin: { type: Boolean, default: false, index: true }, // Fast check for super admin access

    // Preferences
    preferences: {
      notifications: {
        email: Boolean,
        sms: Boolean,
        app: Boolean,
        workOrders: Boolean,
        maintenance: Boolean,
        reports: Boolean,
      },
      language: { type: String, default: "ar" },
      timezone: { type: String, default: "Asia/Riyadh" },
      theme: {
        type: String,
        enum: ["LIGHT", "DARK", "AUTO", "SYSTEM"],
        default: "SYSTEM",
      },
    },

    // Employment
    employment: {
      employeeId: String,
      hireDate: Date,
      terminationDate: Date,
      salary: Number,
      benefits: [String],
      emergencyContact: {
        name: String,
        relationship: String,
        phone: String,
      },
    },

    // Compliance
    compliance: {
      backgroundCheck: Boolean,
      drugTest: Boolean,
      training: [
        {
          course: String,
          completed: Date,
          expires: Date,
          status: String, // VALID, EXPIRED, PENDING
        },
      ],
      safetyRecord: {
        incidents: Number,
        violations: Number,
        lastIncident: Date,
      },
    },

    // Status & Workflow
    status: { type: String, enum: UserStatus, default: "ACTIVE" },
    // workflow fields removed - auditPlugin provides createdBy/updatedBy

    // Metadata
    tags: [String],
    customFields: Schema.Types.Mixed,

    // createdAt/updatedAt handled by timestamps:true
  },
  {
    timestamps: true,
    autoIndex: false, // Indexes managed via schema definitions with explicit names
  },
);

// Apply plugins
UserSchema.plugin(tenantIsolationPlugin, {
  // Enforce tenant-scoped uniqueness before indexes are ready
  uniqueTenantFields: ["email", "username", "code", "employeeId"],
});
UserSchema.plugin(auditPlugin);

// Indexes for performance (orgId is already indexed by tenantIsolationPlugin)
// CRITICAL FIX: Tenant-scoped unique indexes (partial filter guards legacy docs without orgId)
const UNIQUE_TENANT_FILTER = { orgId: { $exists: true } };
UserSchema.index(
  { orgId: 1, email: 1 },
  { unique: true, partialFilterExpression: UNIQUE_TENANT_FILTER, name: "users_orgId_email_unique" },
);
UserSchema.index(
  { orgId: 1, username: 1 },
  { unique: true, partialFilterExpression: UNIQUE_TENANT_FILTER, name: "users_orgId_username_unique" },
);
UserSchema.index(
  { orgId: 1, code: 1 },
  { unique: true, partialFilterExpression: UNIQUE_TENANT_FILTER, name: "users_orgId_code_unique" },
);

// FIXED: Tenant-scoped query indexes
UserSchema.index({ orgId: 1, "professional.role": 1 }, { name: "users_orgId_role" });
UserSchema.index({ orgId: 1, "professional.subRole": 1 }, { name: "users_orgId_subRole" }); // STRICT v4.1: Sub-role index
UserSchema.index({ orgId: 1, "professional.skills.category": 1 }, { name: "users_orgId_skills_category" });
UserSchema.index({ orgId: 1, "workload.available": 1 }, { name: "users_orgId_workload_available" });
UserSchema.index({ orgId: 1, "performance.rating": -1 }, { name: "users_orgId_performance_rating" });
UserSchema.index({ orgId: 1, isSuperAdmin: 1 }, { name: "users_orgId_isSuperAdmin" }); // RBAC index

// =============================================================================
// PII ENCRYPTION MIDDLEWARE (GDPR Article 32 - Security of Processing)
// =============================================================================

/**
 * Sensitive PII fields requiring encryption at rest
 * 
 * COMPLIANCE:
 * - GDPR Article 32: Security of processing (encryption)
 * - HIPAA: PHI encryption requirements
 * - ISO 27001: Cryptographic controls (A.10.1.1)
 */
const ENCRYPTED_FIELDS = {
  // Personal identification
  'personal.nationalId': 'National ID',
  'personal.passport': 'Passport Number',
  
  // Financial data
  'employment.salary': 'Salary',
  
  // Security credentials
  'security.mfa.secret': 'MFA Secret',
} as const;

/**
 * Pre-save hook: Encrypt sensitive PII fields before storing
 */
UserSchema.pre('save', async function(next) {
  // eslint-disable-next-line @typescript-eslint/no-this-alias -- Required for Mongoose hook traversal
  const doc = this;
  try {
    // Only encrypt if fields are modified and not already encrypted
    for (const [path, fieldName] of Object.entries(ENCRYPTED_FIELDS)) {
      const parts = path.split('.');
      let current: any = doc;
      
      // Navigate to parent object
      for (let i = 0; i < parts.length - 1; i++) {
        if (!current[parts[i]]) {
          current[parts[i]] = {};
        }
        current = current[parts[i]];
      }
      
      const field = parts[parts.length - 1];
      const value = current[field];
      
      // Encrypt if value exists and is not already encrypted
      if (value && !isEncrypted(value)) {
        current[field] = encryptField(value, path);
        
        logger.info('user:pii_encrypted', {
          action: 'pre_save_encrypt',
          fieldPath: path,
          fieldName,
          userId: doc._id?.toString(),
          orgId: (doc as any).orgId,
        });
      }
    }
    
    next();
  } catch (error) {
    logger.error('user:encryption_failed', {
      action: 'pre_save_encrypt',
      error: error instanceof Error ? error.message : String(error),
      userId: doc._id?.toString(),
    });
    next(error as Error);
  }
});

/**
 * Post-find hooks: Decrypt sensitive PII fields after retrieval
 * Applied to: find, findOne, findById, findOneAndUpdate
 */
function decryptPIIFields(doc: any) {
  if (!doc) return;
  
  try {
    for (const [path, fieldName] of Object.entries(ENCRYPTED_FIELDS)) {
      const parts = path.split('.');
      let current: any = doc;
      
      // Navigate to parent object
      for (let i = 0; i < parts.length - 1; i++) {
        if (!current[parts[i]]) {
          break;
        }
        current = current[parts[i]];
      }
      
      const field = parts[parts.length - 1];
      const value = current?.[field];
      
      // Decrypt if value is encrypted
      if (value && isEncrypted(value)) {
        current[field] = decryptField(value, path);
      }
    }
  } catch (error) {
    logger.error('user:decryption_failed', {
      action: 'post_find_decrypt',
      error: error instanceof Error ? error.message : String(error),
      userId: doc._id?.toString(),
    });
    // Don't throw - return encrypted value rather than breaking app
  }
}

// Apply decryption to various find operations
UserSchema.post('find', function(docs: any[]) {
  if (Array.isArray(docs)) {
    docs.forEach(decryptPIIFields);
  }
});

UserSchema.post('findOne', function(doc: any) {
  decryptPIIFields(doc);
});

UserSchema.post('findOneAndUpdate', function(doc: any) {
  decryptPIIFields(doc);
});

// =============================================================================
// SEC-001 FIX: Pre-findOneAndUpdate hook to encrypt PII fields during updates
// CRITICAL: Without this, User.findOneAndUpdate() bypasses PII encryption
// =============================================================================
UserSchema.pre('findOneAndUpdate', function(next) {
  try {
    const update = this.getUpdate() as Record<string, any>;
    if (!update) return next();
    
    // Handle both $set operations and direct field updates
    const updateData = update.$set ?? update;
    
    for (const [path, fieldName] of Object.entries(ENCRYPTED_FIELDS)) {
      // Check if this field is being updated
      const value = updateData[path];
      
      if (value !== undefined && value !== null && !isEncrypted(String(value))) {
        // Encrypt the field
        if (update.$set) {
          update.$set[path] = encryptField(String(value), path);
        } else {
          update[path] = encryptField(String(value), path);
        }
        
        logger.info('user:pii_encrypted', {
          action: 'pre_findOneAndUpdate_encrypt',
          fieldPath: path,
          fieldName,
        });
      }
    }
    
    next();
  } catch (error) {
    logger.error('user:encryption_failed', {
      action: 'pre_findOneAndUpdate_encrypt',
      error: error instanceof Error ? error.message : String(error),
    });
    next(error as Error);
  }
});

/**
 * SEC-001 FIX: Pre-updateOne/updateMany hooks to encrypt PII fields
 * Handles bulk update operations that bypass pre-save hooks
 */
UserSchema.pre('updateOne', function(next) {
  try {
    const update = this.getUpdate() as Record<string, any>;
    if (!update) return next();
    
    const updateData = update.$set ?? update;
    
    for (const [path, fieldName] of Object.entries(ENCRYPTED_FIELDS)) {
      const value = updateData[path];
      
      if (value !== undefined && value !== null && !isEncrypted(String(value))) {
        if (update.$set) {
          update.$set[path] = encryptField(String(value), path);
        } else {
          update[path] = encryptField(String(value), path);
        }
        
        logger.info('user:pii_encrypted', {
          action: 'pre_updateOne_encrypt',
          fieldPath: path,
          fieldName,
        });
      }
    }
    
    next();
  } catch (error) {
    logger.error('user:encryption_failed', {
      action: 'pre_updateOne_encrypt',
      error: error instanceof Error ? error.message : String(error),
    });
    next(error as Error);
  }
});

UserSchema.pre('updateMany', function(next) {
  try {
    const update = this.getUpdate() as Record<string, any>;
    if (!update) return next();
    
    const updateData = update.$set ?? update;
    
    for (const [path, fieldName] of Object.entries(ENCRYPTED_FIELDS)) {
      const value = updateData[path];
      
      if (value !== undefined && value !== null && !isEncrypted(String(value))) {
        if (update.$set) {
          update.$set[path] = encryptField(String(value), path);
        } else {
          update[path] = encryptField(String(value), path);
        }
        
        logger.info('user:pii_encrypted', {
          action: 'pre_updateMany_encrypt',
          fieldPath: path,
          fieldName,
        });
      }
    }
    
    next();
  } catch (error) {
    logger.error('user:encryption_failed', {
      action: 'pre_updateMany_encrypt',
      error: error instanceof Error ? error.message : String(error),
    });
    next(error as Error);
  }
});

// Note: findById uses findOne internally, so it's covered by the findOne hook

export type UserDoc = InferSchemaType<typeof UserSchema>;

export const User: Model<UserDoc> = getModel<UserDoc>("User", UserSchema);

]]>
</file>

<file path="server/models/Vendor.ts">
<![CDATA[
import { Schema, Model, models, InferSchemaType } from "mongoose";
import { getModel } from "@/types/mongoose-compat";
import { tenantIsolationPlugin } from "../plugins/tenantIsolation";
import { auditPlugin } from "../plugins/auditPlugin";
import { encryptionPlugin } from "../plugins/encryptionPlugin";

const VendorStatus = [
  "PENDING",
  "APPROVED",
  "SUSPENDED",
  "REJECTED",
  "BLACKLISTED",
] as const;
const VendorType = [
  "SUPPLIER",
  "CONTRACTOR",
  "SERVICE_PROVIDER",
  "CONSULTANT",
] as const;

const VendorSchema = new Schema(
  {
    // tenantId REMOVED - plugin will add orgId

    // Basic Information
    code: { type: String, required: true }, // unique removed - will be tenant-scoped
    name: { type: String, required: true },
    type: { type: String, enum: VendorType, required: true },

    // Contact Information
    contact: {
      primary: {
        name: String,
        title: String,
        email: String,
        phone: String,
        mobile: String,
      },
      secondary: {
        name: String,
        email: String,
        phone: String,
      },
      address: {
        street: String,
        city: String,
        region: String,
        postalCode: String,
        country: { type: String, default: "SA" },
      },
    },

    // Business Information
    business: {
      registrationNumber: String,
      taxId: String,
      licenseNumber: String,
      establishedDate: Date,
      employees: Number,
      annualRevenue: Number,
      specializations: [String], // Areas of expertise
      certifications: [
        {
          name: String,
          issuer: String,
          issued: Date,
          expires: Date,
          status: String, // VALID, EXPIRED, PENDING
        },
      ],
    },

    // Approval Status
    status: { type: String, enum: VendorStatus, default: "PENDING" },
    approval: {
      approvedBy: { type: Schema.Types.ObjectId, ref: "User" },
      approvedAt: Date,
      rejectionReason: String,
      suspensionReason: String,
      reviewNotes: String,
    },

    // Performance Metrics
    performance: {
      rating: { type: Number, min: 0, max: 5 },
      completedProjects: Number,
      ongoingProjects: Number,
      successRate: Number, // percentage
      averageResponseTime: Number, // hours
      complianceRate: Number, // percentage
      reviews: [
        {
          clientId: { type: Schema.Types.ObjectId, ref: "Organization" },
          rating: Number,
          comment: String,
          date: Date,
          projectId: { type: Schema.Types.ObjectId, ref: "Project" },
        },
      ],
    },

    // Financial Information
    financial: {
      bankDetails: {
        accountNumber: String,
        bankName: String,
        iban: String,
      },
      creditLimit: Number,
      paymentTerms: Number, // days
      outstandingBalance: Number,
      paymentHistory: [
        {
          date: Date,
          amount: Number,
          invoiceId: { type: Schema.Types.ObjectId, ref: "Invoice" },
          status: String, // PAID, PENDING, OVERDUE
          method: String,
        },
      ],
    },

    // Services & Products
    catalog: [
      {
        category: String,
        subcategory: String,
        products: [
          {
            code: String,
            name: String,
            description: String,
            unitPrice: Number,
            currency: { type: String, default: "SAR" },
            leadTime: Number, // days
            availability: String, // IN_STOCK, OUT_OF_STOCK, DISCONTINUED
            specifications: Schema.Types.Mixed,
          },
        ],
      },
    ],

    // Work History
    projects: [
      {
        projectId: { type: Schema.Types.ObjectId, ref: "Project" },
        name: String,
        type: String,
        startDate: Date,
        endDate: Date,
        value: Number,
        status: String, // COMPLETED, ONGOING, CANCELLED
        clientId: { type: Schema.Types.ObjectId, ref: "Organization" },
        rating: Number,
        feedback: String,
      },
    ],

    // Compliance
    compliance: {
      insurance: {
        provider: String,
        policyNumber: String,
        coverage: Number,
        expiry: Date,
        status: String, // VALID, EXPIRED, PENDING
      },
      licenses: [
        {
          type: String, // Business License, Trade License, etc.
          number: String,
          issued: Date,
          expires: Date,
          status: String,
        },
      ],
      certifications: [
        {
          type: String, // ISO, OSHA, etc.
          number: String,
          issued: Date,
          expires: Date,
          status: String,
        },
      ],
      backgroundCheck: Boolean,
      references: [
        {
          company: String,
          contact: String,
          phone: String,
          email: String,
          verified: Boolean,
        },
      ],
    },

    // Contracts & Agreements
    contracts: [
      {
        contractId: { type: Schema.Types.ObjectId, ref: "Contract" },
        type: String, // MASTER, PROJECT_SPECIFIC, NDA, etc.
        startDate: Date,
        endDate: Date,
        value: Number,
        terms: String,
        status: String, // ACTIVE, EXPIRED, TERMINATED
        signed: Date,
        signedBy: { type: Schema.Types.ObjectId, ref: "User" },
      },
    ],

    // Preferences
    preferences: {
      notification: {
        email: Boolean,
        sms: Boolean,
        app: Boolean,
      },
      communication: {
        preferredMethod: String, // EMAIL, PHONE, APP
        preferredLanguage: { type: String, default: "ar" },
      },
    },

    // Metadata
    tags: [String],
    customFields: Schema.Types.Mixed,

    // createdBy/updatedBy will be added by auditPlugin
  },
  {
    timestamps: true,
  },
);

// APPLY PLUGINS (BEFORE INDEXES)
VendorSchema.plugin(tenantIsolationPlugin);
VendorSchema.plugin(auditPlugin);
// PII encryption for sensitive financial data
VendorSchema.plugin(encryptionPlugin, {
  fields: {
    "financial.bankDetails.accountNumber": "Bank Account Number",
    "financial.bankDetails.iban": "IBAN",
  },
});

// INDEXES (AFTER PLUGINS)
// CRITICAL FIX: Tenant-scoped unique index for 'code'
VendorSchema.index(
  { orgId: 1, code: 1 },
  { unique: true, partialFilterExpression: { orgId: { $exists: true } } },
);

// FIXED: Tenant-scoped indexes
VendorSchema.index({ orgId: 1, status: 1 });
VendorSchema.index({ orgId: 1, type: 1 });
VendorSchema.index({ orgId: 1, "performance.rating": -1 });
VendorSchema.index({ orgId: 1, "business.specializations": 1 });

export type VendorDoc = InferSchemaType<typeof VendorSchema>;

export const Vendor: Model<VendorDoc> = getModel<VendorDoc>(
  "Vendor",
  VendorSchema,
);

]]>
</file>

<file path="server/models/WorkOrder.ts">
<![CDATA[
import { Schema, Model, models, InferSchemaType } from "mongoose";
import { getModel } from "@/types/mongoose-compat";
import { tenantIsolationPlugin } from "../plugins/tenantIsolation";
import { auditPlugin } from "../plugins/auditPlugin";

// Work Order Status - State Machine as per specification
const WorkOrderStatus = [
  "DRAFT",
  "SUBMITTED",
  "ASSIGNED",
  "IN_PROGRESS",
  "ON_HOLD",
  "PENDING_APPROVAL",
  "COMPLETED",
  "VERIFIED",
  "CLOSED",
  "CANCELLED",
  "REJECTED",
] as const;

const Priority = ["LOW", "MEDIUM", "HIGH", "URGENT", "CRITICAL"] as const;
const WorkOrderType = [
  "MAINTENANCE",
  "REPAIR",
  "INSPECTION",
  "INSTALLATION",
  "EMERGENCY",
  "PREVENTIVE",
  "CORRECTIVE",
] as const;
const SLAStatus = ["ON_TIME", "AT_RISK", "OVERDUE", "BREACHED"] as const;

// Work Order Mongoose Schema - Direct MongoDB Implementation

const WorkOrderSchema = new Schema(
  {
    // Multi-tenancy - will be added by plugin
    // orgId: { type: String, required: true, index: true },

    // Basic Information
    workOrderNumber: { type: String, required: true },
    title: { type: String, required: true, trim: true },
    description: {
      type: String,
      required: function (this: { status?: string }) {
        return this.status !== "DRAFT";
      },
    },
    type: { type: String, enum: WorkOrderType, required: true },
    category: { type: String, required: true },
    subcategory: String,

    // Priority and SLA
    priority: {
      type: String,
      enum: Priority,
      required: true,
      default: "MEDIUM",
    },
    urgency: {
      type: String,
      enum: ["LOW", "MEDIUM", "HIGH", "CRITICAL"],
      default: "MEDIUM",
    },
    impact: {
      type: String,
      enum: ["LOW", "MEDIUM", "HIGH", "CRITICAL"],
      default: "MEDIUM",
    },

    // SLA Management
    sla: {
      responseTimeMinutes: { type: Number, required: true },
      resolutionTimeMinutes: { type: Number, required: true },
      responseDeadline: Date,
      resolutionDeadline: Date,
      status: { type: String, enum: SLAStatus, default: "ON_TIME" },
      breachReasons: [String],
      escalationLevel: { type: Number, default: 0 },
    },

    // Location Information
    location: {
      propertyId: {
        type: Schema.Types.ObjectId,
        ref: "Property",
        required: function (this: { status?: string }) {
          return this.status !== "DRAFT";
        },
      },
      unitNumber: String,
      floor: String,
      building: String,
      area: String,
      room: String,
      coordinates: {
        latitude: Number,
        longitude: Number,
      },
      accessInstructions: String,
    },

    // Requester Information
    requester: {
      userId: { type: Schema.Types.ObjectId, ref: "User" },
      type: {
        type: String,
        enum: ["TENANT", "OWNER", "STAFF", "EXTERNAL"],
        required: true,
      },
      name: { type: String, required: true },
      contactInfo: {
        phone: String,
        mobile: String,
        email: String,
        preferredContact: {
          type: String,
          enum: ["PHONE", "MOBILE", "EMAIL", "APP"],
        },
      },
      isAnonymous: { type: Boolean, default: false },
      availabilityWindow: {
        from: Date,
        to: Date,
        notes: String,
      },
    },

    // Assignment and Team
    assignment: {
      assignedTo: {
        userId: { type: Schema.Types.ObjectId, ref: "User" },
        teamId: { type: Schema.Types.ObjectId, ref: "Team" },
        vendorId: { type: Schema.Types.ObjectId, ref: "Vendor" },
        name: String,
        contactInfo: {
          phone: String,
          email: String,
        },
      },
      assignedBy: { type: Schema.Types.ObjectId, ref: "User" },
      assignedAt: Date,
      reassignmentHistory: [
        {
          fromUserId: { type: Schema.Types.ObjectId, ref: "User" },
          toUserId: { type: Schema.Types.ObjectId, ref: "User" },
          reason: String,
          assignedBy: { type: Schema.Types.ObjectId, ref: "User" },
          assignedAt: Date,
        },
      ],
      estimatedStartTime: Date,
      estimatedCompletionTime: Date,
      scheduledDate: Date,
      scheduledTimeSlot: {
        start: String, // HH:MM
        end: String, // HH:MM
      },
    },

    // Status and Workflow
    status: {
      type: String,
      enum: WorkOrderStatus,
      required: true,
      default: "DRAFT",
    },
    workflow: {
      requiresApproval: { type: Boolean, default: false },
      approver: { type: Schema.Types.ObjectId, ref: "User" },
      approvedAt: Date,
      approvalNotes: String,
      rejectionReason: String,
      currentStep: String,
      nextStep: String,
      completionPercentage: { type: Number, default: 0, min: 0, max: 100 },
    },

    // Status History with State Machine
    statusHistory: [
      {
        fromStatus: String,
        toStatus: String,
        changedBy: String,
        changedAt: { type: Date, default: Date.now },
        reason: String,
        notes: String,
        automaticTransition: { type: Boolean, default: false },
      },
    ],

    // Work Details
    work: {
      actualStartTime: Date,
      actualEndTime: Date,
      totalTimeSpent: Number, // in minutes
      breakdowns: [
        {
          taskDescription: String,
          startTime: Date,
          endTime: Date,
          timeSpent: Number, // in minutes
          performedBy: String,
        },
      ],
      rootCause: String,
      solutionDescription: String,
      preventiveMeasures: String,
      followUpRequired: { type: Boolean, default: false },
      followUpDate: Date,
      workPerformed: String,
      testsPerformed: [String],
      qualityChecks: [
        {
          checkName: String,
          passed: Boolean,
          notes: String,
          checkedBy: String,
          checkedAt: Date,
        },
      ],
    },

    // Materials and Resources
    resources: {
      materials: [
        {
          itemId: String,
          name: String,
          quantity: Number,
          unit: String,
          unitCost: Number,
          totalCost: Number,
          supplierName: String,
          requestedBy: String,
          approvedBy: String,
          deliveredAt: Date,
          notes: String,
        },
      ],
      tools: [
        {
          toolId: String,
          name: String,
          checkedOutAt: Date,
          checkedInAt: Date,
          condition: String,
          notes: String,
        },
      ],
      labor: [
        {
          userId: String,
          name: String,
          role: String,
          hours: Number,
          hourlyRate: Number,
          totalCost: Number,
          overtime: Boolean,
        },
      ],
    },

    // Financial Information
    financial: {
      isBillable: { type: Boolean, default: false },
      estimatedCost: Number,
      actualCost: Number,
      currency: { type: String, default: "SAR" },
      costBreakdown: {
        labor: Number,
        materials: Number,
        equipment: Number,
        overhead: Number,
        markup: Number,
        tax: Number,
        total: Number,
      },
      budgetCode: String,
      costCenter: String,
      purchaseOrderNumber: String,
      invoiceNumber: String,
      paymentStatus: {
        type: String,
        enum: ["PENDING", "PAID", "OVERDUE", "CANCELLED"],
      },
      paymentDate: Date,
    },

    // Finance integration tracking
    financePosted: { type: Boolean, default: false },
    journalEntryId: { type: Schema.Types.ObjectId, ref: "JournalEntry" },
    journalNumber: String,
    financePostedDate: Date,
    financePostedBy: { type: Schema.Types.ObjectId, ref: "User" },

    // Communication and Updates
    communication: {
      comments: [
        {
          commentId: {
            type: String,
            default: () => new Date().getTime().toString(),
          },
          userId: String,
          userName: String,
          comment: String,
          timestamp: { type: Date, default: Date.now },
          isInternal: { type: Boolean, default: false },
          attachments: [
            {
              name: String,
              url: String,
              type: String,
              size: Number,
            },
          ],
          mentions: [String], // userIds mentioned in comment
        },
      ],
      notifications: [
        {
          type: String, // STATUS_CHANGE, ASSIGNMENT, COMMENT, etc.
          sentTo: [String], // userIds
          sentAt: Date,
          channel: String, // EMAIL, SMS, PUSH, IN_APP
          status: String, // SENT, DELIVERED, READ
        },
      ],
      updates: [
        {
          updateType: String,
          description: String,
          updatedBy: String,
          updatedAt: Date,
          isAutomated: { type: Boolean, default: false },
        },
      ],
    },

    // Attachments and Documentation
    attachments: [
      {
        key: String,
        fileName: String,
        originalName: String,
        fileUrl: String,
        fileType: String,
        fileSize: Number,
        uploadedBy: String,
        uploadedAt: { type: Date, default: Date.now },
        category: String, // BEFORE, AFTER, INVOICE, RECEIPT, etc.
        description: String,
        isPublic: { type: Boolean, default: false },
        scanStatus: {
          type: String,
          enum: ["pending", "clean", "infected", "error"],
          default: "pending",
        },
      },
    ],

    // Quality and Rating
    quality: {
      customerRating: {
        score: { type: Number, min: 1, max: 5 },
        feedback: String,
        ratedBy: String,
        ratedAt: Date,
        categories: {
          timeliness: Number,
          quality: Number,
          communication: Number,
          professionalism: Number,
        },
      },
      internalRating: {
        score: { type: Number, min: 1, max: 5 },
        notes: String,
        ratedBy: String,
        ratedAt: Date,
      },
      qualityMetrics: {
        firstTimeFixRate: Boolean,
        customerSatisfactionScore: Number,
        completionTime: Number,
        reopenCount: { type: Number, default: 0 },
      },
    },

    // Compliance and Safety
    compliance: {
      safetyChecklist: [
        {
          item: String,
          checked: Boolean,
          checkedBy: String,
          checkedAt: Date,
          notes: String,
        },
      ],
      permits: [
        {
          permitType: String,
          permitNumber: String,
          issuedBy: String,
          validFrom: Date,
          validTo: Date,
          status: String,
        },
      ],
      regulations: [String], // Applicable regulations/standards
      riskAssessment: {
        riskLevel: {
          type: String,
          enum: ["LOW", "MEDIUM", "HIGH", "CRITICAL"],
        },
        identifiedRisks: [String],
        mitigationMeasures: [String],
        assessedBy: String,
        assessedAt: Date,
      },
    },

    // Recurring Work Orders
    recurrence: {
      isRecurring: { type: Boolean, default: false },
      frequency: String, // DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY
      interval: Number, // Every N periods
      endDate: Date,
      maxOccurrences: Number,
      parentWorkOrderId: String, // Reference to original recurring WO
      nextScheduledDate: Date,
      lastGeneratedDate: Date,
    },

    // Integration and External References
    integrations: {
      externalSystemId: String,
      externalWorkOrderNumber: String,
      syncStatus: String,
      lastSyncAt: Date,
      syncErrors: [String],
      connectedSystems: [
        {
          systemName: String,
          systemId: String,
          lastSync: Date,
        },
      ],
    },

    // Analytics and KPIs
    metrics: {
      responseTime: Number, // minutes from creation to first response
      resolutionTime: Number, // minutes from creation to completion
      firstTimeFixRate: Boolean,
      escalationCount: { type: Number, default: 0 },
      reopenCount: { type: Number, default: 0 },
      customerTouchpoints: Number,
      technicianChangeCount: { type: Number, default: 0 },
    },

    // Custom Fields and Metadata
    customFields: Schema.Types.Mixed,
    tags: [String],
    references: [
      {
        type: String, // RELATED_WO, PARENT_WO, CHILD_WO, etc.
        workOrderId: String,
        description: String,
      },
    ],

    // Soft Delete
    isDeleted: { type: Boolean, default: false },
    deletedAt: Date,
    deletedBy: String,
    deletionReason: String,
  },
  {
    timestamps: true,
    // Add version key for optimistic locking
    versionKey: "version",
    // ⚡ CRITICAL: Disable automatic index creation to prevent IndexOptionsConflict
    // All indexes are managed manually in lib/db/collections.ts for explicit control
    autoIndex: false,
  },
);

// Apply plugins
WorkOrderSchema.plugin(tenantIsolationPlugin, {
  uniqueTenantFields: ["workOrderNumber"],
});
WorkOrderSchema.plugin(auditPlugin);

// ═══════════════════════════════════════════════════════════════════════════
// INDEX MANAGEMENT NOTE
// ═══════════════════════════════════════════════════════════════════════════
// All indexes for this model are managed manually in lib/db/collections.ts
// using the native MongoDB driver with explicit names and options.
//
// See: createIndexes() in lib/db/collections.ts (lines 138-167)
// Indexes: workorders_orgId_workOrderNumber_unique, workorders_orgId_status,
//          workorders_orgId_priority, workorders_orgId_propertyId, etc.
//
// WHY: This prevents IndexOptionsConflict errors during deployment and ensures
// consistent org-scoped multi-tenancy (STRICT v4.1 compliance).
//
// Schema indexes have been removed to maintain single source of truth.
// ═══════════════════════════════════════════════════════════════════════════

// State machine validation
WorkOrderSchema.pre("save", function (next) {
  // Validate status transitions
  const validTransitions: Record<string, string[]> = {
    DRAFT: ["SUBMITTED", "CANCELLED"],
    SUBMITTED: ["ASSIGNED", "REJECTED", "CANCELLED"],
    ASSIGNED: ["IN_PROGRESS", "ON_HOLD", "CANCELLED"],
    IN_PROGRESS: ["ON_HOLD", "PENDING_APPROVAL", "COMPLETED", "CANCELLED"],
    ON_HOLD: ["IN_PROGRESS", "CANCELLED"],
    PENDING_APPROVAL: ["COMPLETED", "REJECTED", "IN_PROGRESS"],
    COMPLETED: ["VERIFIED", "REJECTED"],
    VERIFIED: ["CLOSED"],
    CLOSED: [], // Terminal state
    CANCELLED: [], // Terminal state
    REJECTED: ["DRAFT", "SUBMITTED"],
  };

  if (this.isModified("status") && !this.isNew) {
    const currentStatus = this.status;
    const previousStatus = (
      this as unknown as { $__?: { originalDoc?: { status?: string } } }
    ).$__?.originalDoc?.status;

    if (
      previousStatus &&
      !validTransitions[previousStatus]?.includes(currentStatus)
    ) {
      return next(
        new Error(
          `Invalid status transition from ${previousStatus} to ${currentStatus}`,
        ),
      );
    }
  }

  // Auto-generate work order number if not provided
  if (this.isNew && !this.workOrderNumber) {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const timestamp = now.getTime().toString().slice(-6);
    this.workOrderNumber = `WO-${year}${month}-${timestamp}`;
  }

  next();
});

// Virtual for due date calculation
WorkOrderSchema.virtual("isDue").get(function () {
  return (
    this.sla?.resolutionDeadline && new Date() > this.sla.resolutionDeadline
  );
});

// Virtual for overdue calculation
WorkOrderSchema.virtual("isOverdue").get(function () {
  return (
    this.sla?.resolutionDeadline && new Date() > this.sla.resolutionDeadline
  );
});

// Method to calculate SLA status
WorkOrderSchema.methods.updateSLAStatus = function () {
  const now = new Date();
  const resolutionDeadline = this.sla.resolutionDeadline;

  if (!resolutionDeadline) {
    this.sla.status = "ON_TIME";
    return;
  }

  const timeUntilDeadline = resolutionDeadline.getTime() - now.getTime();
  const totalSLATime = this.sla.resolutionTimeMinutes * 60 * 1000; // Convert to milliseconds
  const timeRemaining = timeUntilDeadline / totalSLATime;

  if (timeUntilDeadline < 0) {
    this.sla.status = "BREACHED";
  } else if (timeRemaining < 0.1) {
    // Less than 10% time remaining
    this.sla.status = "OVERDUE";
  } else if (timeRemaining < 0.25) {
    // Less than 25% time remaining
    this.sla.status = "AT_RISK";
  } else {
    this.sla.status = "ON_TIME";
  }
};

export type WorkOrderDoc = InferSchemaType<typeof WorkOrderSchema>;

// Virtual property for 'code' as alias to 'workOrderNumber'
WorkOrderSchema.virtual("code").get(function (this: WorkOrderDoc) {
  return this.workOrderNumber;
});

// ═══════════════════════════════════════════════════════════════════════════
// INDEXES REMOVED - Managed centrally in lib/db/collections.ts
// ═══════════════════════════════════════════════════════════════════════════
// All WorkOrder indexes are defined in createIndexes() to prevent
// IndexOptionsConflict errors during deployment. See:
//   - workorders_orgId_status_createdAt_desc
//   - workorders_orgId_assignedUser_status  
//   - workorders_orgId_propertyId_status
//   - workorders_orgId_unitNumber_status
//   - workorders_orgId_priority_slaStatus
//   - workorders_sla_resolutionDeadline
// ═══════════════════════════════════════════════════════════════════════════

// Ensure virtuals are included in JSON/Object output
WorkOrderSchema.set("toJSON", { virtuals: true });
WorkOrderSchema.set("toObject", { virtuals: true });

export const WorkOrder: Model<WorkOrderDoc> = getModel<WorkOrderDoc>(
  "WorkOrder",
  WorkOrderSchema,
);

]]>
</file>

<file path="server/models/aqar/Booking.ts">
<![CDATA[
/**
 * Aqar Souq - Booking Model (hotel-style daily rentals)
 * 
 * **Production Features:**
 * - Hard conflict prevention via reservedNights[] + unique partial index
 * - UTC-normalized date math (no timezone bugs)
 * - Tenant-scoped indexes for multi-tenant performance
 * - Atomic createWithAvailability() with race protection
 * - Guarded status transitions (confirm/checkIn/checkOut/cancel)
 * - Auto-computed pricing: totalPrice, platformFee (15%), hostPayout
 * - Query helpers: isAvailable(), overlaps()
 * 
 * **Conflict Strategy:**
 * The unique partial index on (orgId, listingId, reservedNights) where status IN [PENDING, CONFIRMED, CHECKED_IN]
 * is the ONLY reliable way to prevent double-bookings at DB level without heavyweight transactions.
 * Each booking has an array of UTC date-only nights [checkIn..checkOut-1].
 */

import mongoose, { Schema, Document, Model } from 'mongoose';
import type { MModel } from '@/types/mongoose-compat';
import { EscrowSource, EscrowState, type EscrowStateValue } from '@/server/models/finance/EscrowAccount';
import { tenantIsolationPlugin } from '@/server/plugins/tenantIsolation';
import { encryptField, decryptField, isEncrypted } from '@/lib/security/encryption';
import { logger } from '@/lib/logger';

export enum BookingStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  CHECKED_IN = 'CHECKED_IN',
  CHECKED_OUT = 'CHECKED_OUT',
  CANCELLED = 'CANCELLED',
  REJECTED = 'REJECTED',
}

const ACTIVE_STATUSES: BookingStatus[] = [
  BookingStatus.PENDING,
  BookingStatus.CONFIRMED,
  BookingStatus.CHECKED_IN,
];

export interface IBooking extends Document {
  // Property / tenancy
  listingId: mongoose.Types.ObjectId;
  orgId: mongoose.Types.ObjectId;

  // Parties
  guestId: mongoose.Types.ObjectId;
  hostId: mongoose.Types.ObjectId;

  // Dates (UTC date-only, checkOutDate is exclusive)
  checkInDate: Date;     // inclusive (00:00 UTC)
  checkOutDate: Date;    // exclusive (00:00 UTC next day)
  nights: number;
  reservedNights: Date[]; // array of UTC date-only nights [checkIn..checkOut-1]

  // Pricing (SAR)
  pricePerNight: number;     // >= 0
  totalPrice: number;        // computed: pricePerNight × nights
  platformFee: number;       // computed: 15% of totalPrice (consider moving to org config)
  hostPayout: number;        // computed: totalPrice - platformFee

  // Guests
  adults: number;
  children: number;
  infants: number;

  // Status
  status: BookingStatus;

  // Communication
  guestPhone?: string;
  guestNationalId?: string;
  specialRequests?: string;
  hostNotes?: string;

  // Payment
  paymentId?: mongoose.Types.ObjectId;
  paidAt?: Date;

  // Cancellation
  cancelledAt?: Date;
  cancelledBy?: mongoose.Types.ObjectId;
  cancellationReason?: string;
  refundAmount?: number;

  // Check-in/out
  checkedInAt?: Date;
  checkedOutAt?: Date;

  // Escrow
  escrow?: {
    accountId?: mongoose.Types.ObjectId;
    status?: EscrowStateValue;
    releaseAfter?: Date;
    lastEventId?: string;
    idempotencyKey?: string;
  };

  // Timestamps
  createdAt: Date;
  updatedAt: Date;

  // Instance methods
  confirm(): Promise<void>;
  checkIn(): Promise<void>;
  checkOut(): Promise<void>;
  cancel(userId: mongoose.Types.ObjectId, reason?: string): Promise<void>;
}

const BookingSchema = new Schema<IBooking>(
  {
    listingId: { type: Schema.Types.ObjectId, ref: 'AqarListing', required: true, index: true },
    orgId: { type: Schema.Types.ObjectId, ref: 'Organization', required: true, index: true },

    guestId: { type: Schema.Types.ObjectId, ref: 'User', required: true, index: true },
    hostId: { type: Schema.Types.ObjectId, ref: 'User', required: true, index: true },

    checkInDate: { type: Date, required: true, index: true },
    checkOutDate: { type: Date, required: true, index: true },
    nights: { type: Number, required: true, min: 1 },
    reservedNights: [{ type: Date, index: true }], // filled per-night in UTC

    pricePerNight: { type: Number, required: true, min: 0 },
    totalPrice: { type: Number, required: true, min: 0 },
    platformFee: { type: Number, required: true, min: 0, default: 0 },
    hostPayout: { type: Number, required: true, min: 0 },

    adults: { type: Number, required: true, min: 1 },
    children: { type: Number, default: 0, min: 0 },
    infants: { type: Number, default: 0, min: 0 },

    status: {
      type: String,
      enum: Object.values(BookingStatus),
      default: BookingStatus.PENDING,
      required: true,
      index: true,
    },

    guestPhone: { type: String, trim: true },
    guestNationalId: { type: String, trim: true },
    specialRequests: { type: String, maxlength: 1000, trim: true },
    hostNotes: { type: String, maxlength: 1000, trim: true },

    paymentId: { type: Schema.Types.ObjectId, ref: 'Payment' },
    paidAt: { type: Date },

    cancelledAt: { type: Date },
    cancelledBy: { type: Schema.Types.ObjectId, ref: 'User' },
    cancellationReason: { type: String, maxlength: 500, trim: true },
    refundAmount: { type: Number, min: 0 },

    checkedInAt: { type: Date },
    checkedOutAt: { type: Date },
    escrow: {
      accountId: { type: Schema.Types.ObjectId, ref: 'EscrowAccount', index: true },
      status: { type: String, enum: Object.values(EscrowState) },
      releaseAfter: { type: Date },
      lastEventId: { type: String },
      idempotencyKey: { type: String },
    },
  },
  {
    timestamps: true,
    collection: 'aqar_bookings',
  }
);

/* ---------------- Indexes ---------------- */

// Query patterns: bookings by listing/guest/host within tenant, sorted by date
BookingSchema.index({ orgId: 1, listingId: 1, checkInDate: 1, checkOutDate: 1 });
BookingSchema.index({ orgId: 1, guestId: 1, status: 1, checkInDate: -1 });
BookingSchema.index({ orgId: 1, hostId: 1, status: 1, checkInDate: -1 });
BookingSchema.index({ createdAt: -1 });

/**
 * Hard no-overlap guarantee: unique per (orgId, listingId, reservedNight) while status is active.
 * This prevents two bookings from reserving the same night for the same listing.
 * Each booking has reservedNights[] with one UTC Date per booked night.
 * 
 * **Critical:** This is the ONLY reliable way to enforce no overlaps at DB level in MongoDB
 * without heavyweight transactions on date ranges.
 */
BookingSchema.index(
  { orgId: 1, listingId: 1, reservedNights: 1 },
  {
    unique: true,
    partialFilterExpression: { status: { $in: ACTIVE_STATUSES } },
    name: 'uniq_active_reservation_per_night',
  }
);

// =============================================================================
// DATA-001 FIX: Apply tenantIsolationPlugin for multi-tenant data isolation
// CRITICAL: Prevents cross-tenant data access in Aqar Marketplace
// =============================================================================
BookingSchema.plugin(tenantIsolationPlugin);

// =============================================================================
// SEC-002 FIX: PII Encryption for guest personal data (GDPR Article 32)
// Encrypts nationalId and phone for data protection compliance
// =============================================================================
const BOOKING_ENCRYPTED_FIELDS = {
  'guestNationalId': 'Guest National ID',
  'guestPhone': 'Guest Phone',
} as const;

/**
 * Pre-save hook: Encrypt guest PII fields
 */
BookingSchema.pre('save', function(next) {
  try {
    for (const [field, fieldName] of Object.entries(BOOKING_ENCRYPTED_FIELDS)) {
      const value = (this as any)[field];
      if (value && !isEncrypted(value)) {
        (this as any)[field] = encryptField(value, `booking.${field}`);
        logger.info('booking:pii_encrypted', {
          action: 'pre_save_encrypt',
          fieldPath: field,
          fieldName,
          bookingId: this._id?.toString(),
        });
      }
    }
    next();
  } catch (error) {
    logger.error('booking:encryption_failed', {
      action: 'pre_save_encrypt',
      error: error instanceof Error ? error.message : String(error),
    });
    next(error as Error);
  }
});

/**
 * Pre-findOneAndUpdate hook: Encrypt guest PII fields during updates
 */
BookingSchema.pre('findOneAndUpdate', function(next) {
  try {
    const update = this.getUpdate() as Record<string, any>;
    if (!update) return next();
    
    const updateData = update.$set ?? update;
    
    for (const [field, fieldName] of Object.entries(BOOKING_ENCRYPTED_FIELDS)) {
      const value = updateData[field];
      if (value !== undefined && value !== null && !isEncrypted(String(value))) {
        if (update.$set) {
          update.$set[field] = encryptField(String(value), `booking.${field}`);
        } else {
          update[field] = encryptField(String(value), `booking.${field}`);
        }
        logger.info('booking:pii_encrypted', {
          action: 'pre_findOneAndUpdate_encrypt',
          fieldPath: field,
          fieldName,
        });
      }
    }
    next();
  } catch (error) {
    logger.error('booking:encryption_failed', {
      action: 'pre_findOneAndUpdate_encrypt',
      error: error instanceof Error ? error.message : String(error),
    });
    next(error as Error);
  }
});

/**
 * Post-find hooks: Decrypt guest PII fields after retrieval
 */
function decryptBookingPIIFields(doc: any) {
  if (!doc) return;
  try {
    for (const field of Object.keys(BOOKING_ENCRYPTED_FIELDS)) {
      const value = doc[field];
      if (value && isEncrypted(value)) {
        doc[field] = decryptField(value, `booking.${field}`);
      }
    }
  } catch (error) {
    logger.error('booking:decryption_failed', {
      action: 'post_find_decrypt',
      error: error instanceof Error ? error.message : String(error),
    });
  }
}

BookingSchema.post('find', function(docs: any[]) {
  if (Array.isArray(docs)) docs.forEach(decryptBookingPIIFields);
});

BookingSchema.post('findOne', function(doc: any) {
  decryptBookingPIIFields(doc);
});

BookingSchema.post('findOneAndUpdate', function(doc: any) {
  decryptBookingPIIFields(doc);
});

/* ---------------- Helpers ---------------- */

const MS_PER_DAY = 86_400_000;

/**
 * Normalize to UTC date-only (00:00:00.000 UTC)
 * Strips time component to avoid timezone issues
 */
function toUTCDateOnly(d: Date): Date {
  const t = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  return new Date(t);
}

/**
 * Enumerate all nights (UTC date-only) from checkIn to checkOut-1
 * Example: checkIn=2025-01-01, checkOut=2025-01-03 => [2025-01-01, 2025-01-02]
 */
function enumerateNightsUTC(checkIn: Date, checkOut: Date): Date[] {
  const start = toUTCDateOnly(checkIn);
  const end = toUTCDateOnly(checkOut);
  const out: Date[] = [];
  for (let t = start.getTime(); t < end.getTime(); t += MS_PER_DAY) {
    out.push(new Date(t));
  }
  return out;
}

/* ---------------- Pre-save: derived fields ---------------- */

/**
 * Pre-validate hook: compute nights, normalize dates to UTC, populate reservedNights
 * This runs before validation, ensuring nights >= 1 constraint is checked
 */
BookingSchema.pre('validate', function (next) {
  // Normalize to UTC date-only and compute nights
  if (this.isModified('checkInDate') || this.isModified('checkOutDate')) {
    const inUTC = toUTCDateOnly(this.checkInDate);
    const outUTC = toUTCDateOnly(this.checkOutDate);
    const nights = Math.max(0, Math.round((outUTC.getTime() - inUTC.getTime()) / MS_PER_DAY));
    this.nights = nights;

    if (this.nights < 1) {
      return next(new Error('Check-out must be at least 1 day after check-in'));
    }

    this.checkInDate = inUTC;
    this.checkOutDate = outUTC;
    this.reservedNights = enumerateNightsUTC(inUTC, outUTC);
  }

  // Auto-compute pricing (totalPrice, platformFee, hostPayout)
  if (this.isModified('pricePerNight') || this.isModified('nights') || this.isNew) {
    const total = Math.max(0, (this.pricePerNight || 0) * (this.nights || 0));
    // Platform fee: 15% default, configurable via PLATFORM_FEE_PERCENTAGE env var
    const feePercentage = Number(process.env.PLATFORM_FEE_PERCENTAGE) || 15;
    const platform = Math.round(total * (feePercentage / 100));
    const payout = Math.max(0, total - platform);
    this.totalPrice = total;
    this.platformFee = platform;
    this.hostPayout = payout;
  }

  next();
});

// =============================================================================
// DATA-003 FIX: Pre-findOneAndUpdate hook to recalculate derived fields
// CRITICAL: Without this, Booking.findOneAndUpdate() bypasses derived field computation
// This could lead to data inconsistency (wrong nights count, pricing, reservedNights)
// 
// ENHANCED: Now fetches existing document for partial updates to ensure derived
// fields are always recalculated correctly. Also enforces runValidators.
// =============================================================================
BookingSchema.pre('findOneAndUpdate', async function (next) {
  try {
    // Enforce validation and return updated document
    this.setOptions({ runValidators: true, new: true, context: 'query' });
    
    const update = this.getUpdate() as Record<string, any>;
    if (!update) return next();
    
    const updateData = update.$set ?? update;
    
    // Check if dates or price are being updated
    const hasCheckInUpdate = updateData.checkInDate !== undefined;
    const hasCheckOutUpdate = updateData.checkOutDate !== undefined;
    const hasPriceUpdate = updateData.pricePerNight !== undefined;
    
    // If any date or price field is being updated, we need to recalculate derived fields
    if (hasCheckInUpdate || hasCheckOutUpdate || hasPriceUpdate) {
      // Fetch existing document to get current values for partial updates
      // IMPORTANT: Attach session to respect active transactions
      const session = this.getOptions().session ?? null;
      // Use explicit type for lean() result (plain object, not Mongoose Document)
      const existing = await this.model.findOne(this.getQuery()).session(session).lean().exec() as {
        checkInDate?: Date;
        checkOutDate?: Date;
        pricePerNight?: number;
      } | null;
      if (!existing) {
        return next(new Error('Booking not found for update'));
      }
      
      // Merge existing values with updates (updates take precedence)
      // BOOK-002 FIX: Validate that dates exist before processing
      const checkInDate = hasCheckInUpdate ? updateData.checkInDate : existing.checkInDate;
      const checkOutDate = hasCheckOutUpdate ? updateData.checkOutDate : existing.checkOutDate;
      const pricePerNight = hasPriceUpdate ? updateData.pricePerNight : existing.pricePerNight;
      
      // Validate required date fields are present
      if (!checkInDate || !checkOutDate) {
        return next(new Error('Booking must have valid check-in and check-out dates'));
      }
      
      // Calculate derived fields with merged values
      const inUTC = toUTCDateOnly(new Date(checkInDate));
      const outUTC = toUTCDateOnly(new Date(checkOutDate));
      
      // BOOK-002 FIX: Validate dates are valid before proceeding
      if (isNaN(inUTC.getTime()) || isNaN(outUTC.getTime())) {
        return next(new Error('Invalid check-in or check-out date format'));
      }
      const nights = Math.max(0, Math.round((outUTC.getTime() - inUTC.getTime()) / MS_PER_DAY));
      
      if (nights < 1) {
        return next(new Error('Check-out must be at least 1 day after check-in'));
      }
      
      const reservedNights = enumerateNightsUTC(inUTC, outUTC);
      
      // Calculate pricing
      const price = pricePerNight ?? 0;
      const total = Math.max(0, price * nights);
      const feePercentage = Number(process.env.PLATFORM_FEE_PERCENTAGE) || 15;
      const platform = Math.round(total * (feePercentage / 100));
      const payout = Math.max(0, total - platform);
      
      // Apply all derived fields to update
      const derivedFields = {
        checkInDate: inUTC,
        checkOutDate: outUTC,
        nights,
        reservedNights,
        totalPrice: total,
        platformFee: platform,
        hostPayout: payout,
      };
      
      if (update.$set) {
        Object.assign(update.$set, derivedFields);
      } else {
        Object.assign(update, derivedFields);
      }
      
      logger.info('booking:derived_fields_recalculated', {
        action: 'pre_findOneAndUpdate',
        nights,
        reservedNightsCount: reservedNights.length,
        isPartialUpdate: !hasCheckInUpdate || !hasCheckOutUpdate,
        updatedFields: Object.keys(updateData).filter(k => ['checkInDate', 'checkOutDate', 'pricePerNight'].includes(k)),
      });
    }
    
    next();
  } catch (error) {
    logger.error('booking:derived_field_calculation_failed', {
      action: 'pre_findOneAndUpdate',
      error: error instanceof Error ? error.message : String(error),
    });
    next(error as Error);
  }
});

/* ---------------- Methods: status transitions ---------------- */

/**
 * Confirm a pending booking (PENDING → CONFIRMED)
 * Throws if not in PENDING status
 */
BookingSchema.methods.confirm = async function (this: IBooking) {
  if (this.status !== BookingStatus.PENDING) {
    throw new Error('Only pending bookings can be confirmed');
  }
  this.status = BookingStatus.CONFIRMED;
  await this.save();
};

/**
 * Check in a confirmed booking (CONFIRMED → CHECKED_IN)
 * Validates check-in date is today or in the past
 * Throws if not in CONFIRMED status or if before check-in date
 */
BookingSchema.methods.checkIn = async function (this: IBooking) {
  if (this.status !== BookingStatus.CONFIRMED) {
    throw new Error('Only confirmed bookings can be checked in');
  }
  const todayUTC = toUTCDateOnly(new Date());
  if (todayUTC < this.checkInDate) {
    throw new Error('Cannot check in before the check-in date');
  }
  this.status = BookingStatus.CHECKED_IN;
  this.checkedInAt = new Date();
  await this.save();
};

/**
 * Check out a checked-in booking (CHECKED_IN → CHECKED_OUT)
 * Throws if not in CHECKED_IN status
 */
BookingSchema.methods.checkOut = async function (this: IBooking) {
  if (this.status !== BookingStatus.CHECKED_IN) {
    throw new Error('Only checked-in bookings can be checked out');
  }
  this.status = BookingStatus.CHECKED_OUT;
  this.checkedOutAt = new Date();
  await this.save();
};

/**
 * Cancel a booking (any active status → CANCELLED)
 * Computes refund based on days until check-in:
 * - >= 7 days: 100% refund
 * - >= 3 days: 50% refund
 * - < 3 days: 0% refund
 * 
 * Throws if already checked out, cancelled, or currently checked in
 */
BookingSchema.methods.cancel = async function (
  this: IBooking,
  userId: mongoose.Types.ObjectId,
  reason?: string
) {
  if ([BookingStatus.CHECKED_OUT, BookingStatus.CANCELLED].includes(this.status)) {
    throw new Error('Cannot cancel completed or already cancelled booking');
  }
  if (this.status === BookingStatus.CHECKED_IN) {
    throw new Error('Cannot cancel an active stay. Please check out first.');
  }

  this.status = BookingStatus.CANCELLED;
  this.cancelledAt = new Date();
  this.cancelledBy = userId;
  this.cancellationReason = reason;

  // Refund policy: configurable via environment variables
  // Days thresholds for full refund (default 7 days)
  const fullRefundDays = Number(process.env.BOOKING_FULL_REFUND_DAYS) || 7;
  // Days threshold for partial refund (default 3 days)
  const partialRefundDays = Number(process.env.BOOKING_PARTIAL_REFUND_DAYS) || 3;
  // Partial refund percentage (default 50%)
  const partialRefundPercent = Number(process.env.BOOKING_PARTIAL_REFUND_PERCENT) || 50;
  
  const diffMs = this.checkInDate.getTime() - toUTCDateOnly(new Date()).getTime();
  const daysUntilCheckIn = Math.max(0, Math.floor(diffMs / MS_PER_DAY));
  if (daysUntilCheckIn >= fullRefundDays) {
    this.refundAmount = this.totalPrice;                         // Full refund
  } else if (daysUntilCheckIn >= partialRefundDays) {
    this.refundAmount = Math.round(this.totalPrice * (partialRefundPercent / 100));  // Configurable % refund
  } else {
    this.refundAmount = 0;                                       // No refund
  }

  await this.save();
};

/* ---------------- Statics: availability & atomic create ---------------- */

export interface BookingModel extends MModel<IBooking> {
  /**
   * Check if any active booking overlaps with the given nights
   * @param orgId - Organization ID
   * @param listingId - Listing ID
   * @param nights - Array of UTC date-only nights to check
   * @returns true if any overlap exists, false otherwise
   */
  overlaps(params: {
    orgId: mongoose.Types.ObjectId;
    listingId: mongoose.Types.ObjectId;
    nights: Date[];
  }): Promise<boolean>;

  /**
   * Check if listing is available for booking (no active overlaps)
   * @param orgId - Organization ID
   * @param listingId - Listing ID
   * @param checkInDate - Check-in date (will be normalized to UTC)
   * @param checkOutDate - Check-out date (will be normalized to UTC)
   * @returns true if available, false if conflicts exist
   */
  isAvailable(params: {
    orgId: mongoose.Types.ObjectId;
    listingId: mongoose.Types.ObjectId;
    checkInDate: Date;
    checkOutDate: Date;
  }): Promise<boolean>;

  /**
   * Atomically create booking only if dates are available
   * Throws "Dates not available" if conflicts exist
   * The unique index provides final race protection
   * 
   * @param doc - Booking document to create
   * @param session - Optional MongoDB session for transactions
   * @returns Created booking document
   * @throws Error if dates not available or duplicate key on reservedNights
   */
  createWithAvailability(
    doc: Partial<IBooking>,
    session?: mongoose.ClientSession
  ): Promise<IBooking>;
}

/**
 * Check if any active booking has reserved any of the given nights
 * Used for availability checks before creating new bookings
 */
BookingSchema.statics.overlaps = async function ({
  orgId,
  listingId,
  nights,
}: {
  orgId: mongoose.Types.ObjectId;
  listingId: mongoose.Types.ObjectId;
  nights: Date[];
}): Promise<boolean> {
  if (!nights.length) return false;
  const count = await this.countDocuments({
    orgId,
    listingId,
    status: { $in: ACTIVE_STATUSES },
    reservedNights: { $in: nights },
  });
  return count > 0;
};

/**
 * Check if listing is available for booking (no overlaps)
 * Normalizes dates to UTC and checks for conflicts
 */
// ✅ FIXED: Type-safe static method with proper BookingModel interface typing
BookingSchema.statics.isAvailable = (async function (
  this: BookingModel,
  {
    orgId,
    listingId,
    checkInDate,
    checkOutDate,
  }: {
    orgId: mongoose.Types.ObjectId;
    listingId: mongoose.Types.ObjectId;
    checkInDate: Date;
    checkOutDate: Date;
  }
): Promise<boolean> {
  const inUTC = toUTCDateOnly(checkInDate);
  const outUTC = toUTCDateOnly(checkOutDate);
  const nights = enumerateNightsUTC(inUTC, outUTC);
  return !(await this.overlaps({ orgId, listingId, nights }));
}) as BookingModel['isAvailable'];

/**
 * Atomically create booking with availability check
 * Throws if dates are not available
 * The unique index on reservedNights provides final race protection
 */
BookingSchema.statics.createWithAvailability = (async function (
  this: BookingModel,
  doc: Partial<IBooking>,
  session?: mongoose.ClientSession
): Promise<IBooking> {
  const inUTC = toUTCDateOnly(doc.checkInDate as Date);
  const outUTC = toUTCDateOnly(doc.checkOutDate as Date);
  const nights = enumerateNightsUTC(inUTC, outUTC);

  // Pre-check for conflicts (UX feedback)
  const conflict = await this.overlaps({
    orgId: doc.orgId as mongoose.Types.ObjectId,
    listingId: doc.listingId as mongoose.Types.ObjectId,
    nights,
  });
  if (conflict) {
    throw new Error('Dates not available for this listing');
  }

  // Create (unique index also guards race condition)
  const created = await this.create(
    [
      {
        ...doc,
        checkInDate: inUTC,
        checkOutDate: outUTC,
        reservedNights: nights,
      },
    ],
    { session }
  );
  const bookingDoc = created[0];

  // Create escrow account tied to this booking (critical for payouts)
  const { escrowService } = await import('@/services/souq/settlements/escrow-service');
  const { logger } = await import('@/lib/logger');
  try {
    if (process.env.FEATURE_ESCROW_ENABLED !== 'false') {
      const account = await escrowService.createEscrowAccount({
        source: EscrowSource.AQAR_BOOKING,
        sourceId: bookingDoc._id,
        bookingId: bookingDoc._id,
        orgId: bookingDoc.orgId,
        buyerId: bookingDoc.guestId,
        sellerId: bookingDoc.hostId,
        expectedAmount: bookingDoc.totalPrice,
        currency: 'SAR',
        releaseAfter: bookingDoc.checkOutDate,
        idempotencyKey: bookingDoc._id.toString(),
        riskHold: false,
      });

      bookingDoc.escrow = {
        accountId: account._id,
        status: account.status,
        releaseAfter: account.releasePolicy?.autoReleaseAt,
        idempotencyKey: account.idempotencyKeys?.[0],
      };
      await bookingDoc.save();
    } else {
      logger.info('[Escrow] Skipping escrow creation for booking (feature flag disabled)', {
        bookingId: bookingDoc._id.toString(),
      });
    }
  } catch (error) {
    logger.error('[Escrow] Failed to create account for booking', {
      bookingId: bookingDoc._id.toString(),
      error,
    });
    throw error;
  }

  return bookingDoc;
}) as BookingModel['createWithAvailability'];

/* ---------------- Model Export ---------------- */

// ✅ FIXED: Type-safe model export with proper BookingModel interface typing  
const Booking: BookingModel =
  (mongoose.models.AqarBooking as BookingModel) ||
  mongoose.model<IBooking, BookingModel>('AqarBooking', BookingSchema);

export default Booking;
export type BookingDoc = IBooking;

]]>
</file>

<file path="server/models/aqar/Boost.ts">
<![CDATA[
/**
 * Aqar Souq - Boost Model (paid listing promotions)
 *
 * **Production Features:**
 * - Unique partial index on (orgId, listingId, type, active: true) prevents overlaps
 * - Atomic activate() with duplicate key translation to user-friendly errors
 * - Auto-expiry guard in pre-save hook (computes expiresAt from activatedAt + duration)
 * - isActiveNow virtual (checks active && expiresAt > now)
 * - Analytics-safe counters: recordImpression/recordClick use $inc with min-0 protection
 * - ✅ Configurable pricing: getPricing(type, days) static uses environment variables (BOOST_*_PRICE_PER_DAY) with sensible defaults
 * - Query helpers: findActiveFor(orgId, listingId, type?), activateExclusive(id)
 *
 * **Overlap Prevention:**
 * The unique partial index ensures only ONE active boost of a given type per listing per tenant.
 * If you need multiple active HIGHLIGHTED but single FEATURED/PINNED, adjust the index filter.
 *
 * **Types:**
 * - FEATURED: Top placement, highest visibility (100 SAR/day)
 * - PINNED: Sticky in category listing (50 SAR/day)
 * - HIGHLIGHTED: Visual distinction (25 SAR/day)
 */

import mongoose, { Schema, Document } from "mongoose";
import type { HydratedDocument } from "mongoose";
import {
  getModel,
  MModel,
  CommonModelStatics,
} from "@/types/mongoose-compat";
import { tenantIsolationPlugin } from "@/server/plugins/tenantIsolation";

export enum BoostType {
  FEATURED = "FEATURED", // Top placement, highest visibility
  PINNED = "PINNED", // Sticky in category listing
  HIGHLIGHTED = "HIGHLIGHTED", // Visual distinction
}

export interface IBoost extends Document {
  // Listing / tenancy / user
  listingId: mongoose.Types.ObjectId;
  orgId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;

  // Boost details
  type: BoostType;
  durationDays: number; // Positive integer, min 1

  // Pricing (SAR)
  price: number; // >= 0, computed from type + duration

  // Payment
  paymentId?: mongoose.Types.ObjectId;
  paidAt?: Date;

  // Validity
  activatedAt?: Date;
  expiresAt?: Date;
  active: boolean; // True when boost is live, false when inactive/expired

  // Analytics
  impressions: number; // Incremented on view
  clicks: number; // Incremented on click

  // Timestamps
  createdAt: Date;
  updatedAt: Date;

  // Virtuals
  isActiveNow: boolean; // Computed: active && expiresAt > now

  // Instance methods
  activate(): Promise<void>;
  deactivateIfExpired(): Promise<void>;
  recordImpression(): Promise<{ impressions: number }>;
  recordClick(): Promise<{ clicks: number }>;
}

export type BoostModel = MModel<IBoost> &
  CommonModelStatics<IBoost> & {
    /**
     * Get pricing for a boost type and duration
     * @param type - Boost type (FEATURED, PINNED, HIGHLIGHTED)
     * @param days - Duration in days (positive integer)
     * @returns Price in SAR
     * @throws Error if type is invalid or days is not a positive integer
     */
    getPricing(type: BoostType, days: number): number;

    /**
     * Atomically activate a boost by ID
     * @param id - Boost document ID
     * @returns Activated boost document
     * @throws Error if boost not found, already active, not paid, or conflicts with existing active boost
     */
    activateExclusive(id: mongoose.Types.ObjectId): Promise<IBoost>;

    /**
     * Find all active boosts for a listing, optionally filtered by type
     * @param orgId - Organization ID
     * @param listingId - Listing ID
     * @param type - Optional boost type filter
     * @returns Array of active boost documents (lean), sorted by expiresAt desc
     */
    findActiveFor(
      orgId: mongoose.Types.ObjectId,
      listingId: mongoose.Types.ObjectId,
      type?: BoostType,
    ): Promise<IBoost[]>;
  };

const BoostSchema = new Schema<IBoost>(
  {
    listingId: {
      type: Schema.Types.ObjectId,
      ref: "AqarListing",
      required: true,
      index: true,
    },
    orgId: {
      type: Schema.Types.ObjectId,
      ref: "Organization",
      required: true,
      index: true,
    },
    userId: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    type: {
      type: String,
      enum: Object.values(BoostType),
      required: true,
      index: true,
    },
    durationDays: {
      type: Number,
      required: true,
      min: 1,
      max: 730, // Maximum 2 years (730 days)
      validate: {
        validator: Number.isInteger,
        message: "Duration must be a whole number of days",
      },
    },

    price: {
      type: Number,
      required: true,
      min: 0,
      max: 999999.99, // Maximum reasonable price in SAR
      validate: {
        validator: (v: number) => Number.isFinite(v) && v >= 0,
        message: "Price must be a valid non-negative number",
      },
    },

    paymentId: { type: Schema.Types.ObjectId, ref: "Payment" },
    paidAt: { type: Date },

    activatedAt: { type: Date },
    expiresAt: { type: Date, index: true },
    active: { type: Boolean, default: false, index: true },

    impressions: { type: Number, default: 0, min: 0 },
    clicks: { type: Number, default: 0, min: 0 },
  },
  {
    timestamps: true,
    collection: "aqar_boosts",
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  },
);

/* ---------------- Indexes ---------------- */

// Query patterns: active boosts per listing (with expiry), user dashboards
BoostSchema.index({ orgId: 1, listingId: 1, active: 1, expiresAt: -1 });
BoostSchema.index({ orgId: 1, userId: 1, active: 1, createdAt: -1 });

/**
 * Hard no-overlap guarantee: at most ONE active boost of a given type for a listing per tenant.
 * This prevents multiple active FEATURED boosts on the same listing.
 *
 * **Note:** If you need to allow multiple active HIGHLIGHTED but single FEATURED/PINNED,
 * adjust the partial filter to: { active: true, type: { $in: ['FEATURED', 'PINNED'] } }
 */
BoostSchema.index(
  { orgId: 1, listingId: 1, type: 1, active: 1 },
  {
    unique: true,
    partialFilterExpression: { active: true },
    name: "uniq_active_boost_per_type",
  },
);

// =============================================================================
// DATA-001 FIX: Apply tenantIsolationPlugin for multi-tenant data isolation
// CRITICAL: Prevents cross-tenant data access in Aqar Marketplace boosts
// =============================================================================
BoostSchema.plugin(tenantIsolationPlugin);

/* ---------------- Static: Pricing ---------------- */

/**
 * Get pricing for boost type and duration
 * Configurable via environment variables (defaults in SAR/day)
 */
BoostSchema.statics.getPricing = function (type: BoostType, days: number) {
  if (!Object.values(BoostType).includes(type)) {
    throw new Error("Invalid boost type");
  }
  if (!Number.isInteger(days) || days <= 0) {
    throw new Error("Days must be a positive integer");
  }

  // Pricing configurable via environment variables with sensible defaults
  const perDay = {
    [BoostType.FEATURED]:
      Number(process.env.BOOST_FEATURED_PRICE_PER_DAY) || 100, // SAR/day
    [BoostType.PINNED]: Number(process.env.BOOST_PINNED_PRICE_PER_DAY) || 50, // SAR/day
    [BoostType.HIGHLIGHTED]:
      Number(process.env.BOOST_HIGHLIGHTED_PRICE_PER_DAY) || 25, // SAR/day
  } as const;
  return perDay[type] * days;
};

/* ---------------- Hooks ---------------- */

/**
 * Pre-validate: normalize duration and counters
 * Ensure duration is a positive integer, counters are non-negative
 */
BoostSchema.pre("validate", function (next) {
  // Normalize duration to positive integer
  if (typeof this.durationDays === "number") {
    this.durationDays = Math.max(1, Math.floor(this.durationDays));
  }
  // Normalize counters (ensure non-negative)
  if (typeof this.impressions === "number" && this.impressions < 0) {
    this.impressions = 0;
  }
  if (typeof this.clicks === "number" && this.clicks < 0) {
    this.clicks = 0;
  }

  next();
});

/**
 * Pre-save: auto-compute expiresAt from activatedAt + duration
 * If boost is active but expiresAt is missing, compute it
 * This ensures consistent expiry times even if activation logic is bypassed
 */
BoostSchema.pre("save", function (next) {
  // Keep expiresAt consistent: if active and duration is set but expiresAt missing => compute
  // If activatedAt is present, anchor from it, otherwise from now()
  if (this.active) {
    const anchor = this.activatedAt ? new Date(this.activatedAt) : new Date();
    const ms = Math.max(1, this.durationDays || 1) * 24 * 60 * 60 * 1000;
    this.activatedAt = anchor;
    this.expiresAt = new Date(anchor.getTime() + ms);
  }
  next();
});

/* ---------------- Virtuals ---------------- */

/**
 * Check if boost is currently active (active flag + not expired)
 * Used for UI display and filtering
 */
BoostSchema.virtual("isActiveNow").get(function (this: IBoost) {
  if (!this.active || !this.expiresAt) return false;
  return this.expiresAt > new Date();
});

/* ---------------- Methods ---------------- */

/**
 * Activate a boost (sets active flag, computes expiresAt)
 * Throws if already active, not paid, or conflicts with existing active boost
 * The unique index on (orgId, listingId, type, active: true) provides final race protection
 */
BoostSchema.methods.activate = async function (this: IBoost) {
  if (this.active) {
    throw new Error("Boost already activated");
  }
  if (!this.paidAt) {
    throw new Error("Boost not paid");
  }
  // Atomic activation with index guard (one active per listing/type/org)
  this.active = true;
  this.activatedAt = new Date();
  this.expiresAt = new Date(
    Date.now() + Math.max(1, this.durationDays) * 24 * 60 * 60 * 1000,
  );
  try {
    await this.save();
  } catch (err: unknown) {
    // Translate duplicate key error into user-friendly message
    const mongoError = err as { code?: number };
    if (mongoError.code === 11000) {
      throw new Error(
        "Another active boost of this type already exists for this listing",
      );
    }
    throw err;
  }
};

/**
 * Deactivate boost if expired
 * Used for cleanup jobs or on-demand expiry checks
 */
BoostSchema.methods.deactivateIfExpired = async function (this: IBoost) {
  if (this.active && this.expiresAt && this.expiresAt < new Date()) {
    this.active = false;
    await this.save();
  }
};

/**
 * Record an impression (view) for this boost
 * Uses atomic $inc to prevent race conditions
 * @returns Updated impressions count
 */
BoostSchema.methods.recordImpression = async function (this: IBoost) {
  const updated = await (this.constructor as BoostModel).findByIdAndUpdate(
    this._id,
    { $inc: { impressions: 1 } },
    { new: true, projection: { impressions: 1 } },
  );
  return { impressions: updated?.impressions ?? this.impressions + 1 };
};

/**
 * Record a click for this boost
 * Uses atomic $inc to prevent race conditions
 * @returns Updated clicks count
 */
BoostSchema.methods.recordClick = async function (this: IBoost) {
  const updated = await (this.constructor as BoostModel).findByIdAndUpdate(
    this._id,
    { $inc: { clicks: 1 } },
    { new: true, projection: { clicks: 1 } },
  );
  return { clicks: updated?.clicks ?? this.clicks + 1 };
};

/* ---------------- Statics ---------------- */

/**
 * Atomically activate a boost by ID
 * Wraps the activate() method for convenience
 */
BoostSchema.statics.activateExclusive = async function (
  id: mongoose.Types.ObjectId,
) {
  const doc = await this.findById(id);
  if (!doc) {
    throw new Error("Boost not found");
  }
  await doc.activate();
  return doc;
};

/**
 * Find all active boosts for a listing, optionally filtered by type
 * Filters by active flag and expiresAt > now for accurate results
 */
BoostSchema.statics.findActiveFor = function (
  orgId: mongoose.Types.ObjectId,
  listingId: mongoose.Types.ObjectId,
  type?: BoostType,
) {
  interface QueryFilter {
    orgId: mongoose.Types.ObjectId;
    listingId: mongoose.Types.ObjectId;
    active: boolean;
    expiresAt: { $gt: Date };
    type?: BoostType;
  }
  const q: QueryFilter = {
    orgId,
    listingId,
    active: true,
    expiresAt: { $gt: new Date() },
  };
  if (type) q.type = type;
  return this.find(q).sort({ expiresAt: -1 }).lean();
};

/* ---------------- Model Export ---------------- */

const Boost = getModel<IBoost>("AqarBoost", BoostSchema) as BoostModel;

export default Boost;
export type BoostDoc = HydratedDocument<IBoost>;

]]>
</file>

<file path="server/models/aqar/Favorite.ts">
<![CDATA[
/**
 * Aqar Souq - Favorite Model
 *
 * User bookmarks for listings and projects
 */

import mongoose, { Schema, Document, Model } from "mongoose";
import { getModel, MModel } from "@/types/mongoose-compat";
import { tenantIsolationPlugin } from "@/server/plugins/tenantIsolation";

export enum FavoriteType {
  LISTING = "LISTING",
  PROJECT = "PROJECT",
}

export interface IFavorite extends Document {
  // User
  userId: mongoose.Types.ObjectId;
  orgId: mongoose.Types.ObjectId;

  // Target
  targetId: mongoose.Types.ObjectId;
  targetType: FavoriteType;

  // Metadata
  notes?: string;
  tags?: string[];

  // Timestamps
  createdAt: Date;
  updatedAt: Date;
}

const FavoriteSchema = new Schema<IFavorite>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    orgId: {
      type: Schema.Types.ObjectId,
      ref: "Organization",
      required: true,
      index: true,
    },

    targetId: {
      type: Schema.Types.ObjectId,
      refPath: "targetType",
      required: true,
    },
    targetType: {
      type: String,
      enum: Object.values(FavoriteType),
      required: true,
      index: true,
    },

    notes: { type: String, maxlength: 1000 },
    tags: [{ type: String, maxlength: 50 }],
  },
  {
    timestamps: true,
    collection: "aqar_favorites",
  },
);

// Indexes
FavoriteSchema.index({ userId: 1, targetType: 1, createdAt: -1 });
FavoriteSchema.index(
  { userId: 1, targetId: 1, targetType: 1 },
  { unique: true },
); // Prevent duplicates

// =============================================================================
// DATA-001 FIX: Apply tenantIsolationPlugin for multi-tenant data isolation
// CRITICAL: Prevents cross-tenant data access in Aqar favorites
// =============================================================================
FavoriteSchema.plugin(tenantIsolationPlugin);

const Favorite = getModel<IFavorite>("AqarFavorite", FavoriteSchema);

export default Favorite;

]]>
</file>

</batch_content>
