
You are the "Fixzit Memory Builder" for category: "core".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "core",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="services/souq/returns-service.ts">
<![CDATA[
/**
 * Returns Service
 * Handles return merchandise authorization (RMA) workflow
 * - Auto-approval logic
 * - Return label generation
 * - Pickup scheduling
 * - Inspection workflow
 * - Refund processing
 */

import { SouqRMA as RMA } from "@/server/models/souq/RMA";
import { SouqOrder as Order } from "@/server/models/souq/Order";
import type { IOrder } from "@/server/models/souq/Order";
import { SouqListing as Listing } from "@/server/models/souq/Listing";
import { SouqSeller as Seller } from "@/server/models/souq/Seller";
import { inventoryService } from "./inventory-service";
import { fulfillmentService } from "./fulfillment-service";
import { Config } from "@/lib/config/constants";
import { addJob, QUEUE_NAMES, type QueueName } from "@/lib/queues/setup";
import { nanoid } from "nanoid";
import mongoose from "mongoose";
import { logger } from "@/lib/logger";
import { buildSouqOrgFilter } from "@/services/souq/org-scope";

/**
 * Contact information for notifications
 * üîí SECURITY: Fetched from Order/Seller models, not passed as IDs
 */
interface ContactInfo {
  email?: string;
  phone?: string;
}

// üîê STRICT v4.1: Use shared org filter helper for consistent tenant isolation
// Handles both orgId and legacy org_id fields with proper ObjectId matching
const buildOrgFilter = (orgId: string | mongoose.Types.ObjectId) =>
  buildSouqOrgFilter(orgId.toString()) as Record<string, unknown>;

// Helper type for accessing order properties safely
interface OrderWithDates extends IOrder {
  deliveredAt?: Date;
  updatedAt: Date;
}

interface InitiateReturnParams {
  orderId: string;
  buyerId: string;
  orgId: string;
  items: Array<{
    listingId: string;
    quantity: number;
    reason: 'defective' | 'damaged' | 'wrong_item' | 'not_as_described' | 'changed_mind' | 'better_price' | 'other';
    comments?: string;
  }>;
  buyerPhotos?: string[];
}

interface ApproveReturnParams {
  rmaId: string;
  adminId: string;
  approvalNotes?: string;
  orgId: string; // üîí Required for tenant isolation
}

interface InspectReturnParams {
  rmaId: string;
  inspectorId: string;
  condition: 'like_new' | 'good' | 'acceptable' | 'damaged' | 'defective';
  restockable: boolean;
  inspectionNotes?: string;
  inspectionPhotos?: string[];
  orgId: string; // üîí Required for tenant isolation
  session?: mongoose.ClientSession; // üîÑ Optional session for transactional consistency
  allowAutoRefund?: boolean; // üîê Optional: only true for system/finance flows
}

interface ProcessRefundParams {
  rmaId: string;
  refundAmount: number;
  refundMethod: 'original_payment' | 'wallet' | 'bank_transfer';
  processorId: string;
  orgId: string; // üîí Required for tenant isolation
  session?: mongoose.ClientSession; // üîÑ Optional session for transactional consistency
}

/**
 * üîÑ TRANSACTION SAFETY: Notification payloads to be fired AFTER transaction commits.
 * Prevents duplicate/phantom notifications on transaction retries.
 */
interface PendingNotification {
  queue: QueueName;
  jobType: string;
  payload: Record<string, unknown>;
  options?: { priority?: number };
}

const safeToString = (value: unknown): string =>
  value && typeof (value as { toString: () => string }).toString === 'function'
    ? (value as { toString: () => string }).toString()
    : String(value ?? '');

class ReturnsService {
  /**
   * Lookup buyer contact info from order
   * üîí SECURITY: Fetches actual email/phone, not ObjectIds
   */
  private async lookupBuyerContact(orderId: string, orgId: string): Promise<ContactInfo> {
    const order = await this.findOrder(orderId, orgId);
    if (!order) {
      logger.warn('[Returns] Order not found for buyer contact lookup', { orderId, orgId });
      return {};
    }
    return {
      email: order.customerEmail,
      phone: order.shippingAddress?.phone,
    };
  }

  /**
   * Lookup seller contact info
   * üîí SECURITY: Fetches actual email/phone from Seller model
   */
  private async lookupSellerContact(sellerId: string, orgId: string): Promise<ContactInfo> {
    const seller = await Seller.findOne({ 
      _id: sellerId, 
      ...buildOrgFilter(orgId) 
    }).select('contactEmail contactPhone').lean();
    if (!seller) {
      logger.warn('[Returns] Seller not found for contact lookup', { sellerId, orgId });
      return {};
    }
    return {
      email: seller.contactEmail,
      phone: seller.contactPhone,
    };
  }

  /**
   * Resolve seller for requested return items. Enforces single seller per RMA to avoid cross-seller returns.
   */
  private resolveSellerForItems(order: IOrder, items: InitiateReturnParams['items']): mongoose.Types.ObjectId {
    const sellerIds = new Set<string>();
    for (const item of items) {
      const orderItem = order.items.find((oi) => oi.listingId.toString() === item.listingId);
      if (!orderItem?.sellerId) {
        throw new Error(`Seller not found for listing ${item.listingId}`);
      }
      sellerIds.add(orderItem.sellerId.toString());
    }
    if (sellerIds.size !== 1) {
      throw new Error('Returns cannot span multiple sellers; split the request per seller');
    }
    const sellerId = Array.from(sellerIds)[0];
    return new mongoose.Types.ObjectId(sellerId);
  }

  /**
   * Check if an order item is eligible for return
   */
  async checkEligibility(
    orderId: string,
    listingId: string,
    orgId: string,
    preloadedOrder?: IOrder | null,
  ): Promise<{
    eligible: boolean;
    reason?: string;
    daysRemaining?: number;
  }> {
    if (!orgId) {
      return { eligible: false, reason: 'Organization context required' };
    }

    const order = preloadedOrder ?? (await this.findOrder(orderId, orgId));
    if (!order) {
      return { eligible: false, reason: 'Order not found' };
    }
    const orderOrgId = order.orgId ? order.orgId.toString() : undefined;

    if (order.status !== 'delivered') {
      return { eligible: false, reason: 'Order not yet delivered' };
    }

    // Check return window (30 days from delivery)
    const orderWithDates = order as OrderWithDates;
    const deliveryDate = orderWithDates.deliveredAt || orderWithDates.updatedAt;
    if (!deliveryDate) {
      return { eligible: false, reason: 'Delivery date unavailable' };
    }
    const daysSinceDelivery = Math.floor((Date.now() - deliveryDate.getTime()) / (1000 * 60 * 60 * 24));
    const returnWindow = 30;

    if (daysSinceDelivery > returnWindow) {
      return { eligible: false, reason: 'Return window expired (30 days)' };
    }

    // Check if already returned
    const orgScope = orderOrgId ? buildOrgFilter(orderOrgId) : buildOrgFilter(orgId);
    const existingRMA = await RMA.findOne({ 
      orderId: order._id.toString(), 
      'items.listingId': listingId,
      status: { $in: ['initiated', 'approved', 'in_transit', 'received', 'inspected'] },
      ...orgScope,
    }).lean();

    if (existingRMA) {
      return { eligible: false, reason: 'Return already in progress for this item' };
    }

    return { 
      eligible: true, 
      daysRemaining: returnWindow - daysSinceDelivery 
    };
  }

  /**
   * Initiate a return request
   */
  async initiateReturn(params: InitiateReturnParams): Promise<string> {
    const { orderId, buyerId, items, buyerPhotos, orgId } = params;

    if (!orgId) {
      throw new Error('orgId is required to initiate return');
    }

    // Validate order within tenant scope
    const order = await this.findOrder(orderId, orgId);
    if (!order) {
      throw new Error('Order not found');
    }
    const orderOrgId = order.orgId ? order.orgId.toString() : undefined;
    if (orderOrgId && orderOrgId !== orgId) {
      throw new Error('Order does not belong to the provided organization');
    }

    if (order.customerId.toString() !== buyerId) {
      throw new Error('Unauthorized: Not your order');
    }

    const sellerId = this.resolveSellerForItems(order, items);

    // Validate eligibility for all items
    for (const item of items) {
      const eligibility = await this.checkEligibility(orderId, item.listingId, orgId, order);
      if (!eligibility.eligible) {
        throw new Error(`Item ${item.listingId} not eligible: ${eligibility.reason}`);
      }
    }

    // Build RMA items using order line data to satisfy schema requirements
    const rmaItems = items.map((item) => {
      const orderItem = order.items.find((oi) => oi.listingId.toString() === item.listingId);
      if (!orderItem) {
        throw new Error(`Item ${item.listingId} not found on order`);
      }

      return {
        orderItemId: orderItem.listingId.toString(),
        listingId: orderItem.listingId.toString(),
        productId: orderItem.productId.toString(),
        productName: orderItem.title,
        quantity: item.quantity,
        unitPrice: orderItem.pricePerUnit,
        reason: item.reason,
        returnReason: this.mapReturnReason(item.reason),
      };
    });

    const refundAmount = rmaItems.reduce(
      (sum, item) => sum + (item.unitPrice * item.quantity),
      0
    );

    const orderWithDates = order as OrderWithDates;
    const deliveryDate = orderWithDates.deliveredAt || orderWithDates.updatedAt || new Date();
    const returnWindowDays = 30;
    const returnDeadline = new Date(deliveryDate);
    returnDeadline.setDate(returnDeadline.getDate() + returnWindowDays);

    // Create RMA
    const rma = await RMA.create({
      rmaId: `RMA-${nanoid(10)}`,
      orgId,
      orderId: order._id.toString(),
      orderNumber: order.orderId,
      buyerId,
      sellerId: sellerId.toString(),
      items: rmaItems,
      status: 'initiated',
      returnWindowDays,
      returnDeadline,
      refund: {
        amount: refundAmount,
        method: 'original_payment',
        status: 'pending'
      },
      shipping: { shippingCost: 0, paidBy: 'seller' },
      buyerNotes: items
        .map((item) => item.comments)
        .filter(Boolean)
        .join('; ') || undefined,
      buyerPhotos: buyerPhotos || [],
      timeline: [{
        status: 'initiated',
        timestamp: new Date(),
        note: 'Return request submitted by buyer'
      }]
    });

    // Auto-approval logic
    const autoApprovalReasons = ['defective', 'damaged', 'wrong_item', 'not_as_described'];
    const allAutoApprove = items.every(item => autoApprovalReasons.includes(item.reason));

    if (allAutoApprove) {
      await this.autoApprove({ rmaId: rma._id.toString(), orgId });
    }

    // Notify seller - fetch actual contact info
    const sellerContact = await this.lookupSellerContact(sellerId.toString(), orgId);
    if (sellerContact.email) {
      await addJob(QUEUE_NAMES.NOTIFICATIONS, 'send-email', {
        type: 'email',
        to: sellerContact.email,
        orgId,
        template: 'return_initiated',
        data: { rmaId: rma._id.toString(), orderId, items }
      });
    } else {
      logger.warn('[Returns] Seller email not found, skipping notification', { sellerId: sellerId.toString(), orgId });
    }

    return rma._id.toString();
  }

  /**
   * Auto-approve return (for defective/damaged items)
   * üîí SECURITY: orgId required for tenant isolation
   */
  private async autoApprove({ rmaId, orgId }: { rmaId: string; orgId: string }): Promise<void> {
    if (!orgId) {
      throw new Error('orgId is required for auto-approve');
    }
    const rma = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
    if (!rma) return;

    await rma.approve('SYSTEM', 'Auto-approved: Defective or damaged item');
    
    // Generate return label
    await this.generateReturnLabel(rmaId, orgId);
  }

  /**
   * Manually approve return (admin action)
   * 
   * RACE CONDITION FIX: Uses atomic findOneAndUpdate to prevent double-approval.
   * üîí SECURITY: orgId required for tenant isolation
   */
  async approveReturn(params: ApproveReturnParams): Promise<void> {
    const { rmaId, adminId, approvalNotes, orgId } = params;

    if (!orgId) {
      throw new Error('orgId is required for approve return');
    }

    const now = new Date();

    // ATOMIC STATUS TRANSITION: Only one concurrent request can succeed
    // üîí SECURITY: Always scope by orgId for tenant isolation
    const rma = await RMA.findOneAndUpdate(
      { 
        _id: rmaId,
        ...buildOrgFilter(orgId),  // üîí Tenant isolation (string/ObjectId safe)
        status: 'initiated'  // Atomic condition - prevents double-approval
      },
      { 
        $set: { 
          status: 'approving',  // Intermediate state to block concurrent requests
        },
        $push: {
          timeline: {
            status: 'approving',
            timestamp: now,
            note: `Approval initiated by ${adminId}`,
            performedBy: adminId,
          }
        }
      },
      { new: true }
    );

    if (!rma) {
      const existing = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) }).lean();
      if (!existing) {
        throw new Error('RMA not found');
      }
      throw new Error(`Cannot approve RMA: already in status '${existing.status}' (expected 'initiated')`);
    }

    await rma.approve(adminId, approvalNotes);
    
    // Generate return label
    await this.generateReturnLabel(rmaId, orgId);

    // Notify buyer - fetch actual contact info
    const buyerContact = await this.lookupBuyerContact(rma.orderId, orgId);
    if (buyerContact.email) {
      await addJob(QUEUE_NAMES.NOTIFICATIONS, 'send-email', {
        type: 'email',
        to: buyerContact.email,
        orgId,
        template: 'return_approved',
        data: { rmaId, returnLabel: rma.shipping?.labelUrl }
      });
    } else {
      logger.warn('[Returns] Buyer email not found, skipping notification', { rmaId, orderId: rma.orderId, orgId });
    }
  }

  /**
   * Reject return request
   * 
   * RACE CONDITION FIX: Uses atomic findOneAndUpdate to prevent double-rejection.
   * üîí SECURITY: orgId required for tenant isolation
   */
  async rejectReturn(rmaId: string, adminId: string, rejectionReason: string, orgId: string): Promise<void> {
    if (!orgId) {
      throw new Error('orgId is required for reject return');
    }

    const now = new Date();

    // ATOMIC STATUS TRANSITION: Only one concurrent request can succeed
    // üîí SECURITY: Always scope by orgId for tenant isolation
    const rma = await RMA.findOneAndUpdate(
      { 
        _id: rmaId,
        ...buildOrgFilter(orgId),  // üîí Tenant isolation (string/ObjectId safe)
        status: 'initiated'  // Atomic condition - prevents double-rejection
      },
      { 
        $set: { 
          status: 'rejecting',  // Intermediate state to block concurrent requests
        },
        $push: {
          timeline: {
            status: 'rejecting',
            timestamp: now,
            note: `Rejection initiated by ${adminId}`,
            performedBy: adminId,
          }
        }
      },
      { new: true }
    );

    if (!rma) {
      const existing = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) }).lean();
      if (!existing) {
        throw new Error('RMA not found');
      }
      throw new Error(`Cannot reject RMA: already in status '${existing.status}' (expected 'initiated')`);
    }

    await rma.reject(adminId, rejectionReason);

    // Notify buyer - fetch actual contact info
    const buyerContact = await this.lookupBuyerContact(rma.orderId, orgId);
    if (buyerContact.email) {
      await addJob(QUEUE_NAMES.NOTIFICATIONS, 'send-email', {
        type: 'email',
        to: buyerContact.email,
        orgId,
        template: 'return_rejected',
        data: { rmaId, reason: rejectionReason }
      });
    } else {
      logger.warn('[Returns] Buyer email not found, skipping rejection notification', { rmaId, orderId: rma.orderId, orgId });
    }
  }

  /**
   * Generate return shipping label
   * üîí SECURITY: orgId required for tenant isolation
   */
  async generateReturnLabel(rmaId: string, orgId: string): Promise<{
    trackingNumber: string;
    labelUrl: string;
    carrier: string;
  }> {
    if (!orgId) {
      throw new Error('orgId is required for generate return label');
    }

    const rma = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
    if (!rma) {
      throw new Error('RMA not found');
    }

    // üîí SECURITY: Use RMA's orgId for tenant-scoped order lookup
    const rmaOrgId = rma.orgId ? rma.orgId.toString() : undefined;
    if (!rmaOrgId) {
      throw new Error('orgId missing on RMA; cannot generate return label');
    }
    const order = await this.findOrder(rma.orderId, rmaOrgId);
    if (!order) {
      logger.error(
        "RMA return label generation failed: order not found",
        undefined,
        {
          rmaId: rma._id?.toString?.(),
          orderId: rma.orderId?.toString?.(),
          buyerId: rma.buyerId?.toString?.(),
          orgId: rmaOrgId,
          metric: "returns.order_missing",
        },
      );
      throw new Error(`Order not found for RMA ${rma.orderId}`);
    }
    
    const firstItem = Array.isArray(rma.items) ? rma.items[0] : undefined;
    if (!firstItem?.listingId) {
      throw new Error('RMA missing items; cannot generate return label');
    }

    // Get seller's address (or warehouse for FBF) with tenant isolation
    const listing = await Listing.findOne({
      _id: firstItem.listingId,
      ...buildOrgFilter(rmaOrgId),
    });
    if (!listing) {
      throw new Error("Listing not found for org; cannot generate return label");
    }
    // warehouseLocation is a string field, not an address object
    const origin = {
      name: Config.returns.originName,
      street: Config.returns.originStreet,
      city: listing?.warehouseLocation || Config.returns.originCity,
      state: Config.returns.originState,
      postalCode: Config.returns.originPostalCode,
      country: Config.returns.originCountry,
    };

    // Calculate total weight
    const totalWeight = rma.items.reduce((sum: number, item: unknown) => sum + ((item as { quantity: number }).quantity * 0.5), 0);

    // Generate label via carrier (use SPL for returns - most affordable)
    const shippingAddress = order.shippingAddress as { name?: string; street?: string; city?: string; state?: string; postalCode?: string; country?: string };
    const labelRequest = {
      origin: `${shippingAddress.city || 'Riyadh'}, ${shippingAddress.state || 'Riyadh Province'}`,
      destination: `${origin.city}, ${origin.state}`,
      weight: totalWeight,
      dimensions: { length: 30, width: 20, height: 15, unit: 'cm' },
      serviceType: 'standard' as const,
      description: `Return for Order ${order._id}`,
      declaredValue: rma.items.reduce((sum: number, item: unknown) => sum + ((item as { quantity: number }).quantity * 100), 0), // Estimate
      codAmount: 0
    };

    const rates = await fulfillmentService.getRates(labelRequest);
    const splRate = rates.find(r => r.carrier === 'SPL') || rates[0];
    if (!splRate) {
      throw new Error('No return shipping rates available');
    }
    const shippingCost = typeof (splRate as { cost?: unknown }).cost === 'number'
      ? (splRate as { cost: number }).cost
      : 0;

    // In production, this would call the actual carrier API
    const baseLabelUrl =
      (Config.returns.labelBaseUrl || Config.app.url || "http://localhost:3000").replace(/\/+$/, "");
    const label = {
      trackingNumber: `RET-${Date.now()}-${rma._id.toString().slice(-6).toUpperCase()}`,
      labelUrl: `${baseLabelUrl}/returns/labels/${rma._id}.pdf`,
      carrier: splRate.carrier
    };

    // Update RMA status + timeline using model helper, then persist shipping cost
    rma.generateLabel(label.carrier, label.trackingNumber, label.labelUrl);
    rma.shipping = {
      ...(rma.shipping || { paidBy: "seller" }),
      shippingCost,
      carrier: label.carrier,
      trackingNumber: label.trackingNumber,
      labelUrl: label.labelUrl,
    };
    await rma.save();

    return label;
  }

  /**
   * Schedule pickup for return
   * üîí SECURITY: orgId required for tenant isolation
   */
  async schedulePickup(rmaId: string, pickupDate: Date, timeSlot: 'morning' | 'afternoon' | 'evening', orgId: string): Promise<void> {
    if (!orgId) {
      throw new Error('orgId is required for schedule pickup');
    }

    const rma = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
    if (!rma) {
      throw new Error('RMA not found');
    }

    if (!rma.shipping?.labelUrl) {
      throw new Error('Return label not generated yet');
    }

    // In production, schedule via carrier API
    // For now, just update RMA
    rma.timeline.push({
      status: 'pickup_scheduled',
      timestamp: new Date(),
      note: `Pickup scheduled for ${pickupDate.toLocaleDateString()} ${timeSlot}`
    });
    await rma.save();

    // Notify buyer via SMS - fetch actual phone number
    const buyerContact = await this.lookupBuyerContact(rma.orderId, orgId);
    if (buyerContact.phone) {
      await addJob(QUEUE_NAMES.NOTIFICATIONS, 'send-sms', {
        type: 'sms',
        to: buyerContact.phone,
        orgId, // üîê Tenant-specific routing
        message: `Pickup scheduled for your return (RMA ${rmaId}) on ${pickupDate.toLocaleDateString()} ${timeSlot}`
      });
    } else {
      logger.warn('[Returns] Buyer phone not found, skipping SMS notification', { rmaId, orderId: rma.orderId, orgId });
    }
  }

  /**
   * Update return tracking (called by carrier webhook)
   * üîí SECURITY: orgId required for tenant isolation
   */
  async updateTracking(rmaId: string, status: string, location: string | undefined, orgId: string): Promise<void> {
    if (!orgId) {
      throw new Error('orgId is required for update tracking');
    }

    const rma = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
    if (!rma) {
      throw new Error('RMA not found');
    }

    // Map carrier status to RMA status
    const statusMap: Record<string, typeof rma.status> = {
      'picked_up': 'in_transit',
      'in_transit': 'in_transit',
      'out_for_delivery': 'in_transit',
      'delivered': 'received',
      'arrived': 'received'
    };

    const newStatus = statusMap[status] || rma.status;

    if (newStatus !== rma.status) {
      rma.status = newStatus;
      rma.timeline.push({
        status: newStatus,
        timestamp: new Date(),
        note: location ? `Package ${status} at ${location}` : `Package ${status}`
      });
      await rma.save();

      // If received, queue for inspection
      if (newStatus === 'received') {
        await addJob(QUEUE_NAMES.NOTIFICATIONS, 'internal-notification', {
          type: 'internal',
          to: 'inspection-team',
          orgId: rma.orgId?.toString(), // üîê SECURITY: Include orgId for tenant-scoped notification routing
          message: `RMA ${rmaId} received and ready for inspection`
        });
      }
    }
  }

  /**
   * Inspect returned item
   * 
   * RACE CONDITION FIX: Uses atomic findOneAndUpdate to prevent concurrent inspections.
   * Only one inspection can succeed for an RMA in 'received' status.
   * üîê SECURITY: orgId required for tenant isolation
   * 
   * TRANSACTION: Wraps RMA update, inventory adjustment, and refund in a MongoDB session
   * to ensure atomic rollback if any step fails. Prevents stuck "inspected/processing" states.
   * 
   * üîÑ TRANSACTION SAFETY: Notifications are collected during transaction and fired ONLY after commit.
   * This prevents duplicate/phantom notifications on transaction retries or aborts.
   */
  async inspectReturn(params: InspectReturnParams): Promise<void> {
    const { rmaId, inspectorId, condition, restockable, inspectionNotes, inspectionPhotos, orgId, allowAutoRefund = false } = params;

    if (!orgId) {
      throw new Error('orgId is required for inspect return');
    }

    const now = new Date();
    
    // Start a MongoDB session for transactional consistency
    const session = await mongoose.startSession();
    
    // üîÑ TRANSACTION SAFETY: Collect notifications to fire after successful commit
    let pendingNotifications: PendingNotification[] = [];
    
    try {
      await session.withTransaction(async () => {
        pendingNotifications = await this.executeInspection({
          rmaId,
          inspectorId,
          condition,
          restockable,
          inspectionNotes,
          inspectionPhotos,
          orgId,
          now,
          session,
          allowAutoRefund,
        });
      });
      
      // üîÑ TRANSACTION SAFETY: Fire notifications ONLY after successful commit
      await this.fireNotifications(pendingNotifications);
    } catch (error) {
      // Fallback for environments without replica set (e.g., unit tests using standalone Mongo)
      if (error instanceof Error && error.message.includes('Transaction numbers are only allowed')) {
        pendingNotifications = await this.executeInspection({
          rmaId,
          inspectorId,
          condition,
          restockable,
          inspectionNotes,
          inspectionPhotos,
          orgId,
          now,
          allowAutoRefund,
          session: undefined,
        });
        // Fire notifications after non-transactional execution
        await this.fireNotifications(pendingNotifications);
      } else {
        throw error;
      }
    } finally {
      await session.endSession();
    }
  }
  
  /**
   * üîÑ TRANSACTION SAFETY: Fire collected notifications after transaction commits.
   * Makes notification delivery idempotent-safe with respect to transaction retries.
   * Public so routes can call this after getting notifications from processRefund.
   */
  async fireNotifications(notifications: PendingNotification[]): Promise<void> {
    for (const notification of notifications) {
      await addJob(notification.queue, notification.jobType, notification.payload, notification.options);
    }
  }
  
  /**
   * Internal: Execute inspection within a transaction session
   * Returns pending notifications to be fired after transaction commits
   */
  private async executeInspection(params: {
    rmaId: string;
    inspectorId: string;
    condition: 'like_new' | 'good' | 'acceptable' | 'damaged' | 'defective';
    restockable: boolean;
    inspectionNotes?: string;
    inspectionPhotos?: string[];
    orgId: string;
    now: Date;
    session?: mongoose.ClientSession;
    allowAutoRefund?: boolean;
  }): Promise<PendingNotification[]> {
    const { rmaId, inspectorId, condition, restockable, inspectionNotes, inspectionPhotos, orgId, now, session, allowAutoRefund } = params;

    // üîÑ TRANSACTION SAFETY: Collect notifications to return (not fire directly)
    const pendingNotifications: PendingNotification[] = [];

    // ATOMIC STATUS TRANSITION: Only one concurrent request can succeed
    // üîê SECURITY: orgId scoping ensures tenant isolation
    // üîÑ TRANSACTION: Uses session for atomic rollback
    const rma = await RMA.findOneAndUpdate(
      { 
        _id: rmaId, 
        ...buildOrgFilter(orgId),  // üîê Tenant isolation (string/ObjectId safe)
        status: 'received'  // Atomic condition - prevents double-inspection
      },
      { 
        $set: { 
          status: 'inspecting',  // Intermediate state to block concurrent requests
        },
        $push: {
          timeline: {
            status: 'inspecting',
            timestamp: now,
            note: `Inspection started by ${inspectorId}`,
            performedBy: inspectorId,
          }
        }
      },
      session ? { new: true, session } : { new: true }
    );

    if (!rma) {
      const existingQuery = RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
      const existing = session ? await existingQuery.session(session).lean() : await existingQuery.lean();
      if (!existing) {
        throw new Error('RMA not found');
      }
      throw new Error(`Cannot inspect RMA: already in status '${existing.status}' (expected 'received')`);
    }

    const rmaDoc = rma as unknown as {
      completeInspection?: (...args: unknown[]) => Promise<unknown> | unknown;
      save?: () => Promise<unknown>;
      timeline?: unknown[];
      inspection?: unknown;
      refund?: { status?: string; amount?: number; method?: string };
      status: string;
    };

    if (typeof rmaDoc.completeInspection === 'function') {
      await rmaDoc.completeInspection(
        inspectorId,
        condition,
        true,
        restockable,
        inspectionNotes || '',
        inspectionPhotos
      );
    } else {
      // Fallback for mocked models without instance methods
      const timeline = Array.isArray(rmaDoc.timeline) ? [...rmaDoc.timeline] : [];
      timeline.push({
        status: 'inspection_complete',
        timestamp: now,
        note: `Condition: ${condition}, Approved: true`,
        performedBy: inspectorId,
      });
      rmaDoc.timeline = timeline;
      rmaDoc.inspection = {
        inspectedAt: now,
        inspectedBy: inspectorId,
        condition,
        notes: inspectionNotes || '',
        approved: true,
        restockable,
        photosUrls: inspectionPhotos,
      };
      rmaDoc.status = 'inspected';
      const inspectionRefundStatus = allowAutoRefund ? 'processing' : 'pending';
      if (rmaDoc.refund) {
        rmaDoc.refund.status = inspectionRefundStatus;
      } else {
        rmaDoc.refund = {
          status: inspectionRefundStatus,
          amount: 0,
          method: 'original_payment',
        };
      }
    }
    // Save the updated RMA document
    await rma.save(session ? { session } : undefined);

    // Always adjust inventory so unsellable units are tracked correctly.
    // üîê SECURITY: Pass orgId for tenant-scoped inventory lookup/update
    for (const item of rma.items) {
      await inventoryService.processReturn({
        listingId: item.listingId.toString(),
        rmaId,
        quantity: item.quantity,
        condition: restockable ? 'sellable' : 'unsellable',
        orgId,  // Ensures tenant isolation in inventory updates
        session,
      });
    }

    // Calculate refund amount
    const refundAmount = await this.calculateRefundAmount(rmaId, condition, restockable, orgId, session);

    // If nothing is refundable, close the RMA to avoid stuck "inspected" states
    if (refundAmount <= 0) {
      const transactionId = `REF-${Date.now()}-${rma._id.toString().slice(-6)}`;
      const timeline = Array.isArray(rma.timeline) ? rma.timeline : [];
      timeline.push({
        status: 'completed',
        timestamp: now,
        note: 'No refund due after inspection; closing RMA',
        performedBy: inspectorId,
      });

      rma.timeline = timeline;
      rma.status = 'completed';
      rma.completedAt = now;
      rma.refund = {
        amount: 0,
        method: 'original_payment',
        processedBy: inspectorId,
        processedAt: now,
        transactionId,
        status: 'completed',
      };
      await rma.save(session ? { session } : undefined);
      return pendingNotifications;
    }
    
    // Auto-process refund for approved returns (within transaction)
    // üîÑ TRANSACTION SAFETY: Collect refund notifications to merge with inspection notifications
    if (refundAmount > 0 && allowAutoRefund) {
      const refundNotifications = await this.processRefund({
        rmaId,
        refundAmount,
        refundMethod: 'original_payment',
        processorId: inspectorId,
        orgId,
        session,
      });
      pendingNotifications.push(...refundNotifications);
    }
    
    return pendingNotifications;
  }

  /**
   * Calculate refund amount based on inspection
   * 
   * Public to allow server-side validation in refund routes.
   * Prevents over-refunds by computing max allowed amount from inspection results.
   */
  public async calculateRefundAmount(
    rmaId: string,
    condition: string,
    restockable: boolean,
    orgId: string,
    session?: mongoose.ClientSession
  ): Promise<number> {
    if (!orgId) {
      return 0;
    }

    const rmaQuery = RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
    const rma = session ? await rmaQuery.session(session) : await rmaQuery;
    if (!rma) return 0;

    // üîí SECURITY: Use RMA's orgId for tenant-scoped order lookup
    const rmaOrgId = rma.orgId ? rma.orgId.toString() : undefined;
    if (!rmaOrgId) {
      return 0;
    }
    // üîÑ TRANSACTION: Pass session for consistent snapshot within transaction
    const order = await this.findOrder(rma.orderId, rmaOrgId, session);
    if (!order) return 0;

    return this.computeRefundAmount(order, rma.items, condition, restockable);
  }

  /**
   * Derive refundable amount directly from an RMA document (uses recorded inspection data).
   */
  private async calculateRefundAmountFromRmaDoc(
    rma: {
      orderId: mongoose.Types.ObjectId | string;
      items: Array<{ listingId: mongoose.Types.ObjectId | string; quantity: number }>;
      inspection?: { condition?: string; restockable?: boolean };
      orgId?: string | mongoose.Types.ObjectId;
    },
    orgId: string,
    session?: mongoose.ClientSession
  ): Promise<number> {
    if (!orgId) {
      return 0;
    }
    const rmaOrgId = rma.orgId ? rma.orgId.toString() : orgId;
    const condition = rma.inspection?.condition || 'good';
    const restockable = rma.inspection?.restockable ?? true;
    const order = await this.findOrder(rma.orderId.toString(), rmaOrgId, session);
    if (!order) return 0;
    return this.computeRefundAmount(order, rma.items, condition, restockable);
  }

  /**
   * Pure calculation for refund amount based on order + RMA items.
   */
  private computeRefundAmount(
    order: IOrder,
    rmaItems: Array<{ listingId: mongoose.Types.ObjectId | string; quantity: number }>,
    condition: string,
    restockable: boolean
  ): number {
    // Base refund: original item price
    let refundAmount = 0;
    for (const item of rmaItems) {
      const orderItem = order.items.find((oi) =>
        oi.listingId.toString() === item.listingId.toString()
      );
      if (orderItem) {
        refundAmount += orderItem.pricePerUnit * item.quantity;
      }
    }

    // Deduct restocking fee if not restockable
    if (!restockable) {
      refundAmount *= 0.8; // 20% restocking fee
    }

    // Deduct based on condition
    const conditionDeductions: Record<string, number> = {
      'like_new': 0,
      'good': 0.05,
      'acceptable': 0.15,
      'damaged': 0.3,
      'defective': 0
    };

    const deduction = conditionDeductions[condition] || 0;
    refundAmount *= (1 - deduction);

    return Math.round(refundAmount * 100) / 100; // Round to 2 decimals
  }

  /**
   * Public helper to fetch the refundable amount for an RMA with org scoping.
   */
  async getRefundableAmount(
    rmaId: string,
    orgId: string,
    session?: mongoose.ClientSession
  ): Promise<number> {
    if (!orgId) {
      throw new Error('orgId is required to fetch refundable amount');
    }
    const rmaQuery = RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) });
    const rma = session ? await rmaQuery.session(session) : await rmaQuery;
    if (!rma) {
      throw new Error('RMA not found');
    }
    return this.calculateRefundAmountFromRmaDoc(rma, orgId, session);
  }

  /**
   * Process refund
   * 
   * RACE CONDITION FIX: Uses atomic findOneAndUpdate to prevent double-processing.
   * The status transition from 'inspected' to 'refund_processing' is atomic,
   * so concurrent calls will fail safely instead of processing twice.
   * 
   * üîÑ TRANSACTION: Supports optional session for transactional consistency with inspection flow.
   * üîÑ TRANSACTION SAFETY: Returns notifications to be fired after transaction commits.
   */
  async processRefund(params: ProcessRefundParams): Promise<PendingNotification[]> {
    const { rmaId, refundAmount, refundMethod, processorId, orgId, session } = params;

    if (!orgId) {
      throw new Error('orgId is required to process refund');
    }

    // üîÑ TRANSACTION SAFETY: Collect notifications to return (not fire directly)
    const pendingNotifications: PendingNotification[] = [];

    const now = new Date();
    const transactionId = `REF-${Date.now()}-${rmaId.slice(-6)}`;

    // üîí SECURITY: Pre-fetch RMA to get orderId and sellerId for contact lookups
    const rmaPrecheck = await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) }).lean();
    if (!rmaPrecheck) {
      throw new Error('RMA not found');
    }

    // üìß PRE-FETCH CONTACTS: Lookup actual email/phone before transaction to avoid sending to ObjectIds
    const [buyerContact, sellerContact] = await Promise.all([
      this.lookupBuyerContact(rmaPrecheck.orderId, orgId),
      this.lookupSellerContact(rmaPrecheck.sellerId, orgId),
    ]);

    // ATOMIC STATUS TRANSITION: Only one concurrent request can succeed
    // If status is not 'inspected', the update returns null (already processed or wrong state)
    // üîÑ TRANSACTION: Uses session if provided for atomic rollback
    const rma = await RMA.findOneAndUpdate(
      { 
        _id: rmaId,
        ...buildOrgFilter(orgId),
        status: 'inspected'  // Atomic condition - prevents double-processing
      },
      { 
        $set: { 
          status: 'refund_processing',  // Intermediate state to block concurrent requests
          'refund.status': 'processing',
          'refund.amount': refundAmount,
          'refund.method': refundMethod,
        },
        $push: {
          timeline: {
            status: 'refund_processing',
            timestamp: now,
            note: 'Refund processing initiated',
            performedBy: processorId,
          }
        }
      },
      { new: true, session }
    );

    if (!rma) {
      // Either RMA doesn't exist or it's not in 'inspected' status (already processing/completed)
      const existing = session 
        ? await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) }).session(session).lean()
        : await RMA.findOne({ _id: rmaId, ...buildOrgFilter(orgId) }).lean();
      if (!existing) {
        throw new Error('RMA not found');
      }
      // Provide clear error message about current state
      throw new Error(`Cannot refund RMA: already in status '${existing.status}' (expected 'inspected')`);
    }

    // Validate/cap refund amount against computed maximum based on inspection + order
    const allowedRefundAmount = await this.calculateRefundAmountFromRmaDoc(rma, orgId, session);
    if (allowedRefundAmount <= 0) {
      throw new Error('No refundable amount available for this RMA');
    }
    if (refundAmount > allowedRefundAmount) {
      throw new Error(`Refund amount exceeds allowed maximum (${allowedRefundAmount})`);
    }
    const finalRefundAmount = refundAmount;

    const refundData = {
      amount: finalRefundAmount,
      method: refundMethod,
      processedBy: processorId,
      processedAt: now,
      status: 'completed' as const,
      transactionId,
    };

    // Complete the refund (this is the actual processing step)
    const rmaRefundDoc = rma as unknown as {
      completeRefund?: (data: typeof refundData) => Promise<unknown> | unknown;
      save?: () => Promise<unknown>;
      refund?: typeof refundData;
      status?: string;
      completedAt?: Date;
    };

    if (typeof rmaRefundDoc.completeRefund === 'function') {
      await rmaRefundDoc.completeRefund(refundData);
    } else {
      // Fallback for mocked models without instance methods
      rmaRefundDoc.refund = {
        ...refundData,
        method: refundMethod,
      };
      rmaRefundDoc.status = 'completed';
      rmaRefundDoc.completedAt = refundData.processedAt;
    }
    // Save the final completed state (within transaction if session provided)
    await rma.save(session ? { session } : undefined);

    // üìß FIXED: Use pre-fetched contact info instead of ObjectIds
    if (buyerContact.email) {
      const buyerNotification: PendingNotification = {
        queue: QUEUE_NAMES.NOTIFICATIONS,
        jobType: 'send-email',
        payload: { 
          type: 'email',
          to: buyerContact.email,
          orgId,
          template: 'refund_processed',
          data: { 
            rmaId, 
            amount: finalRefundAmount, 
            method: refundMethod,
            estimatedDays: refundMethod === 'original_payment' ? '3-5' : '1-2'
          }
        }
      };
      // üîÑ TRANSACTION SAFETY: Collect notifications, don't fire inside transaction
      pendingNotifications.push(buyerNotification);
    } else {
      logger.warn('[Returns] Buyer email not found, skipping refund notification', { rmaId, orgId });
    }

    if (rma.inspection?.restockable === false && sellerContact.email) {
      const sellerNotification: PendingNotification = {
        queue: QUEUE_NAMES.NOTIFICATIONS,
        jobType: 'send-email',
        payload: {
          type: 'email',
          to: sellerContact.email,
          orgId,
          template: 'return_completed',
          data: { rmaId, restockingFee: finalRefundAmount * 0.25 }
        }
      };

      // üîÑ TRANSACTION SAFETY: Collect notifications, don't fire inside transaction
      pendingNotifications.push(sellerNotification);
    } else if (rma.inspection?.restockable === false) {
      logger.warn('[Returns] Seller email not found, skipping completion notification', { rmaId, orgId });
    }

    return pendingNotifications;
  }

  /**
   * Get return statistics for a seller
   */
  async getSellerReturnStats(
    sellerId: string,
    orgId: string,
    period: 'week' | 'month' | 'year' = 'month',
  ): Promise<{
    totalReturns: number;
    returnRate: number;
    topReasons: Array<{ reason: string; count: number }>;
    avgRefundAmount: number;
    restockableRate: number;
  }> {
    if (!orgId) {
      throw new Error('orgId is required to fetch seller return stats');
    }

    if (!mongoose.Types.ObjectId.isValid(sellerId)) {
      throw new Error('Invalid sellerId');
    }
    const sellerObjectId = new mongoose.Types.ObjectId(sellerId);

    const periodDays = period === 'week' ? 7 : period === 'month' ? 30 : 365;
    const startDate = new Date(Date.now() - periodDays * 24 * 60 * 60 * 1000);

    // üí° OPTIMIZATION: Use .lean() for read-only stats query
    const returns = await RMA.find({
      sellerId: sellerId.toString(),
      createdAt: { $gte: startDate },
      ...buildOrgFilter(orgId),
    }).lean().catch(async (err) => {
      // Graceful fallback for mocked/missing lean in tests
      void err;
      const result = await RMA.find({
        sellerId: sellerId.toString(),
        createdAt: { $gte: startDate },
        ...buildOrgFilter(orgId),
      });
      return Array.isArray(result) ? result : [];
    });

    const totalReturns = returns.length;

    // Calculate return rate (returns / total orders)
    const totalOrders = await Order.countDocuments({
      'items.sellerId': sellerObjectId,
      status: 'delivered',
      deliveredAt: { $gte: startDate },
      ...buildOrgFilter(orgId),
    });

    const returnRate = totalOrders > 0 ? (totalReturns / totalOrders) * 100 : 0;

    // Top return reasons
    const reasonCounts = new Map<string, number>();
    returns.forEach((rma: unknown) => {
      (rma as { items: Array<{ reason: string }> }).items.forEach((item: unknown) => {
        const reason = (item as { reason: string }).reason;
        const count = reasonCounts.get(reason) || 0;
        reasonCounts.set(reason, count + 1);
      });
    });

    const topReasons = Array.from(reasonCounts.entries())
      .map(([reason, count]) => ({ reason, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Average refund amount
    const completedReturns = returns.filter((r: unknown) => (r as { status: string; refund?: unknown }).status === 'completed' && (r as { refund?: unknown }).refund);
    const avgRefundAmount = completedReturns.length > 0
      ? completedReturns.reduce((sum: number, r: unknown) => sum + (((r as { refund?: { amount?: number } }).refund?.amount) || 0), 0) / completedReturns.length
      : 0;

    // Restockable rate
    const inspectedReturns = returns.filter((r: unknown) => (r as { inspection?: unknown }).inspection);
    const restockableCount = inspectedReturns.filter((r: unknown) => (r as { inspection?: { restockable: boolean } }).inspection?.restockable).length;
    const restockableRate = inspectedReturns.length > 0
      ? (restockableCount / inspectedReturns.length) * 100
      : 0;

    return {
      totalReturns,
      returnRate: Math.round(returnRate * 100) / 100,
      topReasons,
      avgRefundAmount: Math.round(avgRefundAmount * 100) / 100,
      restockableRate: Math.round(restockableRate * 100) / 100
    };
  }

  /**
   * Get buyer's return history
   */
  async getBuyerReturnHistory(
    buyerId: string,
    orgId: string,
    options?: { page?: number; limit?: number },
  ): Promise<Array<{
    rmaId: string;
    orderId: string;
    status: string;
    createdAt: Date;
    items: number;
    refundAmount?: number;
  }>> {
    if (!orgId) {
      throw new Error('orgId is required to fetch buyer return history');
    }

    const page = options?.page && options.page > 0 ? options.page : 1;
    const limit = options?.limit && options.limit > 0 ? Math.min(options.limit, 200) : 50;
    const skip = (page - 1) * limit;

    // üîê NOTE: buyerId is stored as string in RMA schema, not ObjectId
    // üí° OPTIMIZATION: Use .lean() and projection for read-only query
    const baseQuery = RMA.find({
      buyerId: buyerId.toString(),
      ...buildOrgFilter(orgId),
    });

    const returns =
      typeof (baseQuery as unknown as Record<string, unknown>).select === 'function'
        ? await baseQuery
            .select({ orderId: 1, status: 1, createdAt: 1, items: 1, refund: 1 })
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limit)
            .lean()
        : (Array.isArray(baseQuery) ? baseQuery : []) as Array<unknown>;

    return returns.map((rma: unknown) => {
      const r = rma as {
        _id: { toString(): string };
        orderId: { toString(): string };
        status: string;
        createdAt: Date;
        items: unknown[];
        refund?: { amount?: number };
      };
      return {
        rmaId: safeToString(r._id),
        orderId: safeToString(r.orderId),
        status: r.status,
        createdAt: r.createdAt,
        items: r.items.length,
        refundAmount: r.refund?.amount,
      };
    });
  }

  /**
   * Find order with mandatory org scoping.
   * üîí SECURITY: orgId is required to prevent cross-tenant reads.
   */
  private async findOrder(orderId: string, orgId: string, session?: mongoose.ClientSession): Promise<IOrder | null> {
    if (!orgId) {
      throw new Error('orgId is required to find order');
    }

    // Build base query with orderId + orgId for tenant isolation (supports string/ObjectId)
    const orgFilter = buildOrgFilter(orgId);
    const baseQuery: Record<string, unknown> = { ...orgFilter };
    
    if (mongoose.Types.ObjectId.isValid(orderId)) {
      const matchByObjectIdQuery = Order.findOne({ _id: orderId, ...baseQuery });
      const matchByObjectId = session ? await matchByObjectIdQuery.session(session) : await matchByObjectIdQuery;
      if (matchByObjectId) {
        return matchByObjectId;
      }
    }
    const matchByOrderIdQuery = Order.findOne({ orderId, ...baseQuery });
    return session ? matchByOrderIdQuery.session(session) : matchByOrderIdQuery;
  }

  private mapReturnReason(
    reason: InitiateReturnParams['items'][number]['reason']
  ): 'defective' | 'wrong_item' | 'not_as_described' | 'no_longer_needed' | 'damaged_in_shipping' | 'other' {
    switch (reason) {
      case 'defective':
        return 'defective';
      case 'damaged':
        return 'damaged_in_shipping';
      case 'wrong_item':
        return 'wrong_item';
      case 'not_as_described':
        return 'not_as_described';
      case 'changed_mind':
      case 'better_price':
        return 'no_longer_needed';
      default:
        return 'other';
    }
  }

  /**
   * Background job: Auto-escalate pending returns
   * Escalate returns that haven't been reviewed within 48 hours
   * 
   */
  async autoEscalatePendingReturns(orgId: string): Promise<number> {
    if (!orgId) {
      throw new Error('orgId is required to auto-escalate pending returns');
    }

    const twoDaysAgo = new Date(Date.now() - 48 * 60 * 60 * 1000);
    
    const query: Record<string, unknown> = {
      status: 'initiated',
      createdAt: { $lt: twoDaysAgo },
      ...buildOrgFilter(orgId),
    };

    logger.info(`[ReturnsService] Auto-escalating pending returns for org ${orgId}`);

    // üí° OPTIMIZATION: Use .lean() since we only read for notifications
    const pendingReturns = await RMA.find(query).lean();

    let escalated = 0;
    for (const rma of pendingReturns) {
      // Notify admin team with org context for proper multi-tenant routing
      await addJob(QUEUE_NAMES.NOTIFICATIONS, 'internal-notification', {
        type: 'internal',
        to: 'admin-team',
        orgId,  // üîê SECURITY: Include orgId for tenant-scoped notification routing
        priority: 'high',
        message: `RMA ${rma._id} pending for 48+ hours - requires attention`
      }, { priority: 2 });
      escalated++;
    }

    return escalated;
  }

  /**
   * Background job: Auto-complete received returns
   * Auto-approve refunds for returns received 7+ days ago (for simple cases)
   * 
   * RACE CONDITION FIX: Uses atomic updateMany to mark RMAs as 'auto_processing'
   * before iterating, preventing concurrent job runs from processing the same RMAs.
   * 
   */
  async autoCompleteReceivedReturns(orgId: string): Promise<number> {
    if (!orgId) {
      throw new Error('orgId is required to auto-complete returns');
    }

    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    const jobId = `auto-complete-${Date.now()}`;  // Unique job identifier for tracking

    // Build query with optional orgId scoping (string/ObjectId safe)
    const baseOrgFilter = buildOrgFilter(orgId);
    const baseQuery: Record<string, unknown> = {
      status: 'received',
      updatedAt: { $lt: sevenDaysAgo },
      autoProcessingJobId: { $exists: false },  // Not already claimed by another job
      ...baseOrgFilter,
    };
    
    logger.info(`[ReturnsService] Auto-completing received returns for org ${orgId}`);

    // ATOMIC BATCH CLAIM: Mark eligible RMAs as being processed by this job instance
    // This prevents concurrent job runs from picking up the same RMAs
    const claimResult = await RMA.updateMany(
      baseQuery,
      {
        $set: { autoProcessingJobId: jobId }
      }
    );

    if (claimResult.modifiedCount === 0) {
      return 0;  // No eligible RMAs to process
    }

    // Now fetch only the RMAs claimed by this job instance
    const receivedReturns = await RMA.find({
      autoProcessingJobId: jobId,
      ...baseOrgFilter,
    });

    let completed = 0;
    for (const rma of receivedReturns) {
      try {
        const hasReceivedScan = Array.isArray((rma as { timeline?: Array<{ status?: string }> }).timeline)
          ? (rma as { timeline: Array<{ status?: string }> }).timeline.some(t => t.status === 'received')
          : false;
        
        if (!hasReceivedScan || !rma.shipping?.trackingNumber) {
          await addJob(QUEUE_NAMES.NOTIFICATIONS, 'internal-notification', {
            type: 'internal',
            to: 'inspection-team',
            orgId,  // üîê SECURITY: Include orgId for tenant-scoped notification routing
            priority: 'medium',
            message: `RMA ${rma._id} skipped auto-complete due to missing receipt confirmation`
          }, { priority: 3 });
          
          // Clear the job claim so it can be picked up by manual review
          const resetOrgFilter = buildOrgFilter(orgId);
          await RMA.updateOne(
            { _id: rma._id, ...resetOrgFilter },
            { $unset: { autoProcessingJobId: 1 } }
          );
          continue;
        }

        // Auto-inspect as "good" condition, restockable
        // üîê Pass orgId from the RMA record for tenant isolation
        const rmaOrgIdRaw = (rma as { orgId?: string | mongoose.Types.ObjectId }).orgId || orgId;
        const rmaOrgId = rmaOrgIdRaw ? rmaOrgIdRaw.toString() : undefined;
        if (!rmaOrgId) {
          logger.error(`[ReturnsService] Cannot auto-inspect RMA ${rma._id}: missing orgId`);
          await RMA.updateOne(
            { _id: rma._id, ...baseOrgFilter },
            { $unset: { autoProcessingJobId: 1 } }
          );
          continue;
        }
        
        await this.inspectReturn({
          rmaId: rma._id.toString(),
          inspectorId: 'SYSTEM',
          condition: 'good',
          restockable: true,
          inspectionNotes: 'Auto-inspected after 7 days - assumed good condition',
          orgId: rmaOrgId,
        });

        // Queue finance review task to ensure manual refund processing after auto-inspection
        await addJob(QUEUE_NAMES.REFUNDS, 'finance-review', {
          rmaId: rma._id.toString(),
          orgId: rmaOrgId,
        });

        // Notify finance/internal to process refund manually (no auto-refund in auto-complete flow)
        await addJob(QUEUE_NAMES.NOTIFICATIONS, 'internal-notification', {
          type: 'internal',
          to: 'finance-team',
          orgId: rmaOrgId,
          message: `RMA ${rma._id} auto-inspected; refund requires finance review`,
        }, { priority: 2 });
        
        // Clear the job claim on success
        await RMA.updateOne(
          { _id: rma._id, ...baseOrgFilter },
          { $unset: { autoProcessingJobId: 1 } }
        );
        completed++;
      } catch (error) {
        // Clear the job claim on error so it can be retried
        await RMA.updateOne(
          { _id: rma._id, ...baseOrgFilter },
          { $unset: { autoProcessingJobId: 1 } }
        );
        // Log but continue processing other RMAs
        logger.error(`[ReturnsService] Failed to auto-complete RMA ${rma._id}`, error as Error);
      }
    }

    return completed;
  }
}

export const returnsService = new ReturnsService();

]]>
</file>

<file path="services/souq/reviews/rating-aggregation-service.ts">
<![CDATA[
/**
 * Souq Rating Aggregation Service - Calculates and caches ratings
 * @module services/souq/reviews/rating-aggregation-service
 */

import { SouqReview, type IReview } from "@/server/models/souq/Review";
import { SouqProduct, type IProduct } from "@/server/models/souq/Product";
import { Types, type FilterQuery } from "mongoose";
import { buildSouqOrgFilter } from "@/services/souq/org-scope";

// üîê STRICT v4.1: Type-safe org filter helpers
const getReviewOrgFilter = (orgId: string): FilterQuery<IReview> =>
  buildSouqOrgFilter(orgId) as FilterQuery<IReview>;
const getProductOrgFilter = (orgId: string): FilterQuery<IProduct> =>
  buildSouqOrgFilter(orgId) as FilterQuery<IProduct>;

export interface RatingAggregate {
  averageRating: number;
  totalReviews: number;
  distribution: { 1: number; 2: number; 3: number; 4: number; 5: number };
  verifiedPurchasePercentage: number;
  lastUpdated: Date;
}

export interface SellerRatingAggregate {
  averageRating: number;
  totalReviews: number;
  responseRate: number;
  last30Days: {
    averageRating: number;
    totalReviews: number;
  };
}

export interface RatingDistribution {
  5: { count: number; percentage: number };
  4: { count: number; percentage: number };
  3: { count: number; percentage: number };
  2: { count: number; percentage: number };
  1: { count: number; percentage: number };
}

class RatingAggregationService {
  // In-memory cache (in production, use Redis)
  private cache = new Map<
    string,
    { data: RatingAggregate; timestamp: number }
  >();
  private cacheTTL = 5 * 60 * 1000; // 5 minutes

  private getCacheKey(productId: string, orgId: string): string {
    return `${orgId}:${productId}`;
  }

  /**
   * Calculate product rating with caching
   */
  async calculateProductRating(
    productId: string,
    orgId: string,
  ): Promise<RatingAggregate> {
    if (!orgId) {
      throw new Error("orgId is required for tenant-scoped product rating");
    }
    // Check cache first
    const cacheKey = this.getCacheKey(productId, orgId);
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.data;
    }

    // üîê STRICT v4.1: Use shared org filter helper for consistent tenant isolation
    const orgFilter = getReviewOrgFilter(orgId);
    const reviewFilter: FilterQuery<IReview> = {
      productId: Types.ObjectId.isValid(productId) ? new Types.ObjectId(productId) : productId,
      status: "published",
      ...orgFilter,
    };

    const reviews = await SouqReview.find(reviewFilter)
      .select("rating isVerifiedPurchase")
      .lean();

    const totalReviews = reviews.length;
    const verifiedCount = reviews.filter((r) => r.isVerifiedPurchase).length;

    // Calculate weighted average (verified purchases count more)
    let weightedSum = 0;
    let totalWeight = 0;

    reviews.forEach((review) => {
      const weight = review.isVerifiedPurchase ? 1.5 : 1.0;
      weightedSum += review.rating * weight;
      totalWeight += weight;
    });

    const averageRating = totalWeight > 0 ? weightedSum / totalWeight : 0;

    // Calculate distribution
    const distribution: Record<1 | 2 | 3 | 4 | 5, number> = {
      1: 0,
      2: 0,
      3: 0,
      4: 0,
      5: 0,
    };
    reviews.forEach((review) => {
      const rating = review.rating as 1 | 2 | 3 | 4 | 5;
      distribution[rating] += 1;
    });

    const verifiedPurchasePercentage =
      totalReviews > 0 ? (verifiedCount / totalReviews) * 100 : 0;

    const aggregate: RatingAggregate = {
      averageRating: Math.round(averageRating * 10) / 10, // Round to 1 decimal
      totalReviews,
      distribution,
      verifiedPurchasePercentage: Math.round(verifiedPurchasePercentage),
      lastUpdated: new Date(),
    };

    // Cache result
    this.cache.set(cacheKey, {
      data: aggregate,
      timestamp: Date.now(),
    });

    return aggregate;
  }

  /**
   * Calculate seller rating across all products
   */
  async calculateSellerRating(
    orgId: string,
    sellerId: string,
  ): Promise<SellerRatingAggregate> {
    // üîê STRICT v4.1: Use shared org filter helper for consistent tenant isolation
    const orgFilter = getProductOrgFilter(orgId);
    const sellerObjectId = Types.ObjectId.isValid(sellerId)
      ? new Types.ObjectId(sellerId)
      : sellerId;

    const products = await SouqProduct.find({ createdBy: sellerObjectId, ...orgFilter })
      .select("_id")
      .lean();
    if (products.length === 0) {
      return {
        averageRating: 0,
        totalReviews: 0,
        responseRate: 0,
        last30Days: {
          averageRating: 0,
          totalReviews: 0,
        },
      };
    }
    const productIds = products.map((p) => p._id);

    // üîê STRICT v4.1: Use shared org filter helper for consistent tenant isolation
    const reviewOrgFilter = getReviewOrgFilter(orgId);
    const reviews = await SouqReview.find({
      ...reviewOrgFilter,
      productId: { $in: productIds },
      status: "published",
    })
      .select("rating createdAt sellerResponse")
      .lean();

    const totalReviews = reviews.length;
    const averageRating =
      totalReviews > 0
        ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews
        : 0;

    // Calculate response rate
    const reviewsWithResponse = reviews.filter((r) => r.sellerResponse).length;
    const responseRate =
      totalReviews > 0 ? (reviewsWithResponse / totalReviews) * 100 : 0;

    // Last 30 days stats
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const recentReviews = reviews.filter((r) => r.createdAt >= thirtyDaysAgo);
    const recentTotal = recentReviews.length;
    const recentAverage =
      recentTotal > 0
        ? recentReviews.reduce((sum, r) => sum + r.rating, 0) / recentTotal
        : 0;

    return {
      averageRating: Math.round(averageRating * 10) / 10,
      totalReviews,
      responseRate: Math.round(responseRate),
      last30Days: {
        averageRating: Math.round(recentAverage * 10) / 10,
        totalReviews: recentTotal,
      },
    };
  }

  /**
   * Update product rating cache (called after new review)
   */
  async updateProductRatingCache(
    productId: string,
    orgId: string,
  ): Promise<void> {
    if (!orgId) {
      throw new Error("orgId is required to update product rating cache");
    }
    // Invalidate cache
    this.cache.delete(this.getCacheKey(productId, orgId));

    // Recalculate
    await this.calculateProductRating(productId, orgId);
  }

  /**
   * Get rating distribution with percentages
   */
  async getRatingDistribution(
    productId: string,
    orgId: string,
  ): Promise<RatingDistribution> {
    if (!orgId) {
      throw new Error("orgId is required to fetch rating distribution");
    }
    const aggregate = await this.calculateProductRating(productId, orgId);
    const total = aggregate.totalReviews;

    const distribution: RatingDistribution = {
      5: {
        count: aggregate.distribution[5],
        percentage:
          total > 0 ? Math.round((aggregate.distribution[5] / total) * 100) : 0,
      },
      4: {
        count: aggregate.distribution[4],
        percentage:
          total > 0 ? Math.round((aggregate.distribution[4] / total) * 100) : 0,
      },
      3: {
        count: aggregate.distribution[3],
        percentage:
          total > 0 ? Math.round((aggregate.distribution[3] / total) * 100) : 0,
      },
      2: {
        count: aggregate.distribution[2],
        percentage:
          total > 0 ? Math.round((aggregate.distribution[2] / total) * 100) : 0,
      },
      1: {
        count: aggregate.distribution[1],
        percentage:
          total > 0 ? Math.round((aggregate.distribution[1] / total) * 100) : 0,
      },
    };

    return distribution;
  }

  /**
   * Get recent reviews for a product
   */
  async getRecentReviews(orgId: string, productId: string, limit: number = 5) {
    // üîê STRICT v4.1: Use shared org filter helper for consistent tenant isolation
    const orgFilter = getReviewOrgFilter(orgId);
    const MAX_LIMIT = 100; // Prevent unbounded queries
    const safeLimit = Math.min(limit, MAX_LIMIT);
    
    return await SouqReview.find({
      ...orgFilter,
      productId: Types.ObjectId.isValid(productId) ? new Types.ObjectId(productId) : productId,
      status: "published",
    })
      .sort({ createdAt: -1 })
      .limit(safeLimit)
      .lean();
  }

  /**
   * Clear cache for specific product
   */
  clearCache(orgId: string, productId: string): void {
    this.cache.delete(this.getCacheKey(orgId, productId));
  }

  /**
   * Clear all cached ratings
   */
  clearAllCache(): void {
    this.cache.clear();
  }
}

export const ratingAggregationService = new RatingAggregationService();

]]>
</file>

<file path="services/souq/reviews/review-service.ts">
<![CDATA[
/**
 * Souq Review Service - Handles review operations
 * @module services/souq/reviews/review-service
 */

import { SouqReview, type IReview } from "@/server/models/souq/Review";
import { SouqOrder } from "@/server/models/souq/Order";
import { SouqProduct, type IProduct } from "@/server/models/souq/Product";
import { buildSouqOrgFilter } from "@/services/souq/org-scope";
import { isSouqModeratorRole } from "@/types/user";
import { nanoid } from "nanoid";
import type mongoose from "mongoose";
import { Types, type FilterQuery } from "mongoose";

// üöÄ PERF: Maximum limit for paginated queries to prevent abuse
const MAX_PAGE_LIMIT = 100;
// üõ°Ô∏è Moderation: Number of unique reports before auto-flagging a review
const REPORT_FLAG_THRESHOLD = 3;

// üîê STRICT v4.1: Helper to validate moderator role (uses centralized types/user.ts)
const assertModeratorRole = (role: string | undefined | null): void => {
  if (!isSouqModeratorRole(role)) {
    throw new Error("Unauthorized: Moderator role required");
  }
};

// Helper to cast org filter to Mongoose FilterQuery type
const getOrgFilter = (orgId: string): FilterQuery<IReview> =>
  buildSouqOrgFilter(orgId) as FilterQuery<IReview>;
const getProductOrgFilter = (orgId: string): FilterQuery<IProduct> =>
  buildSouqOrgFilter(orgId) as FilterQuery<IProduct>;

export interface CreateReviewDto {
  productId: string;
  customerId: string;
  customerName: string;
  orderId?: string;
  rating: number;
  title: string;
  content: string;
  pros?: string[];
  cons?: string[];
  images?: Array<{ url: string; caption?: string }>;
}

export interface UpdateReviewDto {
  title?: string;
  content?: string;
  pros?: string[];
  cons?: string[];
  images?: Array<{ url: string; caption?: string }>;
}

export interface ReviewFilters {
  rating?: number;
  verifiedOnly?: boolean;
  sortBy?: "recent" | "helpful" | "rating";
  page?: number;
  limit?: number;
  status?: "pending" | "published" | "rejected" | "flagged";
}

export interface PaginatedReviews {
  reviews: IReview[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// üöÄ PERF: Lean review type for read-only queries (better performance)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type LeanReview = Record<string, any>;

export interface ReviewStats {
  averageRating: number;
  totalReviews: number;
  distribution: Record<1 | 2 | 3 | 4 | 5, number>;
  verifiedPurchaseCount: number;
  recentReviews: LeanReview[];
}

export interface SellerReviewStats {
  averageRating: number;
  totalReviews: number;
  pendingResponses: number;
  responseRate: number;
  recentReviews: LeanReview[];
}

class ReviewService {
  /**
   * Submit a new review
   */
  async submitReview(orgId: string, data: CreateReviewDto): Promise<IReview> {
    // üîê STRICT v4.1: Validate rating is provided before range check
    if (data.rating == null) {
      throw new Error("Rating is required");
    }
    this.assertRatingRange(data.rating);

    const orgObjectId = this.ensureObjectId(orgId, "orgId");
    const productObjectId = this.ensureObjectId(data.productId, "productId");
    const customerObjectId = this.ensureObjectId(data.customerId, "customerId");
    // üîê STRICT v4.1: Use shared org filter for consistency across Souq services
    const orgFilter = getOrgFilter(orgId);

    const product = await SouqProduct.findOne({
      _id: productObjectId,
      ...orgFilter,
    }).select("fsin isActive");
    if (!product) {
      throw new Error("Product not found");
    }
    if (product.isActive === false) {
      throw new Error("Cannot review inactive product");
    }

    // Check for duplicate review
    const existingReview = await SouqReview.findOne({
      customerId: customerObjectId,
      productId: productObjectId,
      ...orgFilter,
    });

    if (existingReview) {
      throw new Error("You have already reviewed this product");
    }

    // Verify purchase if orderId provided
    let isVerifiedPurchase = false;
    let orderIdObj: mongoose.Types.ObjectId | undefined;

    if (data.orderId) {
      const order = await SouqOrder.findOne({
        orderId: data.orderId,
        customerId: customerObjectId,
        ...orgFilter,
        "items.productId": productObjectId,
        status: "delivered",
      });

      if (order) {
        isVerifiedPurchase = true;
        orderIdObj = order._id;
      }
    }

    // Create review
    const review = await SouqReview.create({
      reviewId: `REV-${nanoid(10)}`,
      orgId: orgObjectId,
      productId: productObjectId,
      fsin: product.fsin,
      customerId: customerObjectId,
      customerName: data.customerName,
      isVerifiedPurchase,
      orderId: orderIdObj,
      rating: data.rating,
      title: data.title,
      content: data.content,
      pros: data.pros || [],
      cons: data.cons || [],
      images: data.images || [],
      status: "pending", // Requires moderation
    });

    return review;
  }

  /**
   * Update existing review (customer only)
   */
  async updateReview(
    reviewId: string,
    orgId: string,
    customerId: string,
    data: UpdateReviewDto,
  ): Promise<IReview> {
    const customerObjectId = this.ensureObjectId(customerId, "customerId");
    // üîê STRICT v4.1: Use shared org filter for consistency
    const orgFilter = getOrgFilter(orgId);
    const review = await SouqReview.findOne({
      reviewId,
      customerId: customerObjectId,
      ...orgFilter,
    });

    if (!review) {
      throw new Error("Review not found or unauthorized");
    }

    if (review.status === "published") {
      throw new Error("Cannot edit published reviews");
    }

    // Update fields
    if (data.title) review.title = data.title;
    if (data.content) review.content = data.content;
    if (data.pros) review.pros = data.pros;
    if (data.cons) review.cons = data.cons;
    if (data.images) {
      review.images = data.images.map((img) => ({
        ...img,
        uploadedAt: new Date(),
      }));
    }

    await review.save();
    return review;
  }

  /**
   * Delete review (customer only, before publication)
   */
  async deleteReview(reviewId: string, orgId: string, customerId: string): Promise<void> {
    const customerObjectId = this.ensureObjectId(customerId, "customerId");
    // üîê STRICT v4.1: Use shared org filter for consistency
    const orgFilter = getOrgFilter(orgId);
    const review = await SouqReview.findOne({
      reviewId,
      customerId: customerObjectId,
      ...orgFilter,
    });

    if (!review) {
      throw new Error("Review not found or unauthorized");
    }

    if (review.status === "published") {
      throw new Error("Cannot delete published reviews");
    }

    await review.deleteOne();
  }

  /**
   * Mark review as helpful
   */
  async markHelpful(reviewId: string, orgId: string, customerId: string): Promise<IReview> {
    // üîê STRICT v4.1: Use shared org filter for consistency
    const orgFilter = getOrgFilter(orgId);
    const voterObjectId = this.ensureObjectId(customerId, "customerId");
    const review = await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    }).select("+helpfulVoters +notHelpfulVoters");

    if (!review) {
      throw new Error("Review not found");
    }
    if (review.status !== "published") {
      throw new Error("Cannot vote on unpublished reviews");
    }

    const voterIdStr = voterObjectId.toString();
    const helpfulSet = new Set(
      (review.helpfulVoters ?? []).map((id) => id.toString()),
    );
    const notHelpfulSet = new Set(
      (review.notHelpfulVoters ?? []).map((id) => id.toString()),
    );
    const alreadyHelpful = helpfulSet.has(voterIdStr);
    const wasNotHelpful = notHelpfulSet.has(voterIdStr);

    if (!alreadyHelpful) {
      helpfulSet.add(voterIdStr);
      review.helpful = Math.max(0, (review.helpful ?? 0) + 1);
    }
    if (wasNotHelpful) {
      notHelpfulSet.delete(voterIdStr);
      review.notHelpful = Math.max(0, (review.notHelpful ?? 0) - 1);
    }

    review.helpfulVoters = Array.from(helpfulSet).map(
      (id) => new Types.ObjectId(id),
    );
    review.notHelpfulVoters = Array.from(notHelpfulSet).map(
      (id) => new Types.ObjectId(id),
    );
    await review.save();

    return review;
  }

  /**
   * Mark review as not helpful
   */
  async markNotHelpful(
    reviewId: string,
    orgId: string,
    customerId: string,
  ): Promise<IReview> {
    const orgFilter = getOrgFilter(orgId);
    const voterObjectId = this.ensureObjectId(customerId, "customerId");
    const review = await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    }).select("+helpfulVoters +notHelpfulVoters");

    if (!review) {
      throw new Error("Review not found");
    }
    if (review.status !== "published") {
      throw new Error("Cannot vote on unpublished reviews");
    }

    const voterIdStr = voterObjectId.toString();
    const helpfulSet = new Set(
      (review.helpfulVoters ?? []).map((id) => id.toString()),
    );
    const notHelpfulSet = new Set(
      (review.notHelpfulVoters ?? []).map((id) => id.toString()),
    );
    const wasHelpful = helpfulSet.has(voterIdStr);
    const alreadyNotHelpful = notHelpfulSet.has(voterIdStr);

    if (!alreadyNotHelpful) {
      notHelpfulSet.add(voterIdStr);
      review.notHelpful = Math.max(0, (review.notHelpful ?? 0) + 1);
    }
    if (wasHelpful) {
      helpfulSet.delete(voterIdStr);
      review.helpful = Math.max(0, (review.helpful ?? 0) - 1);
    }

    review.helpfulVoters = Array.from(helpfulSet).map(
      (id) => new Types.ObjectId(id),
    );
    review.notHelpfulVoters = Array.from(notHelpfulSet).map(
      (id) => new Types.ObjectId(id),
    );
    await review.save();

    return review;
  }

  /**
   * Report inappropriate review
   * @param reviewId - The review to report
   * @param orgId - Organization ID for tenant isolation
   * @param reporterId - ID of the user making the report (for dedup/rate-limit)
   * @param reason - Reason for reporting
   */
  async reportReview(
    reviewId: string,
    orgId: string,
    reporterId: string,
    reason: string,
  ): Promise<IReview> {
    const orgFilter = getOrgFilter(orgId);
    const reporterObjectId = this.ensureObjectId(reporterId, "reporterId");

    // Deduplicate by reporter to prevent spam; only increment count when reporter is new
    const updated = await SouqReview.findOneAndUpdate(
      {
        reviewId,
        ...orgFilter,
        reporters: { $ne: reporterObjectId },
      },
      {
        $addToSet: { reporters: reporterObjectId },
        $push: { reportReasons: { $each: [reason], $slice: -20 } },
        $inc: { reportedCount: 1 },
      },
      { new: true, select: "+reporters" },
    );

    // If the reporter already exists, fetch current state without mutating counts
    const review =
      updated ??
      (await SouqReview.findOne({
        reviewId,
        ...orgFilter,
      }).select("+reporters"));

    if (!review) {
      throw new Error("Review not found");
    }

    // Auto-flag if threshold reached
    if (review.reportedCount >= REPORT_FLAG_THRESHOLD && review.status === "published") {
      review.status = "flagged";
      await review.save();
      const productObjectId = this.ensureObjectId(
        String(review.productId),
        "productId",
      );
      await this.updateProductAggregates(productObjectId, orgId);
    } else if (updated) {
      // Persist the new reason even when not flagging
      await review.save();
    }

    // üö´ Privacy: do not return reporter identities or report details to callers
    delete (review as { reporters?: unknown }).reporters;
    delete (review as { reportReasons?: unknown }).reportReasons;

    return review;
  }

  /**
   * Seller responds to review
   * @param orgId - Required for STRICT v4.1 tenant isolation
   */
  async respondToReview(
    orgId: string,
    reviewId: string,
    sellerId: string,
    content: string,
  ): Promise<IReview> {
    // üîê STRICT v4.1: orgId is ALWAYS required for tenant isolation
    if (!orgId) {
      throw new Error('orgId is required for respondToReview (STRICT v4.1 tenant isolation)');
    }
    const orgFilter = getOrgFilter(orgId);
    const review = await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    });

    if (!review) {
      throw new Error("Review not found");
    }

    if (review.status !== "published") {
      throw new Error("Can only respond to published reviews");
    }

    const reviewOrgId =
      (review as { orgId?: mongoose.Types.ObjectId | string })?.orgId ||
      (review as { org_id?: mongoose.Types.ObjectId | string })?.org_id;
    if (!reviewOrgId) {
      throw new Error("Review missing orgId");
    }
    const productObjectId = this.ensureObjectId(
      String(review.productId),
      "productId",
    );
    const reviewOrgFilter = getProductOrgFilter(String(reviewOrgId));

    const product = await SouqProduct.findOne({
      _id: productObjectId,
      ...reviewOrgFilter,
    }).select("createdBy");
    if (!Types.ObjectId.isValid(sellerId)) {
      throw new Error("Invalid seller id");
    }
    const ownerId =
      typeof product?.createdBy === "string"
        ? product.createdBy
        : product?.createdBy?.toString?.();

    if (!product || ownerId !== sellerId) {
      throw new Error("Unauthorized to respond to this review");
    }

    // Set seller response
    review.sellerResponse = {
      content,
      respondedAt: new Date(),
      respondedBy: new Types.ObjectId(sellerId),
    };

    await review.save();
    return review;
  }

  /**
   * Get reviews for seller (all their products)
   * @param orgId - Required for STRICT v4.1 tenant isolation
   */
  async getSellerReviews(
    orgId: string,
    sellerId: string,
    filters: ReviewFilters = {},
  ): Promise<PaginatedReviews> {
    // üîê STRICT v4.1: orgId is ALWAYS required for tenant isolation
    if (!orgId) {
      throw new Error('orgId is required for getSellerReviews (STRICT v4.1 tenant isolation)');
    }
    const orgFilter = getOrgFilter(orgId);
    const sellerProductIds = await this.getSellerProductIds(orgId, sellerId);
    if (sellerProductIds.length === 0) {
      return {
        reviews: [],
        total: 0,
        page: filters.page ?? 1,
        limit: filters.limit ?? 20,
        totalPages: 0,
      };
    }

    const {
      rating,
      verifiedOnly,
      sortBy = "recent",
      page = 1,
      limit = 20,
      status,
    } = filters;

    // Build query - üîê STRICT v4.1: Include org filter for tenant isolation
    const query: Record<string, unknown> = {
      productId: { $in: sellerProductIds },
      ...orgFilter,
    };

    if (rating) query.rating = rating;
    if (verifiedOnly) query.isVerifiedPurchase = true;
    if (status) query.status = status;

    // Sort options
    let sortOptions: Record<string, 1 | -1> = { createdAt: -1 };
    if (sortBy === "helpful") {
      sortOptions = { helpful: -1 };
    } else if (sortBy === "rating") {
      sortOptions = { rating: -1 };
    }

    // Execute query
    const safeLimit = Math.min(limit ?? 20, MAX_PAGE_LIMIT);
    const currentPage = Math.max(page ?? 1, 1);
    const skip = (currentPage - 1) * safeLimit;
    const [reviews, total] = await Promise.all([
      SouqReview.find(query).sort(sortOptions).skip(skip).limit(safeLimit).lean(),
      SouqReview.countDocuments(query),
    ]);

    return {
      reviews: reviews as unknown as IReview[],
      total,
      page: currentPage,
      limit: safeLimit,
      totalPages: Math.ceil(total / safeLimit),
    };
  }

  /**
   * Get product reviews (public)
   * @param orgId - Required for STRICT v4.1 tenant isolation
   */
  async getProductReviews(
    productId: string,
    orgId: string,
    filters: ReviewFilters = {},
  ): Promise<PaginatedReviews> {
    // üîê STRICT v4.1: orgId is ALWAYS required for tenant isolation
    if (!orgId) {
      throw new Error('orgId is required for getProductReviews (STRICT v4.1 tenant isolation)');
    }
    const orgFilter = getOrgFilter(orgId);
    const productObjectId = this.ensureObjectId(productId, "productId");

    const {
      rating,
      verifiedOnly,
      sortBy = "recent",
      page = 1,
      limit = 20,
    } = filters;

    // Build query
    const query: Record<string, unknown> = {
      productId: { $in: [productId, productObjectId] },
      status: "published", // Only show published reviews
      ...orgFilter,
    };

    if (rating) query.rating = rating;
    if (verifiedOnly) query.isVerifiedPurchase = true;

    // Sort options
    let sortOptions: Record<string, 1 | -1> = { createdAt: -1 };
    if (sortBy === "helpful") {
      sortOptions = { helpful: -1 };
    } else if (sortBy === "rating") {
      sortOptions = { rating: -1 };
    }

    // Execute query
    const safeLimit = Math.min(limit ?? 20, MAX_PAGE_LIMIT);
    const currentPage = Math.max(page ?? 1, 1);
    const skip = (currentPage - 1) * safeLimit;
    const [reviews, total] = await Promise.all([
      SouqReview.find(query).sort(sortOptions).skip(skip).limit(safeLimit).lean(),
      SouqReview.countDocuments(query),
    ]);

    return {
      reviews: reviews as unknown as IReview[],
      total,
      page: currentPage,
      limit: safeLimit,
      totalPages: Math.ceil(total / safeLimit),
    };
  }

  /**
   * Get single review by ID
   */
  async getReviewById(reviewId: string, orgId: string): Promise<IReview | null> {
    const orgFilter = getOrgFilter(orgId);
    return await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    });
  }

  /**
   * Approve review (moderator)
   * üîê STRICT v4.1: Requires moderator role validation
   */
  async approveReview(
    reviewId: string,
    orgId: string,
    moderatorId: string,
    moderatorRole: string,
  ): Promise<IReview> {
    // üîê STRICT v4.1: Validate moderator has appropriate role
    assertModeratorRole(moderatorRole);
    
    const orgFilter = getOrgFilter(orgId);
    const review = await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    });

    if (!review) {
      throw new Error("Review not found");
    }

    review.status = "published";
    review.publishedAt = new Date();
    // üîê AUDIT: Record who approved the review
    review.moderatedBy = new Types.ObjectId(moderatorId);
    review.moderatedAt = new Date();
    await review.save();
    await this.updateProductAggregates(review.productId, orgId);

    return review;
  }

  /**
   * Reject review (moderator)
   * üîê STRICT v4.1: Requires moderator role validation
   */
  async rejectReview(
    reviewId: string,
    orgId: string,
    moderatorId: string,
    moderatorRole: string,
    notes: string,
  ): Promise<IReview> {
    // üîê STRICT v4.1: Validate moderator has appropriate role
    assertModeratorRole(moderatorRole);
    
    const orgFilter = getOrgFilter(orgId);
    const review = await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    });

    if (!review) {
      throw new Error("Review not found");
    }

    review.status = "rejected";
    review.moderationNotes = notes;
    // üîê AUDIT: Record who rejected the review
    review.moderatedBy = new Types.ObjectId(moderatorId);
    review.moderatedAt = new Date();
    await review.save();
    await this.updateProductAggregates(review.productId, orgId);

    return review;
  }

  /**
   * Flag a review for additional moderation review (moderator only)
   * @param reviewId - Unique review identifier
   * @param orgId - Organization ID for multi-tenant isolation
   * @param moderatorId - ID of the moderator flagging the review
   * @param moderatorRole - Role of the moderator (must be in MODERATOR_ROLES)
   * @param reason - Detailed reason for flagging
   * @returns The flagged review document with status 'flagged'
   * @throws Error if unauthorized role, review not found, or reason is empty
   * üîê STRICT v4.1: Requires moderator role validation
   */
  async flagReview(
    reviewId: string,
    orgId: string,
    moderatorId: string,
    moderatorRole: string,
    reason: string,
  ): Promise<IReview> {
    // üîê STRICT v4.1: Validate moderator has appropriate role
    assertModeratorRole(moderatorRole);
    
    if (!reason) {
      throw new Error("Flag reason is required");
    }
    const orgFilter = getOrgFilter(orgId);
    const review = await SouqReview.findOne({
      reviewId,
      ...orgFilter,
    });

    if (!review) {
      throw new Error("Review not found");
    }

    review.status = "flagged";
    review.moderationNotes = reason;
    // üîê AUDIT: Record who flagged the review
    review.moderatedBy = new Types.ObjectId(moderatorId);
    review.moderatedAt = new Date();
    await review.save();
    await this.updateProductAggregates(review.productId, orgId);

    return review;
  }

  /**
   * Get review statistics for a product including rating distribution and recent reviews
   * @param productId - Product identifier (string or ObjectId format)
   * @param orgId - Organization ID for multi-tenant isolation
   * @returns Aggregated stats: averageRating, totalReviews, ratingBreakdown, verifiedPurchaseCount, recentReviews
   */
  async getReviewStats(productId: string, orgId: string): Promise<ReviewStats> {
    const productObjectId = this.ensureObjectId(productId, "productId");
    const orgFilter = getOrgFilter(orgId);
    const [stats] = await SouqReview.aggregate<{
      totalReviews: number;
      totalRating: number;
      verifiedPurchaseCount: number;
      star1: number;
      star2: number;
      star3: number;
      star4: number;
      star5: number;
    }>([
      {
        $match: {
          productId: { $in: [productObjectId, productId] },
          status: "published",
          ...orgFilter,
        },
      },
      {
        $group: {
          _id: "$productId",
          totalReviews: { $sum: 1 },
          totalRating: { $sum: "$rating" },
          verifiedPurchaseCount: {
            $sum: { $cond: [{ $eq: ["$isVerifiedPurchase", true] }, 1, 0] },
          },
          star1: { $sum: { $cond: [{ $eq: ["$rating", 1] }, 1, 0] } },
          star2: { $sum: { $cond: [{ $eq: ["$rating", 2] }, 1, 0] } },
          star3: { $sum: { $cond: [{ $eq: ["$rating", 3] }, 1, 0] } },
          star4: { $sum: { $cond: [{ $eq: ["$rating", 4] }, 1, 0] } },
          star5: { $sum: { $cond: [{ $eq: ["$rating", 5] }, 1, 0] } },
        },
      },
    ]);

    const distribution: Record<1 | 2 | 3 | 4 | 5, number> = {
      1: stats?.star1 ?? 0,
      2: stats?.star2 ?? 0,
      3: stats?.star3 ?? 0,
      4: stats?.star4 ?? 0,
      5: stats?.star5 ?? 0,
    };

    const totalReviews = stats?.totalReviews ?? 0;
    const averageRating =
      totalReviews > 0 ? stats!.totalRating / totalReviews : 0;
    const verifiedPurchaseCount = stats?.verifiedPurchaseCount ?? 0;

    // üîê STRICT v4.1: Include org filter for tenant isolation
    // üöÄ PERF: Use .lean() for read-only data
    const recentReviews = await SouqReview.find({
      productId: { $in: [productObjectId, productId] },
      status: "published",
      ...orgFilter,
    })
      .sort({ createdAt: -1 })
      .limit(5)
      .lean();

    return {
      averageRating,
      totalReviews,
      distribution,
      verifiedPurchaseCount,
      recentReviews,
    };
  }

  /**
   * Get seller review statistics
   * @param orgId - Required for STRICT v4.1 tenant isolation
   */
  async getSellerReviewStats(orgId: string, sellerId: string): Promise<SellerReviewStats> {
    // üîê STRICT v4.1: orgId is ALWAYS required for tenant isolation
    if (!orgId) {
      throw new Error('orgId is required for getSellerReviewStats (STRICT v4.1 tenant isolation)');
    }
    const orgFilter = getOrgFilter(orgId);
    const sellerProductIds = await this.getSellerProductIds(orgId, sellerId);
    if (sellerProductIds.length === 0) {
      return {
        averageRating: 0,
        totalReviews: 0,
        pendingResponses: 0,
        responseRate: 0,
        recentReviews: [],
      };
    }

    // üîê STRICT v4.1: Include org filter for tenant isolation
    // üöÄ PERF: Use aggregation instead of loading all reviews into memory
    const matchStage = {
      status: "published",
      productId: { $in: sellerProductIds },
      ...orgFilter,
    };

    const [stats] = await SouqReview.aggregate<{
      totalReviews: number;
      avgRating: number;
      pendingResponses: number;
    }>([
      { $match: matchStage },
      {
        $group: {
          _id: null,
          totalReviews: { $sum: 1 },
          avgRating: { $avg: "$rating" },
          pendingResponses: {
            $sum: { $cond: [{ $not: ["$sellerResponse"] }, 1, 0] },
          },
        },
      },
    ]);

    const totalReviews = stats?.totalReviews ?? 0;
    const averageRating = stats?.avgRating ?? 0;
    const pendingResponses = stats?.pendingResponses ?? 0;
    const responseRate =
      totalReviews > 0
        ? ((totalReviews - pendingResponses) / totalReviews) * 100
        : 0;

    // Fetch only recent 5 reviews using DB sort/limit instead of loading all
    const recentReviews = await SouqReview.find(matchStage)
      .sort({ createdAt: -1 })
      .limit(5)
      .lean();

    return {
      averageRating,
      totalReviews,
      pendingResponses,
      responseRate,
      recentReviews,
    };
  }

  /**
   * Get product IDs for a seller within an org
   * @param orgId - Required for STRICT v4.1 tenant isolation
   */
  private async getSellerProductIds(
    orgId: string,
    sellerId: string,
  ): Promise<mongoose.Types.ObjectId[]> {
    // üîê STRICT v4.1: orgId is ALWAYS required for tenant isolation
    if (!orgId) {
      throw new Error('orgId is required for getSellerProductIds (STRICT v4.1 tenant isolation)');
    }
    if (!sellerId || !Types.ObjectId.isValid(sellerId)) {
      return [];
    }

    const orgFilter = getOrgFilter(orgId);
    // üîß FIX: Convert sellerId to ObjectId to match schema type
    const sellerObjectId = new Types.ObjectId(sellerId);
    // üîê STRICT v4.1: Include org filter for tenant isolation
    const products = await SouqProduct.find({
      createdBy: sellerObjectId,
      ...orgFilter,
    })
      .select("_id")
      .lean();
    return products.map((product) => product._id);
  }

  /**
   * Validates and converts a string ID to a Mongoose ObjectId
   * @param id - The string ID to convert
   * @param fieldName - The field name for error messages
   * @throws Error if the ID is not a valid ObjectId format
   */
  private ensureObjectId(
    id: string,
    fieldName: string,
  ): mongoose.Types.ObjectId {
    if (!Types.ObjectId.isValid(id)) {
      throw new Error(`Invalid ${fieldName}`);
    }
    return new Types.ObjectId(id);
  }

  /**
   * Validates that rating is an integer between 1 and 5
   * @param rating - The rating value to validate
   * @throws Error if rating is not an integer or out of range
   */
  private assertRatingRange(rating: number): void {
    if (!Number.isInteger(rating) || rating < 1 || rating > 5) {
      throw new Error("Rating must be an integer between 1 and 5");
    }
  }

  /**
   * Updates product aggregate statistics after review changes
   * Recalculates average rating, total reviews, and rating distribution
   * @param productId - The product ObjectId to update
   * @param orgId - Organization ID for tenant isolation
   */
  private async updateProductAggregates(
    productId: mongoose.Types.ObjectId,
    orgId: string,
  ): Promise<void> {
    const orgFilter = getOrgFilter(orgId);
    const [stats] = await SouqReview.aggregate<{
      totalReviews: number;
      totalRating: number;
      star1: number;
      star2: number;
      star3: number;
      star4: number;
      star5: number;
    }>([
      { $match: { productId, status: "published", ...orgFilter } },
      {
        $group: {
          _id: "$productId",
          totalReviews: { $sum: 1 },
          totalRating: { $sum: "$rating" },
          star1: { $sum: { $cond: [{ $eq: ["$rating", 1] }, 1, 0] } },
          star2: { $sum: { $cond: [{ $eq: ["$rating", 2] }, 1, 0] } },
          star3: { $sum: { $cond: [{ $eq: ["$rating", 3] }, 1, 0] } },
          star4: { $sum: { $cond: [{ $eq: ["$rating", 4] }, 1, 0] } },
          star5: { $sum: { $cond: [{ $eq: ["$rating", 5] }, 1, 0] } },
        },
      },
    ]);

    const distribution: Record<1 | 2 | 3 | 4 | 5, number> = {
      1: stats?.star1 ?? 0,
      2: stats?.star2 ?? 0,
      3: stats?.star3 ?? 0,
      4: stats?.star4 ?? 0,
      5: stats?.star5 ?? 0,
    };

    const totalReviews = stats?.totalReviews ?? 0;
    const averageRating =
      totalReviews > 0 ? stats!.totalRating / totalReviews : 0;

    await SouqProduct.updateOne(
      { _id: productId, ...orgFilter },
      {
        $set: {
          averageRating,
          reviewCount: totalReviews,
          ratingDistribution: distribution,
        },
      },
    );
  }
}

export const reviewService = new ReviewService();

]]>
</file>

</batch_content>
