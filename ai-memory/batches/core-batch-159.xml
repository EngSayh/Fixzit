
You are the "Fixzit Memory Builder" for category: "core".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "core",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="docs/i18n-guidelines.md">
<![CDATA[
# i18n Translation Guidelines

**Last Updated**: 2025-11-10  
**Maintained By**: Engineering Team  
**Version**: 1.0

---

## Overview

Fixzit uses a dual-catalog system for internationalization:

- **Primary Source**: `contexts/TranslationContext.tsx` (hardcoded key-value pairs)
- **Secondary Source**: `i18n/en.json` and `i18n/ar.json` (JSON catalogs)

**Supported Languages**:

- English (EN) - Left-to-Right (LTR)
- Arabic (AR) - Right-to-Left (RTL)

**Translation Parity**: 100% (1986 keys in both EN and AR as of 2025-11-10)

---

## Translation Key Structure

### Namespacing Convention

Keys follow a hierarchical dot notation:

```
<module>.<category>.<specific>
```

**Examples**:

```typescript
"nav.dashboard"; // Navigation item
"common.save"; // Common action
"finance.invoice.create"; // Module-specific action
"errors.validation.required"; // Error message
"time.justNow"; // Time formatting
```

### Namespace Guidelines

| Namespace   | Purpose            | Examples                                            |
| ----------- | ------------------ | --------------------------------------------------- |
| `nav.*`     | Navigation items   | `nav.dashboard`, `nav.settings`                     |
| `common.*`  | Shared UI elements | `common.save`, `common.cancel`, `common.loading`    |
| `sidebar.*` | Sidebar-specific   | `sidebar.modules`, `sidebar.account`                |
| `finance.*` | Finance module     | `finance.invoice.total`, `finance.payment.received` |
| `hr.*`      | HR module          | `hr.employee.name`, `hr.payroll.process`            |
| `errors.*`  | Error messages     | `errors.network`, `errors.validation.email`         |
| `time.*`    | Time formatting    | `time.justNow`, `time.mAgo`, `time.hAgo`            |
| `auth.*`    | Authentication     | `auth.login.title`, `auth.signup.submit`            |

---

## Safe Translation Patterns

### ‚úÖ Pattern 1: Static Keys (RECOMMENDED)

**Always use static keys when possible:**

```typescript
// ‚úÖ GOOD - Static key
const title = t("finance.invoice.create");

// ‚úÖ GOOD - Static key with fallback
const label = t("common.save", "Save");
```

**Why**: Statically analyzable by audit tools, no runtime errors.

---

### ‚úÖ Pattern 2: Dynamic Keys with Fallback (ACCEPTABLE)

**When iterating over known enums, use fallback pattern:**

```typescript
// ‚úÖ ACCEPTABLE - Dynamic key with fallback
const getCategoryName = (category: string) =>
  t(`sidebar.category.${category}`, CATEGORY_FALLBACKS[category] || category);

// ‚úÖ ACCEPTABLE - Iterating over known set
modules.map((m) => t(`support.modules.${m}`, m));
```

**Requirements**:

1. Variable must be from a **known, typed enum** or finite set
2. Always provide a **meaningful fallback** value
3. Fallback should be the English translation or the variable itself

**Why Acceptable**:

- Graceful degradation if key is missing
- Type-safe if using TypeScript enums
- Audit tool will flag as UNSAFE_DYNAMIC but it's a false positive

**Examples in Codebase**:

```typescript
// components/Sidebar.tsx - Line 64
t(`sidebar.category.${category}`, CATEGORY_FALLBACKS[category] || category);

// components/SupportPopup.tsx - Lines 266, 285, 300, 319, 334
t(`support.modules.${m}`, m);
t(`support.categories.${c}`, c);
t(`support.types.${t_val}`, t_val);

// app/finance/expenses/new/page.tsx - Line 894
t(`finance.category.${budget.category.toLowerCase()}`, budget.category);
```

---

### ‚ùå Pattern 3: Dynamic Keys WITHOUT Fallback (UNSAFE)

**Never use dynamic keys without fallback:**

```typescript
// ‚ùå BAD - No fallback, will return key string if missing
const label = t(`user.role.${userRole}`);

// ‚ùå BAD - User input in key (security risk)
const message = t(`errors.${userInput}`);
```

**Why Unsafe**:

- Returns key string if translation is missing (e.g., "user.role.ADMIN")
- User input could inject malicious keys
- No type safety or compile-time checks

**Fix**:

```typescript
// ‚úÖ GOOD - Add fallback
const label = t(`user.role.${userRole}`, userRole.replace(/_/g, " "));

// ‚úÖ BETTER - Use mapping object
const ROLE_LABELS: Record<UserRole, string> = {
  ADMIN: t("user.role.admin"),
  USER: t("user.role.user"),
  VIEWER: t("user.role.viewer"),
};
const label = ROLE_LABELS[userRole] || userRole;
```

---

### ‚ùå Pattern 4: User Input in Keys (DANGEROUS)

**Never use user input directly in translation keys:**

```typescript
// ‚ùå DANGEROUS - User input injection
const msg = t(`errors.${formErrors[field]}`);

// ‚ùå DANGEROUS - Untrusted data
const category = t(`category.${req.query.cat}`);
```

**Why Dangerous**:

- Potential security vulnerability (key injection)
- Unpredictable runtime behavior
- Cannot be audited statically

**Fix**:

```typescript
// ‚úÖ SAFE - Validate and map user input
const ERROR_MESSAGES: Record<string, string> = {
  required: t("errors.validation.required"),
  email: t("errors.validation.email"),
  minLength: t("errors.validation.minLength"),
};
const msg = ERROR_MESSAGES[formErrors[field]] || t("errors.generic");
```

---

## Translation Audit Tool

### Running the Audit

```bash
# Check translation coverage
node scripts/audit-translations.mjs

# Auto-fix missing keys (prompts for translations)
node scripts/audit-translations.mjs --fix
```

### Audit Output

```
üì¶ Catalog stats
  EN keys: 1986
  AR keys: 1986
  Gap    : 0

üìä Summary
  Files scanned: 379
  Keys used    : 1555
  Missing (catalog parity): 0
  Missing (used in code)  : 0

‚ö†Ô∏è  UNSAFE_DYNAMIC: Found template-literal t(`...`) usages
    Files: components/Sidebar.tsx, components/SupportPopup.tsx, ...

‚úÖ Translation audit passed!
```

### Understanding UNSAFE_DYNAMIC Warnings

**What it means**: The audit tool found template literals in `t()` calls that it cannot statically analyze.

**Not necessarily a problem if**:

1. Dynamic part is from a known enum or finite set
2. Fallback value is provided
3. No user input is involved

**Action Required**:

- Review each flagged file
- Verify fallback is present
- Document as safe pattern OR refactor if truly unsafe

---

## Adding New Translations

### Step 1: Add to TranslationContext.tsx

```typescript
// contexts/TranslationContext.tsx

const translations: Record<Language, Record<string, string>> = {
  ar: {
    // ... existing keys
    "myModule.newKey": "ÿßŸÑŸÜÿµ ÿßŸÑÿπÿ±ÿ®Ÿä",
  },
  en: {
    // ... existing keys
    "myModule.newKey": "English text",
  },
};
```

### Step 2: Add to JSON Catalogs (Optional, for consistency)

```json
// i18n/en.json
{
  "myModule": {
    "newKey": "English text"
  }
}

// i18n/ar.json
{
  "myModule": {
    "newKey": "ÿßŸÑŸÜÿµ ÿßŸÑÿπÿ±ÿ®Ÿä"
  }
}
```

### Step 3: Use in Code

```typescript
import { useTranslation } from '@/contexts/TranslationContext';

function MyComponent() {
  const { t } = useTranslation();
  return <div>{t('myModule.newKey')}</div>;
}
```

### Step 4: Verify

```bash
# Run audit to ensure no missing keys
node scripts/audit-translations.mjs

# Check TypeScript compiles
pnpm typecheck
```

---

## RTL (Right-to-Left) Support

### Using isRTL Flag

```typescript
import { useTranslation } from '@/contexts/TranslationContext';

function MyComponent() {
  const { t, isRTL } = useTranslation();

  return (
    <div className={`${isRTL ? 'text-right' : 'text-left'}`}>
      {t('common.welcome')}
    </div>
  );
}
```

### Flexbox Direction

```typescript
// Automatic flex direction reversal for RTL
<div className={`flex ${isRTL ? 'flex-row-reverse' : 'flex-row'}`}>
  <Icon />
  <span>{t('nav.home')}</span>
</div>
```

### Conditional Positioning

```typescript
// Position elements based on text direction
<div className={`absolute ${isRTL ? 'right-0' : 'left-0'}`}>
  {t('common.menu')}
</div>
```

---

## Best Practices

### 1. Always Provide Context

```typescript
// ‚ùå BAD - Ambiguous key
t("name");

// ‚úÖ GOOD - Clear namespace
t("user.profile.name");
t("property.address.name");
```

### 2. Use Semantic Fallbacks

```typescript
// ‚ùå BAD - Meaningless fallback
t("finance.status.pending", "KEY_MISSING");

// ‚úÖ GOOD - Readable fallback
t("finance.status.pending", "Pending");
```

### 3. Keep Keys Lowercase with Dots

```typescript
// ‚ùå BAD
t("Finance.Invoice.CreateNew");
t("finance_invoice_create");

// ‚úÖ GOOD
t("finance.invoice.create");
```

### 4. Group Related Keys

```typescript
// ‚úÖ GOOD - Grouped by feature
"finance.invoice.create";
"finance.invoice.edit";
"finance.invoice.delete";
"finance.invoice.total";
"finance.invoice.status.paid";
"finance.invoice.status.pending";
```

### 5. Avoid Duplication

```typescript
// ‚ùå BAD - Duplicate translations
'common.save': 'Save'
'form.save': 'Save'
'invoice.save': 'Save'

// ‚úÖ GOOD - Reuse common key
'common.save': 'Save'
// Use t('common.save') everywhere
```

---

## Testing Translations

### Manual Testing

1. Switch language in UI (LanguageSelector component)
2. Verify all text updates correctly
3. Check RTL layout for Arabic
4. Test edge cases (long text, special characters)

### Automated Testing

```typescript
import { render, screen } from '@testing-library/react';
import { TranslationProvider } from '@/contexts/TranslationContext';

describe('MyComponent i18n', () => {
  it('renders in English', () => {
    render(
      <TranslationProvider initialLanguage="en">
        <MyComponent />
      </TranslationProvider>
    );
    expect(screen.getByText('Save')).toBeInTheDocument();
  });

  it('renders in Arabic', () => {
    render(
      <TranslationProvider initialLanguage="ar">
        <MyComponent />
      </TranslationProvider>
    );
    expect(screen.getByText('ÿ≠ŸÅÿ∏')).toBeInTheDocument();
  });
});
```

---

## Common Issues & Solutions

### Issue 1: Missing Translation Key

**Symptom**: Key string displayed instead of translation (e.g., "finance.invoice.total")

**Solution**:

1. Check if key exists in TranslationContext.tsx
2. Verify spelling (keys are case-sensitive)
3. Add key to both EN and AR sections
4. Run `node scripts/audit-translations.mjs` to verify

### Issue 2: Translation Audit Fails

**Symptom**: Commit hook rejects due to missing keys

**Solution**:

```bash
# See which keys are missing
node scripts/audit-translations.mjs

# Add missing keys to TranslationContext.tsx
# Then commit again
```

### Issue 3: UNSAFE_DYNAMIC Warning

**Symptom**: Audit tool reports UNSAFE_DYNAMIC for template literals

**Solution**:

1. Check if fallback is present: `t(\`key.${var}\`, fallback)` ‚úÖ
2. If no fallback, add one or refactor to static keys
3. Document as safe pattern if intentional

### Issue 4: RTL Layout Issues

**Symptom**: Arabic text displays incorrectly or layout is broken

**Solution**:

1. Use `isRTL` flag for conditional styling
2. Use Flexbox with `flex-row-reverse` for RTL
3. Test with Arabic language enabled
4. Avoid hardcoded `left`/`right` positioning

---

## Migration from Old System

If you have old code using different translation patterns:

### Before (Old Pattern)

```typescript
// Old: Hardcoded strings
<Button>Save</Button>

// Old: English-only
<span>Invoice Total</span>
```

### After (New Pattern)

```typescript
// New: Internationalized
<Button>{t('common.save')}</Button>

// New: Supports EN/AR
<span>{t('finance.invoice.total')}</span>
```

---

## Checklist for Adding New Features

When adding a new feature with UI text:

- [ ] Identify all user-facing strings
- [ ] Create namespaced translation keys
- [ ] Add keys to both EN and AR in TranslationContext.tsx
- [ ] Use `t()` function for all strings (no hardcoded text)
- [ ] Add fallback values where appropriate
- [ ] Test in both English and Arabic
- [ ] Verify RTL layout works correctly
- [ ] Run `pnpm typecheck` (0 errors)
- [ ] Run `node scripts/audit-translations.mjs` (‚úÖ Pass)
- [ ] Commit with translation keys included

---

## Resources

- **Translation Context**: `contexts/TranslationContext.tsx`
- **JSON Catalogs**: `i18n/en.json`, `i18n/ar.json`
- **Audit Script**: `scripts/audit-translations.mjs`
- **Language Selector**: `components/i18n/LanguageSelector.tsx`
- **Examples**: `components/TopBar.tsx`, `components/Sidebar.tsx`

---

## Questions?

Contact the engineering team or review existing components for examples of proper translation usage.

**Remember**: When in doubt, use a static key with a fallback value! üåç

]]>
</file>

<file path="docs/inventory/paytabs-duplicates.md">
<![CDATA[
=== PayTabs Duplicate Analysis ===

## ./docs/inventory/paytabs-duplicates.md

3 ./docs/inventory/paytabs-duplicates.md
=== PayTabs Duplicate Analysis ===

## ./docs/inventory/paytabs-duplicates.md

3 ./docs/inventory/paytabs-duplicates.md

## ./lib/paytabs.config.ts

7 ./lib/paytabs.config.ts
import 'server-only';
export const PAYTABS_CONFIG = {
profileId: process.env.PAYTABS_PROFILE_ID || '',
serverKey: process.env.PAYTABS_SERVER_KEY || '',
baseUrl: process.env.PAYTABS_BASE_URL || '<https://secure.paytabs.sa>'
};

## ./lib/paytabs.ts

207 ./lib/paytabs.ts
const REGIONS: Record<string,string> = {
KSA: '<https://secure.paytabs.sa>', UAE: '<https://secure.paytabs.com>',
EGYPT:'<https://secure-egypt.paytabs.com>', OMAN:'<https://secure-oman.paytabs.com>',
JORDAN:'<https://secure-jordan.paytabs.com>', KUWAIT:'<https://secure-kuwait.paytabs.com>',
GLOBAL:'<https://secure-global.paytabs.com>'
};

export function paytabsBase(region='GLOBAL'){ return REGIONS[region] || REGIONS.GLOBAL; }

export async function createHppRequest(region:string, payload:any) {
const r = await fetch(`${paytabsBase(region)}/payment/request`, {
method:'POST',
headers: {
'Content-Type':'application/json',
'authorization': process.env.PAYTABS_SERVER_KEY!,
},
body: JSON.stringify(payload)
});
return r.json();
}

## ./qa/tests/README-paytabs-unit-tests.md

15 ./qa/tests/README-paytabs-unit-tests.md
PayTabs unit-style tests

Framework in use

- Playwright Test (@playwright/test) ‚Äî reusing the project's existing test runner. No new dependencies are introduced.

What‚Äôs covered

- paytabsBase: region URL resolution and fallbacks
- createHppRequest: request shape, headers, and error propagation
- createPaymentPage: payload correctness, formatting, language/shipping flags, fallbacks, edge cases (amounts, characters)
- verifyPayment: request payload and error propagation
- validateCallback: placeholder signature behavior
- Constants and helpers: PAYMENT_METHODS, CURRENCIES, and getAvailablePaymentMethods structure

Notes

- Global fetch is stubbed per-test to avoid real network calls.
- Environment variables that are read once at module import (via PAYTABS_CONFIG) are set within each test file before importing the module. Playwright runs each spec file in an isolated worker process, ensuring clean state across files.

## ./qa/tests/api-paytabs-callback.spec.ts

279 ./qa/tests/api-paytabs-callback.spec.ts
/\*\*

- Tests for PayTabs callback API route.
-
- Framework: Jest-style (describe/it/expect). If using Vitest, replace jest.fn with vi.fn and adjust mocks accordingly.
-
- Scenarios covered:
- - Invalid signature -> 401 with { ok: false, error: 'Invalid signature' }
- - Success path (resp_status 'A') with valid positive amount -> 200, status 'PAID', calls generateZATCAQR with correct args
- - Success path with invalid amount (NaN / <= 0) -> 400 with { ok: false, error: 'Invalid amount' }
- - Failure path (non-'A' status) -> 200 with status 'FAILED', does not call generateZATCAQR
- - Malformed JSON body -> 500 with { ok: false, error: 'Callback processing failed' }
    \*/

import type { NextRequest } from 'next/server';

// Attempt to import the route handler from common Next.js locations.
// Adjust as necessary for the repository's actual route path.
let POST: (req: NextRequest) => Promise<Response>;
// These paths are tried in order; the first that succeeds will be used.
// If your project uses a different path, update TARGET_ROUTE_PATH.

## ./qa/tests/lib-paytabs.base-and-hpp.spec.ts

113 ./qa/tests/lib-paytabs.base-and-hpp.spec.ts
// Framework: Playwright Test (@playwright/test)
import { test, expect } from '@playwright/test';

test.describe('lib/paytabs - paytabsBase & createHppRequest', () => {
test('paytabsBase resolves region URLs and falls back to GLOBAL', async () => {
const { paytabsBase } = await import('../../src/lib/paytabs');

    expect(paytabsBase('KSA')).toBe('https://secure.paytabs.sa');
    expect(paytabsBase('UAE')).toBe('https://secure.paytabs.com');
    expect(paytabsBase('EGYPT')).toBe('https://secure-egypt.paytabs.com');
    expect(paytabsBase('OMAN')).toBe('https://secure-oman.paytabs.com');
    expect(paytabsBase('JORDAN')).toBe('https://secure-jordan.paytabs.com');
    expect(paytabsBase('KUWAIT')).toBe('https://secure-kuwait.paytabs.com');

    // Fallbacks
    expect(paytabsBase()).toBe('https://secure-global.paytabs.com');
    expect(paytabsBase('UNKNOWN' as any)).toBe('https://secure-global.paytabs.com');
    expect(paytabsBase('' as any)).toBe('https://secure-global.paytabs.com');
    expect(paytabsBase(null as any)).toBe('https://secure-global.paytabs.com');

## ./qa/tests/lib-paytabs.create-payment.custom-base.spec.ts

98 ./qa/tests/lib-paytabs.create-payment.custom-base.spec.ts
// Framework: Playwright Test (@playwright/test)
import { test, expect } from '@playwright/test';

test.describe('lib/paytabs - custom base URL via env', () => {
test('createPaymentPage uses PAYTABS_BASE_URL when provided', async () => {
process.env.PAYTABS_BASE_URL = '<https://custom.paytabs.example>';
process.env.PAYTABS_PROFILE_ID = 'custom-profile';
process.env.PAYTABS_SERVER_KEY = 'custom-key';

    const { createPaymentPage } = await import('../../src/lib/paytabs');

    const originalFetch = globalThis.fetch;
    const calls: any[] = [];
    globalThis.fetch = ((...args: any[]) => {
      calls.push(args);
      return Promise.resolve({ json: async () => ({ redirect_url: 'url', tran_ref: 'ref' }) } as any);
    }) as any;

    try {
      await createPaymentPage({

## ./qa/tests/lib-paytabs.create-payment.default.spec.ts

269 ./qa/tests/lib-paytabs.create-payment.default.spec.ts
// Framework: Playwright Test (@playwright/test)
import { test, expect } from '@playwright/test';

test.describe('lib/paytabs - createPaymentPage (default base URL)', () => {
test('creates payment page successfully and posts correct payload', async () => {
delete process.env.PAYTABS_BASE_URL; // force default to GLOBAL
process.env.PAYTABS_PROFILE_ID = 'test-profile-id';
process.env.PAYTABS_SERVER_KEY = 'test-server-key';

    const { createPaymentPage } = await import('../../src/lib/paytabs');

    const validRequest = {
      amount: 150.5,
      currency: 'SAR',
      customerDetails: {
        name: 'John Doe',
        email: 'john@example.com',
        phone: '+966501234567',
        address: '123 Main St',
        city: 'Riyadh',

## ./qa/tests/lib-paytabs.spec.ts

403 ./qa/tests/lib-paytabs.spec.ts
/\*\*

- Tests for PayTabs integration helpers.
- Testing framework: Jest (ts-jest or Babel/Jest setup assumed).
- If your project uses Vitest/Mocha, adapt describe/it/expect/mocking accordingly.
  \*/

// We will dynamically import the module under test using a relative path guess.
// Update the import below to match your actual module path if different.
// Try common locations in order via require.resolve in a try/catch chain.
interface PayTabsHelpers {
// Add expected function signatures here, e.g.:
// createPayment(params: CreatePaymentParams): Promise<PaymentResult>;
// verifyPayment(id: string): Promise<VerificationResult>;
// For now, use index signature to allow any property, but avoid `any` type.
[key: string]: unknown;
}
let lib: PayTabsHelpers;
// Define the exact path to the PayTabs helpers module here.
const PAYTABS_HELPERS_MODULE_PATH = '../../lib-paytabs'; // <-- Update this path as needed
function loadModule() {

## ./qa/tests/lib-paytabs.verify-and-utils.spec.ts

67 ./qa/tests/lib-paytabs.verify-and-utils.spec.ts
// Framework: Playwright Test (@playwright/test)
import { test, expect } from '@playwright/test';

test.describe('lib/paytabs - validateCallback, constants, and helpers', () => {
test('validateCallback: signature equals generated value (placeholder empty string)', async () => {
const { validateCallback } = await import('../../src/lib/paytabs');

    // Placeholder generateSignature returns ''
    expect(validateCallback({}, '')).toBe(true);
    expect(validateCallback({ any: 'thing' }, '')).toBe(true);

    expect(validateCallback({}, 'x')).toBe(false);
    expect(validateCallback(null as any, 'x')).toBe(false);
    expect(validateCallback({ a: 1 }, undefined as any)).toBe(false);

});

test('PAYMENT_METHODS and CURRENCIES have expected mappings', async () => {
const { PAYMENT_METHODS, CURRENCIES } = await import('../../src/lib/paytabs');

    expect(PAYMENT_METHODS).toMatchObject({

## ./services/paytabs.ts

104 ./services/paytabs.ts
import PaymentMethod from '../db/models/PaymentMethod';
import Subscription from '../db/models/Subscription';
import OwnerGroup from '../db/models/OwnerGroup';
import { provisionSubscriber } from './provision';

export interface NormalizedPayTabsPayload {
tran_ref?: string;
respStatus?: string;
token?: string;
customer_email?: string;
cart_id?: string;
amount?: number;
currency?: string;
maskedCard?: string;
}

export function normalizePayTabsPayload(data: any): NormalizedPayTabsPayload {
const paymentInfo = data?.payment_info || {};
return {
tran_ref: data?.tran_ref || data?.tranRef,

## ./src/lib/paytabs.config.ts

7 ./src/lib/paytabs.config.ts
import 'server-only';
export const PAYTABS_CONFIG = {
profileId: process.env.PAYTABS_PROFILE_ID || '',
serverKey: process.env.PAYTABS_SERVER_KEY || '',
baseUrl: process.env.PAYTABS_BASE_URL || '<https://secure.paytabs.sa>'
};

## ./src/lib/paytabs.ts

207 ./src/lib/paytabs.ts
const REGIONS: Record<string,string> = {
KSA: '<https://secure.paytabs.sa>', UAE: '<https://secure.paytabs.com>',
EGYPT:'<https://secure-egypt.paytabs.com>', OMAN:'<https://secure-oman.paytabs.com>',
JORDAN:'<https://secure-jordan.paytabs.com>', KUWAIT:'<https://secure-kuwait.paytabs.com>',
GLOBAL:'<https://secure-global.paytabs.com>'
};

export function paytabsBase(region='GLOBAL'){ return REGIONS[region] || REGIONS.GLOBAL; }

export async function createHppRequest(region:string, payload:any) {
const r = await fetch(`${paytabsBase(region)}/payment/request`, {
method:'POST',
headers: {
'Content-Type':'application/json',
'authorization': process.env.PAYTABS_SERVER_KEY!,
},
body: JSON.stringify(payload)
});
return r.json();
}

## ./src/services/paytabs.ts

104 ./src/services/paytabs.ts
import PaymentMethod from '../db/models/PaymentMethod';
import Subscription from '../db/models/Subscription';
import OwnerGroup from '../db/models/OwnerGroup';
import { provisionSubscriber } from './provision';

export interface NormalizedPayTabsPayload {
tran_ref?: string;
respStatus?: string;
token?: string;
customer_email?: string;
cart_id?: string;
amount?: number;
currency?: string;
maskedCard?: string;
}

export function normalizePayTabsPayload(data: any): NormalizedPayTabsPayload {
const paymentInfo = data?.payment_info || {};
return {
tran_ref: data?.tran_ref || data?.tranRef,

## ./tests/paytabs.test.ts

379 ./tests/paytabs.test.ts
/\*\*

- Comprehensive tests for PayTabs integration helpers.
- Testing library/framework: Vitest
-
- These tests attempt to import the PayTabs module from common paths.
- If import fails, adjust the candidate paths in importPaytabs() to match your project.
  \*/

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';

// Keep a pristine copy of the environment
const ORIGINAL_ENV = { ...process.env };

beforeEach(() => {
vi.resetModules();
vi.restoreAllMocks();
// Reset environment for each test
process.env = { ...ORIGINAL_ENV };
});

## ./tests/unit/api/api-paytabs-callback.spec.ts

283 ./tests/unit/api/api-paytabs-callback.spec.ts
/\*\*

- Tests for PayTabs callback API route.
-
- Framework: Jest-style (describe/it/expect). If using Vitest, replace jest.fn with vi.fn and adjust mocks accordingly.
-
- Scenarios covered:
- - Invalid signature -> 401 with { ok: false, error: 'Invalid signature' }
- - Success path (resp_status 'A') with valid positive amount -> 200, status 'PAID', calls generateZATCAQR with correct args
- - Success path with invalid amount (NaN / <= 0) -> 400 with { ok: false, error: 'Invalid amount' }
- - Failure path (non-'A' status) -> 200 with status 'FAILED', does not call generateZATCAQR
- - Malformed JSON body -> 500 with { ok: false, error: 'Callback processing failed' }
    \*/

import type { NextRequest } from 'next/server';

// Attempt to import the route handler from common Next.js locations.
// Adjust as necessary for the repository's actual route path.
let POST: (req: NextRequest) => Promise<Response>;
// These paths are tried in order; the first that succeeds will be used.
// If your project uses a different path, update TARGET_ROUTE_PATH.

## ./tests/unit/api/api-paytabs.spec.ts

223 ./tests/unit/api/api-paytabs.spec.ts
/\*\*

- Tests for PayTabs payment page creation route handler (POST).
- Framework: Jest (TypeScript). If using Vitest, replace jest._with vi._ equivalents.
  \*/
  import { describe, test, expect, jest, beforeEach, beforeAll, afterEach } from '@jest/globals';
  import type { NextRequest } from 'next/server'

// Mock next/server to isolate NextResponse and avoid runtime coupling
jest.mock('next/server', () => {
const actual = jest.requireActual('next/server')
// Provide a minimal NextResponse.json that returns a standard Response-like object
return {
...actual,
NextResponse: {
json: (data: any, init?: ResponseInit) => {
const status = init?.status ?? 200
// Return a Response-like object with status and json() for assertions
return {
status,
async json() {

]]>
</file>

<file path="docs/migrations/REFUND_METHOD_V2.md">
<![CDATA[
# Souq Refund Method Migration Guide

**Version**: v2.0.26  
**Date**: November 2025  
**Impact**: BREAKING CHANGE  
**Affected Systems**: Souq Marketplace, Returns & RMA

---

## Overview

The Souq refund system has been updated to replace the deprecated `store_credit` refund method with a unified `wallet` system. This change improves consistency across the platform and provides users with a better refund experience.

---

## What Changed

### Before (v2.0.25 and earlier)
```typescript
// Refund to store credit
const refundRequest = {
  rmaId: "RMA-12345",
  refundMethod: "store_credit",  // ‚ùå DEPRECATED
  amount: 150.00
};
```

### After (v2.0.26+)
```typescript
// Refund to digital wallet
const refundRequest = {
  rmaId: "RMA-12345",
  refundMethod: "wallet",  // ‚úÖ NEW
  amount: 150.00
};
```

---

## Affected Endpoints

### API Route: `/api/souq/returns/refund`

**Method**: `POST`

**Old Valid Methods** (v2.0.25):
- `original_payment`
- `store_credit` ‚ùå
- `bank_transfer`

**New Valid Methods** (v2.0.26+):
- `original_payment`
- `wallet` ‚úÖ
- `bank_transfer`

---

## Migration Steps

### For API Clients

**Step 1**: Update your refund request payloads
```diff
{
  "rmaId": "RMA-12345",
- "refundMethod": "store_credit",
+ "refundMethod": "wallet",
  "amount": 150.00
}
```

**Step 2**: Update validation logic
```typescript
// Before
const validMethods = ['original_payment', 'store_credit', 'bank_transfer'];

// After
const validMethods = ['original_payment', 'wallet', 'bank_transfer'];
```

**Step 3**: Update error handling
```typescript
// The API will now return 400 if you send "store_credit"
try {
  const response = await fetch('/api/souq/returns/refund', {
    method: 'POST',
    body: JSON.stringify({
      refundMethod: 'store_credit' // ‚ùå This will fail
    })
  });
} catch (error) {
  // Expected error:
  // { error: 'Invalid refund method. Valid options: original_payment, wallet, bank_transfer' }
}
```

---

## Technical Details

### Database Changes

**RMA Model** (`server/models/souq/RMA.ts`):
```typescript
// Refund method enum updated
refundMethod: {
  type: String,
  enum: ['original_payment', 'wallet', 'bank_transfer'], // 'store_credit' removed
  required: function() {
    return this.status === 'refund_processing' || this.status === 'refunded';
  }
}
```

### Service Layer Changes

**Returns Service** (`services/souq/returns-service.ts`):
```typescript
// Method validation updated
async processRefund(rmaId: string, refundMethod: 'original_payment' | 'wallet' | 'bank_transfer') {
  // Validation now rejects 'store_credit'
  const validMethods = ['original_payment', 'wallet', 'bank_transfer'];
  if (!validMethods.includes(refundMethod)) {
    throw new Error(`Invalid refund method: ${refundMethod}`);
  }
  
  // Process refund...
}
```

---

## Backward Compatibility

### ‚ö†Ô∏è Breaking Change Notice

This is a **BREAKING CHANGE** with **NO backward compatibility**. The `store_credit` option has been completely removed and will cause validation errors if used.

**Timeline**:
- **Deprecated**: Never formally deprecated (direct removal)
- **Removed**: v2.0.26 (November 2025)
- **Migration Window**: Immediate (no grace period)

---

## Testing Your Migration

### Test Case 1: Verify wallet refunds work
```bash
curl -X POST https://your-domain.com/api/souq/returns/refund \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "rmaId": "RMA-TEST-001",
    "refundMethod": "wallet",
    "amount": 100.00,
    "reason": "Test wallet refund"
  }'

# Expected: 200 OK with refund confirmation
```

### Test Case 2: Verify store_credit is rejected
```bash
curl -X POST https://your-domain.com/api/souq/returns/refund \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "rmaId": "RMA-TEST-002",
    "refundMethod": "store_credit",
    "amount": 100.00
  }'

# Expected: 400 Bad Request
# {
#   "error": "Invalid refund method. Valid options: original_payment, wallet, bank_transfer"
# }
```

---

## User Impact

### Customer Experience

**Before**:
- Refund credited to "store credit" balance
- Could only use credit within the platform
- No ability to withdraw funds

**After**:
- Refund credited to digital "wallet"
- Can use wallet balance for any Fixzit service (FM, Souq, Aqar)
- Future: Potential to withdraw to bank account

### Benefits
- ‚úÖ Unified balance across all Fixzit modules
- ‚úÖ Better user experience (one wallet vs multiple credit systems)
- ‚úÖ Clearer financial tracking
- ‚úÖ Enables future wallet features (withdrawals, P2P transfers)

---

## Rollback Plan

If critical issues arise, you can rollback to v2.0.25:

```bash
# Rollback deployment
git checkout v2.0.25
vercel deploy --prod

# Or use Vercel dashboard: Deployments ‚Üí [Select v2.0.25] ‚Üí "Promote to Production"
```

**Note**: Any refunds processed with `wallet` method during v2.0.26 deployment will need manual reconciliation after rollback.

---

## Support & Questions

### Common Issues

**Q: I'm getting 400 errors on refund requests**  
A: Check if you're still using `store_credit`. Update to `wallet`.

**Q: What happens to existing store credit balances?**  
A: Store credit balances were migrated to wallet balances before this release. No user data was lost.

**Q: Can users still see their old store credit history?**  
A: Yes, historical transactions maintain their original labels, but new refunds use "wallet".

### Getting Help

- **GitHub Issues**: [github.com/EngSayh/Fixzit/issues](https://github.com/EngSayh/Fixzit/issues)
- **API Documentation**: `openapi.yaml` (updated with breaking change notice)
- **Team Contact**: support@fixzit.co

---

## Checklist for API Clients

- [ ] Updated refund method from `store_credit` to `wallet`
- [ ] Updated validation logic to accept `wallet`
- [ ] Updated error handling for 400 responses
- [ ] Tested wallet refunds in staging environment
- [ ] Verified store_credit requests are rejected
- [ ] Updated internal documentation
- [ ] Notified end users (if applicable)
- [ ] Deployed changes to production

---

**Document Version**: 1.0  
**Last Updated**: November 24, 2025  
**Author**: Fixzit Engineering Team

]]>
</file>

<file path="docs/modules/ATS_CAREERS_FINAL_REVIEW.md">
<![CDATA[
# Fixzit ATS & Careers ‚Äì Final Review Summary (Software Engineer & Architect)

**Status:** Architecture Review Complete  
**Date:** November 16, 2025  
**Reviewer:** Senior Software Architect  
**Alignment:** SDD, Blueprint Bible vFinal, Master Governance V5, STRICT v4

---

## Context

Based on all ATS/Careers code snippets in the repo and the Fixzit blueprints (SDD, Blueprint Bible vFinal, Master Governance V5, STRICT v4), the module is a solid start but not yet at enterprise level. It must be fully aligned with:

- Multi-tenant, RBAC-driven SaaS design (org_id on all records; org-scoped queries)
- Sidebar & Top Bar governance with single global layout, RTL/LTR, dark mode, brand tokens (#0061A8, #00A859, #FFB400)
- STRICT v4 Halt‚ÄìFix‚ÄìVerify with 0 console/network/build errors per page√órole and enforced artifacts
- The ATS belongs under **HR ‚Üí Recruitment (ATS)** and must behave like every other Fixzit module (Dashboard, Work Orders, Finance, etc.), not as a side project

---

## 1) Architecture & Integration

### ‚úÖ Current State

- Next.js App Router + Mongo/Mongoose for ATS domain
- Basic job posting and application workflow

### üîß Required Changes

**1.1 Stack Standardization**

- ‚úÖ **Keep:** Next.js App Router + Mongo/Mongoose for the ATS domain only
- ‚ö†Ô∏è **Clarify:** This is consistent with the "mongos database" decision for ATS
- ‚úÖ **Note:** Core FM domains remain on main DB as per SDD

**1.2 Integration Requirements**

```typescript
// Integrate with existing building blocks:

// A. Notifications Service
import { sendNotification } from "@/services/notifications/fm-notification-engine";

// New application received
await sendNotification({
  type: "ATS_APPLICATION_RECEIVED",
  recipients: [hiringManager, hrTeam],
  data: { candidateName, jobTitle, applicationId },
  channels: ["email", "in-app"],
});

// B. Approvals Engine (DoA)
import { createApproval } from "@/lib/fm-approval-engine";

// Job posting approval
await createApproval({
  type: "JOB_POSTING",
  entityId: jobId,
  requestedBy: hrUserId,
  orgId,
  metadata: { position, salary, department },
});

// C. Finance Integration (Optional - Phase 2)
import { createExpense } from "@/server/finance/budget.service";

// Track recruitment costs
await createExpense({
  category: "RECRUITMENT",
  amount: jobBoardCost,
  linkedEntity: { type: "JOB", id: jobId },
  orgId,
});
```

**1.3 External Integrations (Phase 2)**

```typescript
// Webhooks & Feeds for external boards
// app/api/ats/webhooks/linkedin/route.ts
export async function POST(req: NextRequest) {
  // LinkedIn integration for job posting sync
  // Behind feature flag: LINKEDIN_INTEGRATION_ENABLED
}

// app/api/ats/feeds/indeed/route.ts
export async function GET(req: NextRequest) {
  // Generate Indeed XML feed
  // Format: Indeed Apply Now format
}
```

**1.4 Tooling Standards**

- ‚úÖ **Zod** for API validation
- ‚úÖ **React Hook Form** for forms
- ‚úÖ **SWR** for client-side data fetching
- ‚úÖ **pdf-parse** for resume parsing (Node.js, not Python)
- ‚úÖ **string-similarity** for fuzzy matching (Node.js)

---

## 2) Multi-Tenancy & RBAC

### üîß Critical Fixes Required

**2.1 Enforce orgId Consistency**

```typescript
// server/models/ats/Job.ts
import { Schema, model } from "mongoose";
import { ObjectId } from "mongodb";

interface IJob {
  _id: ObjectId;
  orgId: ObjectId; // ‚ö†Ô∏è MUST be ObjectId, not string/number
  title: string;
  department: string;
  // ... other fields
}

const JobSchema = new Schema<IJob>({
  orgId: { type: Schema.Types.ObjectId, required: true, index: true },
  // ... rest of schema
});

// Compound indexes for multi-tenancy
JobSchema.index({ orgId: 1, status: 1, createdAt: -1 });
JobSchema.index({ orgId: 1, slug: 1 }, { unique: true });

export const Job = model<IJob>("Job", JobSchema);
```

**2.2 Org-Scoped Queries**

```typescript
// ‚ùå WRONG - No org scoping
const jobs = await Job.find({ status: "open" });

// ‚úÖ CORRECT - Always scope by orgId
const jobs = await Job.find({
  orgId: session.user.orgId,
  status: "open",
});
```

**2.3 ATS RBAC Matrix**

| Role                | Jobs                 | Candidates    | Applications  | Interviews      | Offers    | Analytics     |
| ------------------- | -------------------- | ------------- | ------------- | --------------- | --------- | ------------- |
| **Super Admin**     | Read All (Audit)     | Read All      | Read All      | Read All        | Read All  | Global View   |
| **Corporate Admin** | Full CRUD            | Full CRUD     | Full CRUD     | Full CRUD       | Full CRUD | Org View      |
| **HR Manager**      | Full CRUD            | Full CRUD     | Full CRUD     | Full CRUD       | Approve   | Org View      |
| **Hiring Manager**  | Read/Update Assigned | Read Assigned | Read Assigned | Create/Update   | Request   | Assigned Only |
| **Interviewer**     | Read Assigned        | Read Assigned | Read Assigned | Update Assigned | None      | None          |
| **Candidate**       | Read Applied         | None          | Read Own      | Read Own        | Read Own  | None          |

**2.4 RBAC Middleware**

```typescript
// lib/ats-auth-middleware.ts
import { auth } from "@/auth";
import { NextRequest } from "next/server";

export async function atsRBACCheck(
  req: NextRequest,
  requiredRole: "super_admin" | "hr" | "hiring_manager" | "interviewer",
) {
  const session = await auth();

  if (!session?.user) {
    return { authorized: false, error: "Unauthorized" };
  }

  const { role, orgId } = session.user;

  // Super Admin can impersonate any tenant
  if (role === "SUPER_ADMIN") {
    const impersonateOrgId = req.headers.get("X-Impersonate-Org");
    return {
      authorized: true,
      orgId: impersonateOrgId || orgId,
      isSuperAdmin: true,
    };
  }

  // Role-based access
  const roleMap = {
    super_admin: ["SUPER_ADMIN"],
    hr: ["SUPER_ADMIN", "HR_MANAGER", "CORPORATE_ADMIN"],
    hiring_manager: ["SUPER_ADMIN", "HR_MANAGER", "HIRING_MANAGER"],
    interviewer: ["SUPER_ADMIN", "HR_MANAGER", "HIRING_MANAGER", "INTERVIEWER"],
  };

  if (!roleMap[requiredRole]?.includes(role)) {
    return { authorized: false, error: "Forbidden" };
  }

  return { authorized: true, orgId, role };
}
```

---

## 3) UI/UX & Governance Compliance

### üîß Critical Fixes Required

**3.1 Sidebar Integration**

```typescript
// config/navigation.ts
export const sidebarTree = [
  // ... existing modules
  {
    id: "hr",
    label: "Human Resources",
    icon: Users,
    children: [
      { id: "hr-dashboard", label: "Dashboard", path: "/hr" },
      { id: "hr-employees", label: "Employees", path: "/hr/employees" },
      { id: "hr-attendance", label: "Attendance", path: "/hr/attendance" },
      { id: "hr-payroll", label: "Payroll", path: "/hr/payroll" },
      {
        id: "hr-recruitment",
        label: "Recruitment (ATS)",
        icon: Briefcase,
        path: "/hr/ats",
        children: [
          { id: "ats-jobs", label: "Jobs", path: "/hr/ats/jobs" },
          { id: "ats-pipeline", label: "Pipeline", path: "/hr/ats/pipeline" },
          {
            id: "ats-candidates",
            label: "Candidates",
            path: "/hr/ats/candidates",
          },
          {
            id: "ats-interviews",
            label: "Interviews",
            path: "/hr/ats/interviews",
          },
          { id: "ats-offers", label: "Offers", path: "/hr/ats/offers" },
          {
            id: "ats-analytics",
            label: "Analytics",
            path: "/hr/ats/analytics",
          },
        ],
      },
    ],
  },
];
```

**3.2 Tab Layout (Monday-style)**

```typescript
// app/hr/ats/page.tsx
'use client';

import { Tabs } from '@/components/Tabs';
import { Briefcase, Users, Calendar, FileText, TrendingUp, GitBranch } from 'lucide-react';

const atsTabs = [
  { id: 'jobs', label: 'Jobs', icon: Briefcase, component: JobsView },
  { id: 'pipeline', label: 'Pipeline', icon: GitBranch, component: PipelineView },
  { id: 'candidates', label: 'Candidates', icon: Users, component: CandidatesView },
  { id: 'interviews', label: 'Interviews', icon: Calendar, component: InterviewsView },
  { id: 'offers', label: 'Offers', icon: FileText, component: OffersView },
  { id: 'analytics', label: 'Analytics', icon: TrendingUp, component: AnalyticsView }
];

export default function ATSPage() {
  return (
    <div className="h-full">
      {/* Use existing Header component - DO NOT create new header */}
      <Tabs tabs={atsTabs} defaultTab="jobs" />
    </div>
  );
}
```

**3.3 Layout Freeze Compliance**

```typescript
// ‚ùå WRONG - Creates duplicate header
export default function ATSLayout({ children }) {
  return (
    <div>
      <ATSHeader /> {/* DON'T DO THIS */}
      <ATSSidebar /> {/* DON'T DO THIS */}
      {children}
    </div>
  );
}

// ‚úÖ CORRECT - Uses global layout
// No custom layout needed - uses app/layout.tsx
export default function ATSPage() {
  return <ATSContent />; // Just the content
}
```

**3.4 RTL/Dark Mode/Language Selector**

```typescript
// Must respect existing theme context
import { useTheme } from '@/contexts/ThemeContext';
import { useTranslation } from '@/contexts/TranslationContext';

export function ATSJobCard({ job }) {
  const { theme } = useTheme(); // 'light' | 'dark'
  const { t, locale } = useTranslation(); // 'en' | 'ar'
  const isRTL = locale === 'ar';

  return (
    <div
      className={`card ${theme === 'dark' ? 'bg-gray-800' : 'bg-white'}`}
      dir={isRTL ? 'rtl' : 'ltr'}
    >
      <h3>{job.title[locale]}</h3>
      <p>{t('ats.jobs.location')}: {job.location}</p>
    </div>
  );
}
```

**3.5 Public Careers Page**

```typescript
// app/careers/page.tsx
import { Header } from '@/components/public/Header'; // Public header
import { Footer } from '@/components/public/Footer'; // Public footer

export default async function CareersPage() {
  return (
    <>
      <Header /> {/* Brand, Language Toggle, Login */}
      <main className="container mx-auto px-4 py-8">
        <h1 className="text-4xl font-bold text-[#0061A8]">
          Join Our Team
        </h1>
        {/* Job listings */}
      </main>
      <Footer /> {/* Company info, links, social */}
    </>
  );
}
```

---

## 4) Features Missing / Stubbed

### üîß Implementation Required

**4.1 Resume Parsing (Node.js)**

```typescript
// lib/ats/resume-parser.ts
import pdfParse from "pdf-parse";
import stringSimilarity from "string-similarity";

interface ParsedResume {
  email?: string;
  phone?: string;
  name?: string;
  skills: string[];
  experience?: string;
  education?: string;
}

export async function parseResume(buffer: Buffer): Promise<ParsedResume> {
  // Extract text from PDF
  const pdfData = await pdfParse(buffer);
  const text = pdfData.text;

  // Extract email
  const emailMatch = text.match(/[\w.-]+@[\w.-]+\.\w+/);
  const email = emailMatch?.[0];

  // Extract phone (Saudi format)
  const phoneMatch = text.match(/\+?966[\s-]?\d{2}[\s-]?\d{3}[\s-]?\d{4}/);
  const phone = phoneMatch?.[0];

  // Extract name (heuristic: first line with 2-4 words)
  const lines = text.split("\n").filter((l) => l.trim());
  const nameMatch = lines.find((l) => {
    const words = l.trim().split(/\s+/);
    return words.length >= 2 && words.length <= 4 && /^[A-Za-z\s]+$/.test(l);
  });
  const name = nameMatch?.trim();

  // Extract skills (keywords)
  const skillKeywords = [
    "javascript",
    "typescript",
    "react",
    "node",
    "python",
    "java",
    "sql",
    "mongodb",
    "aws",
    "docker",
    "kubernetes",
    "leadership",
    "management",
    "communication",
  ];

  const skills = skillKeywords.filter((skill) =>
    text.toLowerCase().includes(skill.toLowerCase()),
  );

  return { email, phone, name, skills, experience: text, education: text };
}

export function scoreCandidate(
  candidateSkills: string[],
  requiredSkills: string[],
  niceToHaveSkills: string[] = [],
): number {
  if (requiredSkills.length === 0) return 0;

  let score = 0;
  let maxScore = requiredSkills.length * 10 + niceToHaveSkills.length * 5;

  // Required skills (10 points each)
  for (const required of requiredSkills) {
    const bestMatch = stringSimilarity.findBestMatch(
      required.toLowerCase(),
      candidateSkills.map((s) => s.toLowerCase()),
    );

    if (bestMatch.bestMatch.rating > 0.7) {
      score += 10 * bestMatch.bestMatch.rating;
    }
  }

  // Nice-to-have skills (5 points each)
  for (const nice of niceToHaveSkills) {
    const bestMatch = stringSimilarity.findBestMatch(
      nice.toLowerCase(),
      candidateSkills.map((s) => s.toLowerCase()),
    );

    if (bestMatch.bestMatch.rating > 0.7) {
      score += 5 * bestMatch.bestMatch.rating;
    }
  }

  return Math.round((score / maxScore) * 100);
}
```

**4.2 ICS Calendar Generation (Node.js)**

```typescript
// lib/ats/ics-generator.ts
export interface ICSEvent {
  title: string;
  description: string;
  location: string;
  startTime: Date;
  endTime: Date;
  attendees: string[];
  organizerEmail: string;
}

export function generateICS(event: ICSEvent): string {
  const formatDate = (date: Date): string => {
    return date.toISOString().replace(/[-:]/g, "").split(".")[0] + "Z";
  };

  const ics = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Fixzit//ATS Interview Scheduler//EN
CALSCALE:GREGORIAN
METHOD:REQUEST
BEGIN:VEVENT
UID:${Date.now()}@fixzit.com
DTSTAMP:${formatDate(new Date())}
DTSTART:${formatDate(event.startTime)}
DTEND:${formatDate(event.endTime)}
SUMMARY:${event.title}
DESCRIPTION:${event.description.replace(/\n/g, "\\n")}
LOCATION:${event.location}
ORGANIZER:CN=Fixzit ATS:MAILTO:${event.organizerEmail}
${event.attendees.map((email) => `ATTENDEE:MAILTO:${email}`).join("\n")}
STATUS:CONFIRMED
SEQUENCE:0
END:VEVENT
END:VCALENDAR`;

  return ics;
}

// Usage in interview scheduling
import { sendEmail } from "@/lib/email";

export async function scheduleInterview(
  interview: Interview,
  candidate: Candidate,
  interviewer: User,
) {
  const icsContent = generateICS({
    title: `Interview: ${candidate.name} - ${interview.jobTitle}`,
    description: `Interview for ${interview.jobTitle} position\n\nCandidate: ${candidate.name}\nInterviewer: ${interviewer.name}`,
    location: interview.location || "Virtual (Link to be shared)",
    startTime: interview.scheduledAt,
    endTime: new Date(interview.scheduledAt.getTime() + 60 * 60 * 1000), // 1 hour
    attendees: [candidate.email, interviewer.email],
    organizerEmail: "ats@fixzit.com",
  });

  // Send calendar invite
  await sendEmail(
    [candidate.email, interviewer.email],
    `Interview Scheduled: ${interview.jobTitle}`,
    `Your interview has been scheduled. Please find the calendar invite attached.`,
    [
      {
        filename: "interview.ics",
        content: Buffer.from(icsContent),
        contentType: "text/calendar; charset=utf-8; method=REQUEST",
      },
    ],
  );
}
```

**4.3 Offer PDF Generation**

```typescript
// lib/ats/offer-pdf.ts
import PDFDocument from "pdfkit";

export async function generateOfferPDF(offer: Offer): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument();
    const chunks: Buffer[] = [];

    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Header
    doc.fontSize(24).text("Fixzit", { align: "center" });
    doc.fontSize(16).text("Employment Offer Letter", { align: "center" });
    doc.moveDown(2);

    // Offer details
    doc.fontSize(12);
    doc.text(`Date: ${new Date().toLocaleDateString()}`);
    doc.moveDown();
    doc.text(`Dear ${offer.candidateName},`);
    doc.moveDown();
    doc.text(`We are pleased to offer you the position of ${offer.jobTitle}.`);
    doc.moveDown();

    // Terms
    doc.text("Position Details:", { underline: true });
    doc.text(`Title: ${offer.jobTitle}`);
    doc.text(`Department: ${offer.department}`);
    doc.text(`Location: ${offer.location}`);
    doc.text(`Start Date: ${offer.startDate.toLocaleDateString()}`);
    doc.moveDown();

    doc.text("Compensation:", { underline: true });
    doc.text(
      `Base Salary: SAR ${offer.salary.toLocaleString()} per ${offer.salaryPeriod}`,
    );
    if (offer.benefits?.length) {
      doc.text(`Benefits: ${offer.benefits.join(", ")}`);
    }
    doc.moveDown();

    // Signature
    doc.moveDown(3);
    doc.text(
      "Please sign and return this offer by " +
        offer.expiresAt.toLocaleDateString(),
    );
    doc.moveDown(2);
    doc.text("Accepted by: ________________________  Date: __________");

    doc.end();
  });
}
```

**4.4 Job Board Feeds**

```typescript
// app/api/ats/feeds/indeed/route.ts
import { NextResponse } from "next/server";
import { Job } from "@/server/models/ats/Job";

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const orgId = searchParams.get("orgId");

  const jobs = await Job.find({
    orgId,
    status: "open",
    publishToIndeed: true,
  }).lean();

  // Generate Indeed XML feed
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<source>
  <publisher>Fixzit</publisher>
  <publisherurl>https://fixzit.com</publisherurl>
  ${jobs
    .map(
      (job) => `
  <job>
    <title><![CDATA[${job.title}]]]]><![CDATA[></title>
    <date>${job.createdAt.toISOString().split("T")[0]}</date>
    <referencenumber>${job._id}</referencenumber>
    <url><![CDATA[https://fixzit.com/careers/${job.slug}]]]]><![CDATA[></url>
    <company><![CDATA[Fixzit]]]]><![CDATA[></company>
    <city>${job.location.city}</city>
    <country>${job.location.country}</country>
    <description><![CDATA[${job.description}]]]]><![CDATA[></description>
  </job>
  `,
    )
    .join("\n")}
</source>`;

  return new NextResponse(xml, {
    headers: { "Content-Type": "application/xml" },
  });
}

// app/careers/[slug]/page.tsx - Add JSON-LD for Google Jobs
export async function generateMetadata({ params }) {
  const job = await Job.findOne({ slug: params.slug });

  const jsonLd = {
    "@context": "https://schema.org/",
    "@type": "JobPosting",
    title: job.title,
    description: job.description,
    datePosted: job.createdAt.toISOString(),
    validThrough: job.applicationDeadline?.toISOString(),
    employmentType: job.employmentType, // FULL_TIME, PART_TIME, etc.
    hiringOrganization: {
      "@type": "Organization",
      name: "Fixzit",
      sameAs: "https://fixzit.com",
      logo: "https://fixzit.com/logo.png",
    },
    jobLocation: {
      "@type": "Place",
      address: {
        "@type": "PostalAddress",
        addressLocality: job.location.city,
        addressCountry: job.location.country,
      },
    },
    baseSalary: job.salaryRange
      ? {
          "@type": "MonetaryAmount",
          currency: "SAR",
          value: {
            "@type": "QuantitativeValue",
            minValue: job.salaryRange.min,
            maxValue: job.salaryRange.max,
            unitText: "YEAR",
          },
        }
      : undefined,
  };

  return {
    title: job.title,
    description: job.description.substring(0, 160),
    other: {
      "application/ld+json": JSON.stringify(jsonLd),
    },
  };
}
```

**4.5 Analytics Dashboard**

```typescript
// app/api/ats/analytics/route.ts
import { Application } from "@/server/models/ats/Application";
import { ObjectId } from "mongodb";

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const orgId = searchParams.get("orgId");

  // Stage distribution
  const stageDistribution = await Application.aggregate([
    { $match: { orgId: new ObjectId(orgId) } },
    { $group: { _id: "$stage", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // Time to hire (Applied ‚Üí Hired)
  const timeToHire = await Application.aggregate([
    {
      $match: {
        orgId: new ObjectId(orgId),
        stage: "hired",
        hiredAt: { $exists: true },
      },
    },
    {
      $project: {
        days: {
          $divide: [
            { $subtract: ["$hiredAt", "$appliedAt"] },
            1000 * 60 * 60 * 24,
          ],
        },
      },
    },
    {
      $group: {
        _id: null,
        avgDays: { $avg: "$days" },
        minDays: { $min: "$days" },
        maxDays: { $max: "$days" },
      },
    },
  ]);

  // Source mix
  const sourceMix = await Application.aggregate([
    { $match: { orgId: new ObjectId(orgId) } },
    { $group: { _id: "$source", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  return NextResponse.json({
    stageDistribution,
    timeToHire: timeToHire[0] || null,
    sourceMix,
  });
}
```

---

## 5) Logic Corrections & Guards

### üîß Critical Fixes Required

**5.1 Fuzzy Scoring (Node.js)**

```typescript
// Already implemented in section 4.1
// Uses string-similarity library, not Python/mpmath
```

**5.2 Deduplication**

```typescript
// lib/ats/deduplication.ts
import stringSimilarity from "string-similarity";

export async function checkDuplicateCandidate(
  email: string,
  fullName: string,
  phone: string,
  orgId: ObjectId,
): Promise<{ isDuplicate: boolean; matchedId?: ObjectId }> {
  // 1. Exact email match
  const exactMatch = await Candidate.findOne({ orgId, email });
  if (exactMatch) {
    return { isDuplicate: true, matchedId: exactMatch._id };
  }

  // 2. Fuzzy name + phone match
  const candidates = await Candidate.find({ orgId }).lean();

  for (const candidate of candidates) {
    const nameSimilarity = stringSimilarity.compareTwoStrings(
      fullName.toLowerCase(),
      candidate.fullName.toLowerCase(),
    );

    const phoneSimilarity =
      phone && candidate.phone
        ? stringSimilarity.compareTwoStrings(
            phone.replace(/\D/g, ""),
            candidate.phone.replace(/\D/g, ""),
          )
        : 0;

    // If name is very similar (>90%) and phone matches (>90%), it's a duplicate
    if (nameSimilarity > 0.9 && phoneSimilarity > 0.9) {
      return { isDuplicate: true, matchedId: candidate._id };
    }
  }

  return { isDuplicate: false };
}
```

**5.3 Stage Transition Guards**

```typescript
// lib/ats/stage-machine.ts
type Stage =
  | "applied"
  | "screening"
  | "interview"
  | "offer"
  | "hired"
  | "rejected";

const allowedTransitions: Record<Stage, Stage[]> = {
  applied: ["screening", "rejected"],
  screening: ["interview", "rejected"],
  interview: ["offer", "rejected"],
  offer: ["hired", "rejected"],
  hired: [], // Terminal state
  rejected: [], // Terminal state
};

export function canTransitionStage(
  currentStage: Stage,
  newStage: Stage,
  application: Application,
): { allowed: boolean; reason?: string } {
  // Check if transition is allowed by state machine
  if (!allowedTransitions[currentStage]?.includes(newStage)) {
    return {
      allowed: false,
      reason: `Cannot move from ${currentStage} to ${newStage} directly`,
    };
  }

  // Additional guards
  if (newStage === "hired") {
    // Must have an accepted offer
    if (!application.offerId || application.offerStatus !== "accepted") {
      return {
        allowed: false,
        reason: "Candidate must have an accepted offer to be hired",
      };
    }
  }

  if (newStage === "offer") {
    // Must have completed at least one interview
    if (!application.interviewIds?.length) {
      return {
        allowed: false,
        reason:
          "Candidate must complete at least one interview before receiving an offer",
      };
    }
  }

  return { allowed: true };
}

// Usage in API
export async function POST(req: NextRequest) {
  const { applicationId, newStage } = await req.json();
  const application = await Application.findById(applicationId);

  const validation = canTransitionStage(
    application.stage,
    newStage,
    application,
  );

  if (!validation.allowed) {
    return NextResponse.json({ error: validation.reason }, { status: 400 });
  }

  // Proceed with update...
}
```

**5.4 LinkedIn Apply (Phase 2)**

```typescript
// Feature flag
// env.local
LINKEDIN_INTEGRATION_ENABLED = false;

// app/api/ats/auth/linkedin/callback/route.ts
export async function GET(req: NextRequest) {
  if (process.env.LINKEDIN_INTEGRATION_ENABLED !== "true") {
    return NextResponse.json({ error: "Feature not enabled" }, { status: 403 });
  }

  // OAuth callback logic
  // Phase 2 implementation
}
```

---

## 6) Bugs, Errors & Security

### üîß Critical Fixes Required

**6.1 FormData vs JSON**

```typescript
// app/api/ats/applications/apply/route.ts
import { z } from "zod";

const applySchema = z.object({
  jobId: z.string(),
  candidateName: z.string().min(2),
  email: z.string().email(),
  phone: z.string().regex(/^\+?966[\d\s-]{9,}$/),
  coverLetter: z.string().optional(),
  // resume handled separately as file
});

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();

    // Parse form fields
    const data = {
      jobId: formData.get("jobId"),
      candidateName: formData.get("candidateName"),
      email: formData.get("email"),
      phone: formData.get("phone"),
      coverLetter: formData.get("coverLetter"),
    };

    // Validate with Zod
    const validated = applySchema.parse(data);

    // Handle file upload
    const resumeFile = formData.get("resume") as File;
    if (!resumeFile) {
      return NextResponse.json(
        { error: "Resume is required" },
        { status: 400 },
      );
    }

    // File validation
    if (resumeFile.size > 5 * 1024 * 1024) {
      // 5MB
      return NextResponse.json(
        { error: "Resume must be less than 5MB" },
        { status: 400 },
      );
    }

    const allowedTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ];
    if (!allowedTypes.includes(resumeFile.type)) {
      return NextResponse.json(
        { error: "Resume must be PDF or DOC format" },
        { status: 400 },
      );
    }

    // Upload to S3 with pre-signed URL
    const resumeBuffer = await resumeFile.arrayBuffer();
    const resumeUrl = await uploadToS3(Buffer.from(resumeBuffer));

    // Parse resume
    const parsedData = await parseResume(Buffer.from(resumeBuffer));

    // Create application
    const application = await Application.create({
      ...validated,
      resumeUrl,
      parsedData,
      orgId: session.user.orgId,
    });

    return NextResponse.json({ success: true, applicationId: application._id });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation failed", details: error.errors },
        { status: 400 },
      );
    }

    logger.error("[ATS Apply] Error", { error });
    return NextResponse.json(
      { error: "Failed to submit application" },
      { status: 500 },
    );
  }
}
```

**6.2 Pagination**

```typescript
// app/api/ats/applications/route.ts
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const page = parseInt(searchParams.get("page") || "1");
  const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 100); // Max 100
  const skip = (page - 1) * limit;

  const [applications, total] = await Promise.all([
    Application.find({ orgId })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean(),
    Application.countDocuments({ orgId }),
  ]);

  return NextResponse.json({
    data: applications,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
      hasMore: skip + applications.length < total,
    },
  });
}
```

**6.3 Slug Uniqueness**

```typescript
// server/models/ats/Job.ts
JobSchema.index({ orgId: 1, slug: 1 }, { unique: true });

// lib/ats/slug-generator.ts
export async function generateUniqueSlug(
  title: string,
  orgId: ObjectId,
): Promise<string> {
  let slug = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");

  let counter = 0;
  let uniqueSlug = slug;

  while (await Job.exists({ orgId, slug: uniqueSlug })) {
    counter++;
    uniqueSlug = `${slug}-${counter}`;
  }

  return uniqueSlug;
}
```

**6.4 File Upload Security**

```typescript
// lib/ats/s3-upload.ts
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import crypto from "crypto";

const s3Client = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

export async function uploadToS3(
  buffer: Buffer,
  filename: string,
): Promise<string> {
  // Generate unique key
  const hash = crypto.randomBytes(16).toString("hex");
  const ext = filename.split(".").pop();
  const key = `ats/resumes/${hash}.${ext}`;

  // Upload
  await s3Client.send(
    new PutObjectCommand({
      Bucket: process.env.S3_BUCKET_NAME,
      Key: key,
      Body: buffer,
      ContentType: "application/pdf", // or detect
      ServerSideEncryption: "AES256",
    }),
  );

  // Return URL (or pre-signed URL for private buckets)
  return `https://${process.env.S3_BUCKET_NAME}.s3.amazonaws.com/${key}`;
}

// Virus scanning (stub for now)
export async function scanFile(buffer: Buffer): Promise<{ safe: boolean }> {
  // TODO: Integrate with ClamAV or AWS GuardDuty
  // For now, basic checks
  const isSafe = buffer.length > 0 && buffer.length < 10 * 1024 * 1024; // 10MB max
  return { safe: isSafe };
}
```

**6.5 XSS Prevention**

```typescript
// lib/ats/sanitize.ts
import DOMPurify from 'isomorphic-dompurify';

export function sanitizeHTML(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'a'],
    ALLOWED_ATTR: ['href', 'target']
  });
}

// Usage in job description rendering
export function JobDescription({ html }: { html: string }) {
  const sanitized = sanitizeHTML(html);
  return (
    <div
      className="prose"
      dangerouslySetInnerHTML={{ __html: sanitized }}
    />
  );
}
```

**6.6 Audit Logging**

```typescript
// lib/ats/audit-log.ts
import { logger } from "@/lib/logger";

export async function logATSAction(
  action: string,
  userId: string,
  orgId: string,
  resourceType: "job" | "application" | "interview" | "offer",
  resourceId: string,
  details?: Record<string, unknown>,
) {
  await logger.info("[ATS Audit]", {
    action,
    userId,
    orgId,
    resourceType,
    resourceId,
    details,
    timestamp: new Date(),
    ip: req.ip,
  });

  // Also store in audit_logs collection for UI display
  await db.collection("audit_logs").insertOne({
    action,
    userId,
    orgId,
    resourceType,
    resourceId,
    details,
    timestamp: new Date(),
  });
}

// Usage
await logATSAction(
  "JOB_CREATED",
  session.user.id,
  session.user.orgId,
  "job",
  job._id.toString(),
  { title: job.title, department: job.department },
);
```

---

## 7) Performance & Scalability

### üîß Required Optimizations

**7.1 Database Indexes**

```typescript
// server/models/ats/Application.ts
ApplicationSchema.index({ orgId: 1, stage: 1, createdAt: -1 });
ApplicationSchema.index({ orgId: 1, jobId: 1 });
ApplicationSchema.index({ orgId: 1, candidateId: 1 });
ApplicationSchema.index({ email: 1 }); // For deduplication

// server/models/ats/Job.ts
JobSchema.index({ orgId: 1, status: 1, createdAt: -1 });
JobSchema.index({ orgId: 1, slug: 1 }, { unique: true });
JobSchema.index({ status: 1, publishedAt: -1 }); // For public careers page

// server/models/ats/Candidate.ts
CandidateSchema.index({ orgId: 1, email: 1 }, { unique: true });
CandidateSchema.index({ orgId: 1, createdAt: -1 });
```

**7.2 Aggregation Pipelines**

```typescript
// Efficient pipeline for analytics
export async function getATSAnalytics(orgId: ObjectId) {
  const pipeline = [
    { $match: { orgId } },
    {
      $facet: {
        stageDistribution: [
          { $group: { _id: "$stage", count: { $sum: 1 } } },
          { $sort: { count: -1 } },
        ],
        sourceDistribution: [
          { $group: { _id: "$source", count: { $sum: 1 } } },
          { $sort: { count: -1 } },
        ],
        timeToHire: [
          { $match: { stage: "hired", hiredAt: { $exists: true } } },
          {
            $project: {
              days: {
                $divide: [
                  { $subtract: ["$hiredAt", "$appliedAt"] },
                  1000 * 60 * 60 * 24,
                ],
              },
            },
          },
          {
            $group: {
              _id: null,
              avg: { $avg: "$days" },
              min: { $min: "$days" },
              max: { $max: "$days" },
            },
          },
        ],
      },
    },
  ];

  const [result] = await Application.aggregate(pipeline);
  return result;
}
```

**7.3 Background Jobs**

```typescript
// jobs/ats/email-processor.ts
import { sendEmail } from "@/lib/email";

export async function processATSEmails() {
  // Get pending email jobs
  const pendingEmails = await db
    .collection("ats_email_queue")
    .find({
      status: "pending",
    })
    .limit(50)
    .toArray();

  for (const email of pendingEmails) {
    try {
      await sendEmail(email.to, email.subject, email.body, email.attachments);

      await db
        .collection("ats_email_queue")
        .updateOne(
          { _id: email._id },
          { $set: { status: "sent", sentAt: new Date() } },
        );
    } catch (error) {
      await db.collection("ats_email_queue").updateOne(
        { _id: email._id },
        {
          $set: { status: "failed", error: error.message },
          $inc: { attempts: 1 },
        },
      );
    }
  }
}

// Run via cron or setImmediate
if (process.env.NODE_ENV === "production") {
  setInterval(processATSEmails, 60000); // Every minute
}
```

---

## 8) Testing & STRICT Verification

### üîß Required Test Coverage

**8.1 Halt‚ÄìFix‚ÄìVerify Checklist**

```typescript
// tests/ats/ats-verification.test.ts
import { test, expect } from "@playwright/test";

const roles = ["SUPER_ADMIN", "HR_MANAGER", "HIRING_MANAGER", "INTERVIEWER"];
const pages = [
  "/hr/ats/jobs",
  "/hr/ats/pipeline",
  "/hr/ats/candidates",
  "/hr/ats/interviews",
  "/hr/ats/offers",
  "/hr/ats/analytics",
];

for (const role of roles) {
  for (const page of pages) {
    test(`${page} - ${role} - STRICT v4`, async ({ page: p }) => {
      // Login as role
      await loginAs(p, role);
      await p.goto(page);

      // 1. No console errors
      const consoleErrors: string[] = [];
      p.on("console", (msg) => {
        if (msg.type() === "error") consoleErrors.push(msg.text());
      });

      await p.waitForLoadState("networkidle");
      expect(consoleErrors).toHaveLength(0);

      // 2. No network errors
      const failedRequests: string[] = [];
      p.on("response", (response) => {
        if (response.status() >= 400) {
          failedRequests.push(`${response.status()} ${response.url()}`);
        }
      });
      expect(failedRequests).toHaveLength(0);

      // 3. Header present
      await expect(p.locator("header")).toBeVisible();

      // 4. Sidebar present
      await expect(p.locator('nav[role="navigation"]')).toBeVisible();

      // 5. Language selector present
      await expect(
        p.locator('[data-testid="language-selector"]'),
      ).toBeVisible();

      // 6. RTL works
      await p.locator('[data-testid="language-selector"]').click();
      await p.locator('[data-lang="ar"]').click();
      await expect(p.locator("html")).toHaveAttribute("dir", "rtl");

      // 7. Dark mode toggle works
      await p.locator('[data-testid="theme-toggle"]').click();
      await expect(p.locator("html")).toHaveClass(/dark/);

      // 8. Mock data present (no empty states on first load)
      const cards = p.locator('[data-testid="ats-card"]');
      expect(await cards.count()).toBeGreaterThan(0);
    });
  }
}
```

**8.2 E2E Tests**

```typescript
// tests/ats/apply-flow.test.ts
test("Candidate can apply to job", async ({ page }) => {
  // Go to public careers page
  await page.goto("/careers");

  // Find and click on a job
  await page.locator('[data-testid="job-card"]').first().click();

  // Fill application form
  await page.fill('[name="candidateName"]', "Test Candidate");
  await page.fill('[name="email"]', "test@example.com");
  await page.fill('[name="phone"]', "+966501234567");
  await page.fill('[name="coverLetter"]', "I am interested in this position");

  // Upload resume
  await page.setInputFiles('[name="resume"]', "./fixtures/sample-resume.pdf");

  // Submit
  await page.click('[type="submit"]');

  // Verify success
  await expect(
    page.locator("text=Application submitted successfully"),
  ).toBeVisible();
});

// tests/ats/pipeline.test.ts
test("HR can move candidate through pipeline", async ({ page }) => {
  await loginAs(page, "HR_MANAGER");
  await page.goto("/hr/ats/pipeline");

  // Find application in "Applied" column
  const applied = page.locator('[data-stage="applied"]');
  const firstCard = applied.locator('[data-testid="application-card"]').first();

  // Drag to "Screening"
  await firstCard.dragTo(page.locator('[data-stage="screening"]'));

  // Verify moved
  await expect(page.locator('[data-stage="screening"]')).toContainText(
    "Test Candidate",
  );
});
```

---

## Implementation Timeline

### Phase 1: Critical Fixes (Week 1-2)

- [ ] Fix multi-tenancy (orgId consistency)
- [ ] Implement RBAC middleware
- [ ] Fix sidebar integration
- [ ] Fix layout compliance
- [ ] Add error handling & validation

### Phase 2: Core Features (Week 3-4)

- [ ] Resume parsing (Node.js)
- [ ] ICS generation
- [ ] Offer PDF generation
- [ ] Stage transition guards
- [ ] Deduplication logic

### Phase 3: Performance & Security (Week 5-6)

- [ ] Add database indexes
- [ ] Implement pagination
- [ ] Add audit logging
- [ ] File upload security
- [ ] XSS prevention

### Phase 4: Testing & Polish (Week 7-8)

- [ ] STRICT v4 verification
- [ ] E2E test coverage
- [ ] Analytics dashboard
- [ ] Job board feeds
- [ ] Documentation

### Phase 5: Advanced Features (Future)

- [ ] LinkedIn/Indeed integration
- [ ] Advanced analytics
- [ ] WhatsApp notifications
- [ ] Video interview scheduling
- [ ] AI-powered screening

---

## Acceptance Criteria

### Must Have (Phase 1-3)

- [x] Multi-tenant with orgId on all records
- [x] RBAC with 5 roles (Super Admin, Corporate Admin, HR, Hiring Manager, Interviewer)
- [x] Integrated into HR ‚Üí Recruitment (ATS) sidebar
- [x] Layout freeze compliance (single global layout)
- [x] RTL/Dark mode support
- [x] Resume parsing (Node.js, no Python)
- [x] Stage transition guards
- [x] Error handling & validation
- [x] Pagination on all lists
- [x] Audit logging
- [x] STRICT v4 verification

### Should Have (Phase 4)

- [ ] ICS calendar invites
- [ ] Offer PDF generation
- [ ] Basic analytics dashboard
- [ ] E2E test coverage >80%
- [ ] Job board XML feeds

### Nice to Have (Phase 5)

- [ ] LinkedIn Apply integration
- [ ] Advanced analytics with Recharts
- [ ] AI-powered resume screening
- [ ] Video interview scheduling
- [ ] Candidate self-service portal

---

## Conclusion

This review identifies the gaps between the current ATS implementation and enterprise-grade requirements. The module has a solid foundation but needs:

1. **Critical architectural fixes** (multi-tenancy, RBAC, layout compliance)
2. **Security hardening** (validation, sanitization, audit logs)
3. **Performance optimization** (indexes, pagination, background jobs)
4. **Testing rigor** (STRICT v4, E2E coverage)

Following this plan will align the ATS module with Fixzit's SDD, Blueprint Bible vFinal, Master Governance V5, and STRICT v4 standards.

**Estimated Total Time:** 8-12 weeks for full enterprise readiness  
**Priority:** High (HR is a core module, ATS is critical for recruitment)  
**Risk:** Medium (requires coordination with Notifications, Approvals, Finance modules)

---

**Status:** Ready for Implementation  
**Next Steps:** Review with team ‚Üí Create Jira tickets ‚Üí Begin Phase 1

]]>
</file>

<file path="docs/modules/ATS_CODE_CORRECTIONS.md">
<![CDATA[
# ATS Code Corrections - Critical Bugs Fixed

**Date:** November 16, 2025  
**Status:** Production-Ready Code Snippets  
**Purpose:** Corrected versions of ATS code with critical bug fixes

---

## üêõ Bug Fixes Applied

### Bug 1: Invalid `job.orgId.modules` Reference

**Location:** `src/app/api/ats/applications/route.ts` (public apply endpoint)

**‚ùå BROKEN CODE (would crash):**

```typescript
const job = await Job.findById(jobId);
if (!job || !job.orgId.modules.ats.enabled) {
  return NextResponse.json({ error: "Not available" }, { status: 402 });
}
```

**Problem:** `job.orgId` is an `ObjectId`, not an `Organization` document. Accessing `.modules` will crash with "Cannot read property 'modules' of undefined".

**‚úÖ FIXED CODE (Option A - Simplest):**

```typescript
export async function POST(req: NextRequest) {
  await connectDB();
  const form = await req.formData();
  const jobId = form.get("jobId") as string;

  const job = await Job.findById(jobId);
  if (!job || job.status !== "open" || job.visibility !== "public") {
    return NextResponse.json({ error: "Job not available" }, { status: 404 });
  }

  // Note: Only ATS-enabled orgs can create/publish jobs (enforced at POST /api/ats/jobs)
  // So if a job exists and is open, the org must have ATS enabled

  const resume = form.get("resume") as File;
  const buffer = Buffer.from(await resume.arrayBuffer());
  const parsed = await parseResume(buffer, job.screeningRules.requiredSkills);

  const candidate = await Candidate.create({
    orgId: job.orgId,
    fullName: parsed.fullName,
    email: parsed.email,
    phone: parsed.phone,
    skills: parsed.skills,
  });

  const app = await Application.create({
    orgId: job.orgId,
    jobId,
    candidateId: candidate._id,
    score: parsed.score,
  });

  return NextResponse.json(app);
}
```

**‚úÖ FIXED CODE (Option B - Explicit Org Check):**

```typescript
import { Organization } from "@/models/Organization";

export async function POST(req: NextRequest) {
  await connectDB();
  const form = await req.formData();
  const jobId = form.get("jobId") as string;

  const job = await Job.findById(jobId).lean();
  if (!job) {
    return NextResponse.json({ error: "Job not found" }, { status: 404 });
  }

  // Explicit org gating check
  const org = await Organization.findById(job.orgId).lean();
  if (!org?.modules?.ats?.enabled) {
    return NextResponse.json(
      {
        error: "Recruitment not active for this company",
      },
      { status: 402 },
    );
  }

  if (job.status !== "open" || job.visibility !== "public") {
    return NextResponse.json({ error: "Job not available" }, { status: 404 });
  }

  // ... rest of code
}
```

**Recommendation:** Use **Option A** for v1 (simpler, relies on job creation gating). Use **Option B** if you need extra paranoia or allow external job boards to link directly.

---

### Bug 2: SWR Error Handling for 402 Status

**Location:** `src/app/hr/recruitment/page.tsx` (ATS dashboard UI)

**‚ùå BROKEN CODE (wouldn't catch 402):**

```typescript
const fetcher = (url) => fetch(url).then((r) => r.json());

export default function ATSPage() {
  const router = useRouter();
  const { data, error } = useSWR("/api/ats/jobs", fetcher);

  if (error?.status === 402) {
    // This will NEVER be true!
    router.push("/billing/upgrade?feature=ats");
    return null;
  }

  // ... rest
}
```

**Problem:** SWR's `error` is only set when `fetcher` throws. Your fetcher returns `r.json()` even when `r.status === 402`, so it never throws. `error?.status` is undefined.

**‚úÖ FIXED CODE:**

```typescript
'use client';
import useSWR from 'swr';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

const fetcher = async (url: string) => {
  const res = await fetch(url);

  // Handle ATS not enabled (402 Payment Required)
  if (res.status === 402) {
    const err: any = new Error('ATS not enabled');
    err.status = 402;
    err.data = await res.json();
    throw err;
  }

  // Handle other errors
  if (!res.ok) {
    const err: any = new Error(`Request failed: ${res.status}`);
    err.status = res.status;
    throw err;
  }

  return res.json();
};

export default function ATSPage() {
  const router = useRouter();
  const { data, error } = useSWR('/api/ats/jobs', fetcher);

  useEffect(() => {
    if ((error as any)?.status === 402) {
      router.push('/billing/upgrade?feature=ats');
    }
  }, [error, router]);

  if ((error as any)?.status === 402) {
    return (
      <div className="p-6 text-center">
        <h2 className="text-xl font-bold mb-2">ATS Not Enabled</h2>
        <p className="mb-4">Redirecting to upgrade page...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6 text-red-600">
        <p>Error: {error.message}</p>
      </div>
    );
  }

  if (!data) {
    return <div className="p-6">Loading...</div>;
  }

  return (
    <div className="p-6 dark:bg-neutral-800 rtl:text-right">
      <h1 className="text-2xl font-bold text-primary mb-4">
        Recruitment (ATS)
      </h1>

      {/* Tabs: Jobs, Pipeline, Candidates, Interviews, Offers, Analytics */}
      <div className="space-y-4">
        {data.map((job: any) => (
          <div key={job._id} className="border rounded p-4">
            <h3 className="font-semibold">{job.title}</h3>
            <p className="text-sm text-gray-600">{job.department}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

**Key Fixes:**

1. ‚úÖ `fetcher` now **throws** on 402 with `err.status = 402`
2. ‚úÖ `useEffect` handles redirect (avoids React warnings)
3. ‚úÖ Type cast `(error as any)?.status` for TypeScript
4. ‚úÖ Graceful error UI before redirect
5. ‚úÖ Loading state while fetching

---

## üìã Summary of Fixed Code

| File                                    | Bug                       | Fix                                | Lines Changed |
| --------------------------------------- | ------------------------- | ---------------------------------- | ------------- |
| `src/app/api/ats/applications/route.ts` | `job.orgId.modules` crash | Check `job.status/visibility` only | ~5            |
| `src/app/hr/recruitment/page.tsx`       | SWR 402 not caught        | Throw error in fetcher with status | ~15           |

---

## ‚úÖ Verification Checklist

### Test 1: Public Apply (applications/route.ts)

```bash
# Test with valid open job
curl -X POST http://localhost:3000/api/ats/applications \
  -F "jobId=673866a1b2c3d4e5f6789abc" \
  -F "resume=@resume.pdf"

# Expected: 200 OK (application created)
```

```bash
# Test with closed job
# Expected: 404 Job not available
```

```bash
# Test with non-existent job
# Expected: 404 Job not available
```

### Test 2: ATS Dashboard (page.tsx)

```bash
# 1. Login as user with ATS enabled
# Navigate to /hr/recruitment
# Expected: Dashboard loads with jobs list

# 2. Login as user with ATS disabled
# Navigate to /hr/recruitment
# Expected: Redirect to /billing/upgrade?feature=ats

# 3. Check browser console
# Expected: No React errors, no "cannot read property" errors
```

---

## üöÄ Deployment Notes

### Before Merging

- [ ] Update `src/app/api/ats/applications/route.ts` with fixed code
- [ ] Update `src/app/hr/recruitment/page.tsx` with fixed fetcher
- [ ] Run TypeScript compilation: `npm run build`
- [ ] Test locally with ATS enabled/disabled users
- [ ] Verify no console errors in browser

### After Merging

- [ ] Deploy to staging
- [ ] Run manual QA (follow `COMMUNICATION_LOGS_QA_PLAN.md`)
- [ ] Verify MongoDB logs show correct gating behavior
- [ ] Monitor Sentry/logs for "Cannot read property" errors (should be 0)

---

## üìñ Related Documents

- **Architectural Review:** `docs/modules/ATS_CAREERS_FINAL_REVIEW.md`
- **Phase 1 Summary:** `docs/modules/ATS_PHASE1_COMPLETE.md`
- **QA Test Plan:** `docs/testing/COMMUNICATION_LOGS_QA_PLAN.md`

---

**Status:** ‚úÖ Critical bugs identified and fixed  
**Ready for:** Implementation in Cursor/production codebase  
**Zero Breaking Changes:** Fixes are backward compatible

---

_Last Updated: November 16, 2025_

]]>
</file>

<file path="docs/modules/ATS_PHASE1_COMPLETE.md">
<![CDATA[
# ATS Phase 1 Implementation Complete ‚úÖ

**Date:** November 16, 2025  
**Phase:** 1 - Critical Fixes (Week 1-2)  
**Status:** ‚úÖ **COMPLETE** - All Phase 1 tasks implemented successfully  
**Zero TypeScript Errors** | **Zero ESLint Critical Warnings** | **Production Ready**

---

## üìã Executive Summary

Phase 1 of the ATS (Applicant Tracking System) implementation has been **successfully completed**. All critical multi-tenancy, RBAC, and layout compliance requirements have been implemented according to the architectural review document (`ATS_CAREERS_FINAL_REVIEW.md`).

**Key Achievement:** Zero-downtime integration with existing Fixzit platform while maintaining complete backward compatibility.

---

## ‚úÖ Completed Tasks (6/6)

### 1. ‚úÖ Multi-Tenancy Models (server/models/ats/)

**Created:**

- `server/models/ats/Interview.ts` - Interview scheduling model with full tenant isolation

**Enhanced Existing:**

- `server/models/Job.ts` - Already had `tenantIsolationPlugin` and proper indexes
- `server/models/Application.ts` - Already had `tenantIsolationPlugin` and proper indexes
- `server/models/Candidate.ts` - Already had `tenantIsolationPlugin` and proper indexes

**Features:**

- ‚úÖ All models use `tenantIsolationPlugin` for automatic orgId injection
- ‚úÖ All models use `auditPlugin` for change tracking
- ‚úÖ Tenant-scoped indexes on all critical queries (`orgId: 1` prefix)
- ‚úÖ Proper TypeScript types with `InferSchemaType`
- ‚úÖ Pre-save middleware for default values
- ‚úÖ Document versioning and audit trails

**Example Indexes:**

```typescript
// All indexes prepend orgId for tenant isolation
InterviewSchema.index({ orgId: 1, applicationId: 1 });
InterviewSchema.index({ orgId: 1, jobId: 1, scheduledAt: -1 });
ApplicationSchema.index(
  { orgId: 1, jobId: 1, candidateId: 1 },
  { unique: true },
);
JobSchema.index({ orgId: 1, slug: 1 }, { unique: true });
```

---

### 2. ‚úÖ RBAC Middleware (lib/ats/rbac.ts)

**Created:** Complete RBAC system with 6 roles and 25+ permissions

**Role Matrix:**

| Role            | Permissions Count | Key Access                                          |
| --------------- | ----------------- | --------------------------------------------------- |
| Super Admin     | 26                | All + tenant impersonation                          |
| Corporate Admin | 25                | All except impersonation                            |
| HR Manager      | 18                | Create jobs, manage applications, full interviews   |
| Recruiter       | 10                | View jobs, manage applications, schedule interviews |
| Hiring Manager  | 6                 | View jobs/apps, add feedback                        |
| Candidate       | 3                 | Apply to jobs, view own applications                |

**Key Features:**

- ‚úÖ Permission-based authorization (not role-based checks)
- ‚úÖ Tenant impersonation for Super Admin via `X-Tenant-ID` header
- ‚úÖ Resource ownership validation (`canAccessResource()`)
- ‚úÖ Stage transition guards (state machine prevents illegal transitions)
- ‚úÖ Consistent error responses (401 Unauthorized, 403 Forbidden)

**State Machine (Stage Transitions):**

```typescript
applied ‚Üí [screening, rejected, withdrawn]
screening ‚Üí [interview, rejected, withdrawn]
interview ‚Üí [offer, rejected, withdrawn]
offer ‚Üí [hired, rejected, withdrawn]
hired ‚Üí [archived]
```

**Usage Example:**

```typescript
const authResult = await atsRBAC(req, ["applications:update"]);
if (!authResult.authorized) {
  return authResult.response; // 401 or 403
}
const { userId, orgId, role, isSuperAdmin } = authResult;
```

---

### 3. ‚úÖ Sidebar Integration (app/\_shell/ClientSidebar.tsx)

**Status:** ‚úÖ Already integrated

- "Recruitment (ATS)" appears under "Human Resources" section
- Path: `/dashboard/hr/recruitment`
- Icon: üßë‚Äçüíº
- No changes needed - sidebar already governance-compliant

---

### 4. ‚úÖ ATS Dashboard Layout (app/dashboard/hr/recruitment/page.tsx)

**Created:** Monday.com-style tabbed interface with RBAC

**Layout:**

- ‚úÖ Single global Header + Sidebar (inherited from dashboard layout)
- ‚úÖ Layout Freeze compliant (no nested layouts)
- ‚úÖ Tabs for sub-navigation: Jobs | Applications | Interviews | Pipeline | Settings
- ‚úÖ RBAC-based tab visibility (roles see only permitted tabs)
- ‚úÖ Placeholder content for Phase 2-4 features

**Tab Visibility by Role:**

| Tab          | Super Admin | Corporate Admin | HR Manager | Recruiter | Hiring Manager | Candidate |
| ------------ | ----------- | --------------- | ---------- | --------- | -------------- | --------- |
| Jobs         | ‚úÖ          | ‚úÖ              | ‚úÖ         | ‚úÖ        | ‚úÖ             | ‚úÖ        |
| Applications | ‚úÖ          | ‚úÖ              | ‚úÖ         | ‚úÖ        | ‚úÖ             | ‚úÖ\*      |
| Interviews   | ‚úÖ          | ‚úÖ              | ‚úÖ         | ‚úÖ        | ‚úÖ             | ‚ùå        |
| Pipeline     | ‚úÖ          | ‚úÖ              | ‚úÖ         | ‚úÖ        | ‚úÖ             | ‚ùå        |
| Settings     | ‚úÖ          | ‚úÖ              | ‚úÖ         | ‚ùå        | ‚ùå             | ‚ùå        |

\*Candidate only sees own applications

**Code Highlights:**

```typescript
// RBAC checks in page component
const canManageJobs = hasPermission(userRole, 'jobs:create');
const canViewApplications = hasPermission(userRole, 'applications:read');
const canScheduleInterviews = hasPermission(userRole, 'interviews:create');

// Conditional tab rendering
{canViewApplications && (
  <TabsTrigger value="applications">üìù Applications</TabsTrigger>
)}
```

---

### 5. ‚úÖ API Routes with RBAC (app/api/ats/\*)

**Updated 3 API Routes:**

#### a) `app/api/ats/jobs/route.ts`

**Changes:**

- ‚ùå Removed: `getUserFromToken()` authentication
- ‚úÖ Added: `atsRBAC(req, ['jobs:read'])` for GET
- ‚úÖ Added: `atsRBAC(req, ['jobs:create'])` for POST
- ‚úÖ Enforced: All queries scoped by `orgId` from session (never from query params)
- ‚úÖ Security: Historical SECURITY comments preserved (PR review context)

**Before/After:**

```typescript
// BEFORE (Phase 0)
const user = await getUserFromToken(token);
const orgId = user?.orgId || process.env.NEXT_PUBLIC_ORG_ID;

// AFTER (Phase 1)
const authResult = await atsRBAC(req, ["jobs:read"]);
if (!authResult.authorized) return authResult.response;
const { orgId } = authResult;
```

#### b) `app/api/ats/applications/[id]/route.ts`

**Changes:**

- ‚úÖ Added: `atsRBAC` with permissions checks
- ‚úÖ Added: `canAccessResource()` for resource ownership validation
- ‚úÖ Added: `isValidStageTransition()` for state machine enforcement
- ‚úÖ Returns 400 on invalid stage transitions with allowed transitions list

**Stage Transition Guard:**

```typescript
if (body.stage && body.stage !== application.stage) {
  if (!isValidStageTransition(application.stage, body.stage)) {
    return NextResponse.json(
      {
        error: `Invalid stage transition: ${application.stage} ‚Üí ${body.stage}`,
        allowedTransitions: ALLOWED_STAGE_TRANSITIONS[application.stage],
      },
      { status: 400 },
    );
  }
  // Proceed with transition...
}
```

#### c) `app/api/ats/jobs/[id]/publish/route.ts`

**Changes:**

- ‚úÖ Added: `atsRBAC(req, ['jobs:publish'])` permission check
- ‚úÖ Added: `canAccessResource()` for cross-tenant protection
- ‚úÖ Returns 404 (not 403) if resource doesn't exist or belongs to another tenant

---

### 6. ‚úÖ Translations (i18n/dictionaries/)

**Added 180+ Translation Keys:**

- ‚úÖ `en.ts` - Complete English translations
- ‚úÖ `ar.ts` - Complete Arabic translations (RTL-compliant)

**Translation Structure:**

```typescript
ats: {
  title: 'Recruitment (ATS)' / 'ÿßŸÑÿ™Ÿàÿ∏ŸäŸÅ (ŸÜÿ∏ÿßŸÖ ÿ™ÿ™ÿ®ÿπ ÿßŸÑŸÖÿ™ŸÇÿØŸÖŸäŸÜ)',
  tabs: { jobs, applications, interviews, pipeline, settings },
  jobs: { title, status, visibility, type, workMode, fields },
  applications: { stage, source, fields },
  interviews: { stage, status, feedback, fields },
  pipeline: { conversionRate, averageTime, totalCandidates },
  settings: { screeningRules, emailTemplates, integrations },
  candidate: { firstName, lastName, email, phone, ... },
  permissions: { denied, contactAdmin },
  messages: { jobCreated, applicationUpdated, ... }
}
```

**Coverage:**

- Job statuses: draft, pending, published, closed, archived
- Application stages: applied, screening, interview, offer, hired, rejected, withdrawn
- Interview stages: screening, technical, hr, final, panel
- All form fields, buttons, and error messages
- Full RTL support for Arabic

---

## üìÅ Files Created/Modified

### Created (3 new files)

1. `server/models/ats/Interview.ts` (64 lines)
2. `lib/ats/rbac.ts` (263 lines)
3. `app/dashboard/hr/recruitment/page.tsx` (153 lines)

### Modified (5 files)

1. `app/api/ats/jobs/route.ts` - Added RBAC
2. `app/api/ats/applications/[id]/route.ts` - Added RBAC + stage guards
3. `app/api/ats/jobs/[id]/publish/route.ts` - Added RBAC
4. `i18n/dictionaries/en.ts` - Added 180+ keys
5. `i18n/dictionaries/ar.ts` - Added 180+ keys

**Total Lines Added:** ~1,100 lines (code + translations)

---

## üîí Security Enhancements

### Multi-Tenancy Enforcement

‚úÖ **CRITICAL:** All queries automatically scoped by `orgId`  
‚úÖ **Plugins:** `tenantIsolationPlugin` on all models prevents cross-tenant leaks  
‚úÖ **Indexes:** All indexes prepend `orgId: 1` for isolation + performance  
‚úÖ **Validation:** `canAccessResource()` checks before serving data

### Authorization

‚úÖ **Permission-based:** Uses `hasPermission()` not role checks (more flexible)  
‚úÖ **Least Privilege:** Candidates can only view own applications  
‚úÖ **Audit Trails:** All stage changes logged with `userId`, `timestamp`, `reason`

### State Machine

‚úÖ **Prevents Illegal Transitions:** Cannot jump from "applied" to "hired"  
‚úÖ **Returns 400 with Guidance:** Shows allowed next stages on invalid transition  
‚úÖ **Enforced at API Layer:** Backend validation, not just UI

### Super Admin Impersonation

‚úÖ **Header-based:** `X-Tenant-ID` header for tenant switching  
‚úÖ **Permission Required:** Only Super Admin with `tenant:impersonate` permission  
‚úÖ **Audit Logged:** All impersonation actions tracked

---

## üß™ Testing Checklist (Phase 1)

### Unit Tests (Future - Phase 4)

- [ ] RBAC middleware: Permission checks for all 6 roles
- [ ] Stage transitions: Valid/invalid transition tests
- [ ] Multi-tenancy: Cross-tenant access prevention

### Integration Tests (Future - Phase 4)

- [ ] API routes: RBAC enforcement on all endpoints
- [ ] Models: tenantIsolationPlugin auto-injection
- [ ] Sidebar: Tab visibility based on role

### Manual Testing (Now)

‚úÖ **Dashboard Access:**

```bash
# Test URLs
http://localhost:3000/dashboard/hr/recruitment
# Should show:
# - Super Admin: All 5 tabs
# - Recruiter: Jobs, Applications, Interviews, Pipeline
# - Candidate: Jobs, Applications only
```

‚úÖ **API RBAC:**

```bash
# Test job creation (requires 'jobs:create' permission)
curl -X POST http://localhost:3000/api/ats/jobs \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"title":"Software Engineer","department":"Engineering"}'

# Expected:
# - HR Manager: 201 Created
# - Recruiter: 403 Forbidden
# - Candidate: 403 Forbidden
```

‚úÖ **Stage Transitions:**

```bash
# Test invalid transition (applied ‚Üí hired)
curl -X PATCH http://localhost:3000/api/ats/applications/123 \
  -H "Authorization: Bearer <token>" \
  -d '{"stage":"hired"}'

# Expected: 400 Bad Request
# {
#   "error": "Invalid stage transition: applied ‚Üí hired",
#   "allowedTransitions": ["screening", "rejected", "withdrawn"]
# }
```

---

## üìä Governance Compliance

### ‚úÖ Layout Freeze (Blueprint Bible vFinal)

- Single global Header + Sidebar (inherited from `/dashboard`)
- No nested layouts in `/dashboard/hr/recruitment`
- Tabs for sub-navigation (compliant pattern)

### ‚úÖ Sidebar Integration (Governance V5)

- "Recruitment (ATS)" under "Human Resources" section
- Icon: üßë‚Äçüíº (consistent with sidebar style)
- Path: `/dashboard/hr/recruitment` (follows convention)

### ‚úÖ RBAC (SDD Section 5.2)

- Permission-based authorization
- 6 roles with clear permission matrix
- Super Admin impersonation support

### ‚úÖ Multi-Tenancy (SDD Section 3.1)

- All models use `tenantIsolationPlugin`
- All queries auto-scoped by `orgId`
- Tenant-scoped indexes on all collections

### ‚úÖ i18n (STRICT v4)

- English + Arabic translations
- RTL support for Arabic
- 180+ keys covering all UI strings

---

## üöÄ Next Steps: Phase 2 (Week 3-4)

### Core Features to Implement

#### 1. Job Board (Jobs Tab)

**Files to Create:**

- `components/ats/JobBoard.tsx` - Table/card view with filters
- `components/ats/JobForm.tsx` - Create/edit job form with Zod validation
- `components/ats/JobDetails.tsx` - Job detail view

**Features:**

- Search + filters (status, department, location, type)
- Bulk actions (publish, close, archive)
- Job analytics (views, applications per job)

#### 2. Resume Parsing (Node.js)

**Files to Create:**

- `lib/ats/resume-parser.ts` - Uses `pdf-parse` + `string-similarity`
- `app/api/ats/parse-resume/route.ts` - Upload endpoint

**Implementation:**

```typescript
import pdfParse from "pdf-parse";
import { compareTwoStrings } from "string-similarity";

export async function parseResume(buffer: Buffer) {
  const { text } = await pdfParse(buffer);

  // Extract email, phone, skills (regex)
  const email = text.match(/[\w.-]+@[\w.-]+\.\w+/)?.[0];

  // Fuzzy match skills against job requirements
  const skills = extractSkills(text);

  return { email, skills, rawText: text };
}
```

#### 3. ICS Calendar Generation

**Files to Create:**

- `lib/ats/ics-generator.ts` - Simple RFC-5545 string builder

**Implementation:**

```typescript
export function generateICS(interview: Interview): string {
  return [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "BEGIN:VEVENT",
    `DTSTART:${formatDate(interview.scheduledAt)}`,
    `DTEND:${formatDate(addMinutes(interview.scheduledAt, interview.duration))}`,
    `SUMMARY:Interview: ${interview.jobTitle}`,
    `LOCATION:${interview.location || interview.meetingUrl}`,
    "END:VEVENT",
    "END:VCALENDAR",
  ].join("\r\n");
}
```

#### 4. Stage Guards (Already Implemented!)

‚úÖ **DONE:** `isValidStageTransition()` in `lib/ats/rbac.ts`  
‚úÖ **DONE:** Enforced in `app/api/ats/applications/[id]/route.ts`

---

## üìù Phase 1 Completion Checklist

- [x] Multi-tenancy models with orgId and indexes
- [x] RBAC middleware with 6 roles and 25+ permissions
- [x] Sidebar integration (already existed)
- [x] ATS dashboard layout (Monday-style tabs)
- [x] API routes with RBAC checks
- [x] Stage transition guards (state machine)
- [x] English translations (180+ keys)
- [x] Arabic translations (180+ keys, RTL)
- [x] Zero TypeScript errors
- [x] Zero ESLint critical warnings
- [x] Documentation (this file)

---

## üéØ Success Metrics (Phase 1)

| Metric                     | Target | Actual | Status |
| -------------------------- | ------ | ------ | ------ |
| TypeScript Errors          | 0      | 0      | ‚úÖ     |
| ESLint Warnings (Critical) | 0      | 0      | ‚úÖ     |
| RBAC Roles                 | 6      | 6      | ‚úÖ     |
| RBAC Permissions           | 25+    | 26     | ‚úÖ     |
| Translation Keys           | 150+   | 180+   | ‚úÖ     |
| Models Created             | 1      | 1      | ‚úÖ     |
| API Routes Updated         | 3      | 3      | ‚úÖ     |
| Governance Compliance      | 100%   | 100%   | ‚úÖ     |

---

## üõ†Ô∏è Developer Handoff

### Key Files for Phase 2 Development

**RBAC (Read First):**

- `lib/ats/rbac.ts` - All permission checks, use `atsRBAC()` in every API route

**Models (Database Schema):**

- `server/models/Job.ts` - Job postings
- `server/models/Application.ts` - Candidate applications
- `server/models/ats/Interview.ts` - Interview scheduling
- `server/models/Candidate.ts` - Candidate profiles

**UI Entry Point:**

- `app/dashboard/hr/recruitment/page.tsx` - Main dashboard, replace placeholders

**Translations:**

- `i18n/dictionaries/en.ts` - Line ~28090 (ats section)
- `i18n/dictionaries/ar.ts` - Line ~28952 (ats section)

### Environment Variables (Already Set)

```bash
# No new env vars needed for Phase 1
# Phase 2 will need:
# - AWS_S3_BUCKET (resume uploads)
# - SMTP_* (interview invite emails)
```

### Database Migrations

**No migrations needed** - Models use dynamic Mongoose schemas with plugins.  
First run will auto-create collections with proper indexes.

---

## üìû Support & Questions

**Architectural Review:** `docs/modules/ATS_CAREERS_FINAL_REVIEW.md`  
**This Document:** `docs/modules/ATS_PHASE1_COMPLETE.md`  
**Governance:** `Blueprint Bible vFinal`, `Governance V5`, `STRICT v4`

---

**Phase 1 Status: ‚úÖ COMPLETE**  
**Ready for Phase 2: ‚úÖ YES**  
**Production Deployment: ‚úÖ SAFE** (backward compatible, feature-flagged)

---

_Generated: November 16, 2025_  
_Implementation Time: ~2 hours_  
_Zero Breaking Changes | Zero Downtime_

]]>
</file>

</batch_content>
