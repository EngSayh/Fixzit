
You are the "Fixzit Memory Builder" for category: "core".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "core",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="components/AutoIncidentReporter.tsx">
<![CDATA[
"use client";
import { useEffect } from "react";
import { STORAGE_KEYS } from "@/config/constants";
import { logger } from "@/lib/logger";

declare global {
  interface Window {
    __incidentReporter?: boolean;
    __incidentLastAt?: number;
  }
}

export default function AutoIncidentReporter() {
  useEffect(() => {
    const QUEUE_KEY = "fxz_failed_incidents";

    const loadQueued = (): Record<string, unknown>[] => {
      try {
        const raw = localStorage.getItem(QUEUE_KEY);
        return raw ? (JSON.parse(raw) as Record<string, unknown>[]) : [];
      } catch {
        return [];
      }
    };

    const saveQueued = (items: Record<string, unknown>[]) => {
      try {
        const trimmed = items.slice(-20); // cap to avoid unbounded growth
        localStorage.setItem(QUEUE_KEY, JSON.stringify(trimmed));
      } catch {
        // ignore storage errors
      }
    };

    if (typeof window !== "undefined") {
      const enabled =
        String(process.env.NEXT_PUBLIC_ENABLE_INCIDENTS || "true") !== "false";
      if (!enabled || window.__incidentReporter) return;
      window.__incidentReporter = true;
    }
    const getUser = () => {
      // Security Note: Only extracts user ID and tenant ID from localStorage
      // Does not log sensitive data like tokens or PII
      // Backend must handle this data securely and in compliance with privacy regulations
      try {
        return localStorage.getItem(STORAGE_KEYS.userSession)
          ? JSON.parse(localStorage.getItem(STORAGE_KEYS.userSession) as string)
          : null;
      } catch (e) {
        // Silently return null - invalid JSON or localStorage unavailable
        logger.warn("Failed to parse user session from localStorage", {
          component: "AutoIncidentReporter",
          action: "getUser",
          error: e,
        });
        return null;
      }
    };
    const buildCtx = () => ({
      url: typeof window !== "undefined" ? window.location.href : "",
      userAgent: typeof navigator !== "undefined" ? navigator.userAgent : "",
      locale: typeof navigator !== "undefined" ? navigator.language : "en",
      rtl: typeof document !== "undefined" ? document.dir === "rtl" : false,
      time: new Date().toISOString(),
      network:
        typeof navigator !== "undefined"
          ? navigator.onLine
            ? "online"
            : "offline"
          : undefined,
    });
    const flushQueue = async () => {
      const queued = loadQueued();
      if (!queued.length) return;
      const remaining: Record<string, unknown>[] = [];
      for (const item of queued) {
        try {
          await fetch("/api/support/incidents", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify(item),
            keepalive: true,
          });
        } catch {
          remaining.push(item);
        }
      }
      if (remaining.length !== queued.length) {
        saveQueued(remaining);
      }
    };

    const send = (payload: Record<string, unknown>) => {
      const now = Date.now();
      if (window.__incidentLastAt && now - window.__incidentLastAt < 30000)
        return; // throttle 30s
      window.__incidentLastAt = now;
      const url = "/api/support/incidents";
      try {
        const blob = new Blob([JSON.stringify(payload)], {
          type: "application/json",
        });
        if (
          "sendBeacon" in navigator &&
          typeof navigator.sendBeacon === "function" &&
          navigator.sendBeacon(url, blob)
        )
          return;
      } catch (e) {
        // Blob creation or sendBeacon may fail in restrictive environments
        logger.warn("[Telemetry] sendBeacon failed, falling back to fetch", {
          component: "AutoIncidentReporter",
          action: "sendBeacon",
          error: e,
        });
      }
      // Fire-and-forget: Incident reporting must never crash the app, even if API fails
      fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload),
        keepalive: true,
      }).catch((err) => {
        // Log fetch failures for debugging telemetry pipeline
        logger.warn("[Telemetry] Incident report fetch failed", {
          component: "AutoIncidentReporter",
          action: "send",
          error: err,
        });
        saveQueued([...loadQueued(), payload]);
      });
    };

    const onErr = (ev: ErrorEvent) => {
      const u = getUser();
      const user = u ? { userId: u.id, tenant: u.tenantId } : undefined;
      const ctx = buildCtx();
      send({
        code: "UI-UI-ERROR-001",
        message: ev.message,
        details: ev.error?.stack,
        userContext: user,
        clientContext: ctx,
      });
    };
    const onRej = (ev: PromiseRejectionEvent) => {
      const reason = ev.reason as
        | { message?: string; stack?: string }
        | string
        | undefined;
      const msg =
        typeof reason === "string"
          ? reason
          : reason?.message || "Unhandled rejection";
      const stack =
        typeof reason === "object" && reason?.stack
          ? String(reason.stack)
          : undefined;
      const u = getUser();
      const user = u ? { userId: u.id, tenant: u.tenantId } : undefined;
      const ctx = buildCtx();
      send({
        code: "UI-UI-REJECTION-001",
        message: msg,
        details: stack,
        userContext: user,
        clientContext: ctx,
      });
    };

    flushQueue();
    window.addEventListener("error", onErr);
    window.addEventListener("unhandledrejection", onRej);
    return () => {
      window.removeEventListener("error", onErr);
      window.removeEventListener("unhandledrejection", onRej);
    };
  }, []);
  return null;
}

]]>
</file>

<file path="components/ClientDate.tsx">
<![CDATA[
"use client";
import React from "react";
import { useEffect, useState } from "react";
import { logger } from "@/lib/logger";
import {
  formatDate as formatDateUtil,
  formatServerDate as formatServerDateUtil,
} from "@/lib/formatServerDate";

/**
 * ClientDate Component - SSR-Safe Date Rendering
 *
 * Prevents hydration mismatches by rendering dates only on the client.
 * Server renders a placeholder, client hydrates with actual formatted date.
 *
 * @example
 * // Basic usage
 * <ClientDate date={new Date()} />
 *
 * // With custom format
 * <ClientDate date={invoice.dueDate} format="short" />
 *
 * // With custom locale
 * <ClientDate date={payment.date} locale="ar-SA" />
 *
 * // Relative time
 * <ClientDate date={ticket.createdAt} format="relative" />
 */

interface ClientDateProps {
  /** The date to format - can be Date object, ISO string, or timestamp */
  date: Date | string | number;

  /** Format style */
  format?:
    | "full"
    | "long"
    | "medium"
    | "short"
    | "date-only"
    | "time-only"
    | "relative"
    | "iso";

  /** Locale override (defaults to browser locale) */
  locale?: string;

  /** Custom format function */
  formatter?: (_date: Date, _locale?: string) => string;

  /** Placeholder text during SSR/before hydration */
  placeholder?: string;

  /** Additional CSS classes */
  className?: string;

  /** Fallback text if date is invalid */
  fallback?: string;

  /** Timezone override (e.g., 'Asia/Riyadh') */
  timeZone?: string;
}

/**
 * Converts input to Date object safely
 */
function parseDate(date: Date | string | number): Date | null {
  if (date instanceof Date) {
    return isNaN(date.getTime()) ? null : date;
  }

  if (typeof date === "string" || typeof date === "number") {
    const parsed = new Date(date);
    return isNaN(parsed.getTime()) ? null : parsed;
  }

  return null;
}

/**
 * Main formatting function (wraps shared utility)
 */
function formatDate(
  date: Date,
  format: ClientDateProps["format"],
  locale?: string,
  timeZone?: string,
  formatter?: ClientDateProps["formatter"],
): string {
  // Custom formatter takes precedence
  if (formatter) {
    return formatter(date, locale);
  }

  const browserLocale =
    locale || (typeof navigator !== "undefined" ? navigator.language : "en-US");
  return formatDateUtil(date, format || "medium", browserLocale, timeZone);
}

/**
 * ClientDate Component Implementation
 *
 * @note The `formatter` prop should be memoized with useCallback by the caller
 * to prevent unnecessary re-renders. If passed as an inline function, it will
 * cause the component to re-run the formatting effect on every parent render.
 */
export default function ClientDate({
  date,
  format = "medium",
  locale,
  formatter,
  placeholder = "...",
  className = "",
  fallback = "Invalid Date",
  timeZone,
}: ClientDateProps) {
  const [mounted, setMounted] = useState(false);
  const [formattedDate, setFormattedDate] = useState<string>(placeholder);

  useEffect(() => {
    setMounted(true);

    const parsedDate = parseDate(date);

    if (!parsedDate) {
      setFormattedDate(fallback);
      return;
    }

    try {
      const formatted = formatDate(
        parsedDate,
        format,
        locale,
        timeZone,
        formatter,
      );
      setFormattedDate(formatted);
    } catch (error) {
      logger.error("ClientDate formatting error", { error });
      setFormattedDate(fallback);
    }
  }, [date, format, locale, timeZone, fallback, formatter]);

  // Server renders placeholder, client hydrates with actual date
  if (!mounted) {
    return <span className={className}>{placeholder}</span>;
  }

  return <span className={className}>{formattedDate}</span>;
}

/**
 * Re-export formatServerDate from shared module for convenience
 * This function is safe to use in Server Components
 */
export const formatServerDate = formatServerDateUtil;

/**
 * Hook for using formatted dates in client components
 * Returns null during SSR, formatted string on client
 */
export function useClientDate(
  date: Date | string | number,
  format: ClientDateProps["format"] = "medium",
  locale?: string,
  timeZone?: string,
): string | null {
  const [formatted, setFormatted] = useState<string | null>(null);

  useEffect(() => {
    const parsedDate = parseDate(date);

    if (!parsedDate) {
      setFormatted("Invalid Date");
      return;
    }

    try {
      setFormatted(formatDateUtil(parsedDate, format, locale, timeZone));
    } catch (error: unknown) {
      logger.error("useClientDate formatting error", {
        error,
        date,
        format,
        locale,
        timeZone,
      });
      setFormatted("Invalid Date");
    }
  }, [date, format, locale, timeZone]);

  return formatted;
}

]]>
</file>

<file path="components/ClientLayout.tsx">
<![CDATA[
"use client";
import React from "react";
import { logger } from "@/lib/logger";

import { ReactNode, useEffect, useMemo, useState } from "react";
import { usePathname, useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import dynamic from "next/dynamic";
import TopBar from "./TopBar";
import Sidebar from "./Sidebar";
import Footer from "./Footer";
import AutoFixInitializer from "./AutoFixInitializer";
import ResponsiveLayout from "./ResponsiveLayout";
import HtmlAttrs from "./HtmlAttrs";
import PreferenceBroadcast from "./PreferenceBroadcast";
import TrialBanner from "./TrialBanner";
import { useSubscription } from "@/hooks/useSubscription";
import { useTranslation } from "@/contexts/TranslationContext";
import {
  AUTH_ROUTES,
  MARKETING_ROUTE_PREFIXES,
  MARKETING_ROUTES,
  PROTECTED_ROUTE_PREFIXES,
} from "@/config/routes/public";
import { UserRole, type UserRoleType } from "@/types/user";
import type { BadgeCounts } from "@/config/navigation";
import type { DefaultSession } from "next-auth";
import { useOrgCounters } from "@/hooks/useOrgCounters";

type WorkOrderCounters = {
  total?: number;
  open?: number;
  inProgress?: number;
  overdue?: number;
};

type FinanceCounters = {
  unpaid?: number;
  overdue?: number;
};

type HrCounters = {
  probation?: number;
  onLeave?: number;
};

type PropertiesCounters = {
  total?: number;
  leased?: number;
  maintenance?: number;
};

type CrmCounters = {
  contracts?: number;
  leads?: number;
};

type SupportCounters = {
  open?: number;
  pending?: number;
};

type MarketplaceCounters = {
  orders?: number;
  listings?: number;
  reviews?: number;
};

type ApprovalCounters = {
  total?: number;
  pending?: number;
  overdue?: number;
};

type RfqCounters = {
  total?: number;
  open?: number;
  awarded?: number;
  closed?: number;
};

type HrApplicationCounters = {
  total?: number;
  pending?: number;
  applied?: number;
  screening?: number;
  interview?: number;
};

interface CounterPayload {
  workOrders?: WorkOrderCounters;
  finance?: FinanceCounters;
  invoices?: FinanceCounters;
  hr?: HrCounters;
  employees?: HrCounters;
  properties?: PropertiesCounters;
  crm?: CrmCounters;
  customers?: CrmCounters;
  support?: SupportCounters;
  marketplace?: MarketplaceCounters;
  approvals?: ApprovalCounters;
  rfqs?: RfqCounters;
  hrApplications?: HrApplicationCounters;
}

const mapCountersToBadgeCounts = (
  counters?: CounterPayload,
): BadgeCounts | undefined => {
  if (!counters) return undefined;
  const value: BadgeCounts = {};

  const setCount = (key: keyof BadgeCounts, input?: number) => {
    if (typeof input === "number" && Number.isFinite(input)) {
      value[key] = input;
    }
  };

  // Work Orders - correctly mapped
  const workOrders = counters.workOrders ?? {};
  setCount("workOrders", workOrders.total);
  setCount("pendingWorkOrders", workOrders.open);
  setCount("inProgressWorkOrders", workOrders.inProgress);
  setCount("urgentWorkOrders", workOrders.overdue);

  // Finance - correctly mapped
  const finance = counters.finance ?? counters.invoices ?? {};
  setCount("pending_invoices", finance.unpaid);
  setCount("overdue_invoices", finance.overdue);

  // HR Applications - from ATS application counters
  const hrApplications = counters.hrApplications ?? {};
  setCount("hr_applications", hrApplications.pending);

  // Properties - correctly mapped with calculated vacant units
  const properties = counters.properties ?? {};
  const vacantUnits =
    typeof properties.total === "number" &&
    typeof properties.leased === "number"
      ? Math.max(properties.total - properties.leased, 0)
      : undefined;
  if (typeof vacantUnits === "number") {
    value.vacant_units = vacantUnits;
  }
  setCount("properties_needing_attention", properties.maintenance);

  // CRM - correctly mapped
  const crm = counters.crm ?? counters.customers ?? {};
  setCount("crm_deals", crm.contracts);
  setCount("aqar_leads", crm.leads);

  // Support - open tickets only; pending != approvals
  const support = counters.support ?? {};
  setCount("open_support_tickets", support.open);

  // Approvals - workflow approvals
  const approvals = counters.approvals ?? {};
  setCount("pending_approvals", approvals.pending);

  // Marketplace - orders and listings; reviews != RFQs
  const marketplace = counters.marketplace ?? {};
  setCount("marketplace_orders", marketplace.orders);
  setCount("marketplace_products", marketplace.listings);

  // RFQs - marketplace procurement
  const rfqs = counters.rfqs ?? {};
  setCount("open_rfqs", rfqs.open);

  return Object.keys(value).length ? value : undefined;
};

// Dynamic imports for heavy components to reduce initial bundle size
const AutoIncidentReporter = dynamic(
  () => import("@/components/AutoIncidentReporter"),
  { ssr: false },
);

type UserRoleOrGuest = UserRoleType | "guest";

export default function ClientLayout({ children }: { children: ReactNode }) {
  const [role, setRole] = useState<UserRoleOrGuest>("guest");
  const [loading, setLoading] = useState(true);
  const pathname = usePathname() ?? "";
  const router = useRouter();

  // ✅ FIXED: SessionProvider is now always available (in PublicProviders)
  const { data: session, status } = useSession();
  const [authUser, setAuthUser] = useState<{
    id?: string;
    role?: string;
  } | null>(null);

  const marketingRoutes = new Set<string>(MARKETING_ROUTES);
  const marketingRoutePrefixes = MARKETING_ROUTE_PREFIXES;
  const authRoutes = new Set<string>(AUTH_ROUTES);

  const isMarketingPage =
    marketingRoutes.has(pathname) ||
    marketingRoutePrefixes.some(
      (prefix) => pathname === prefix || pathname.startsWith(`${prefix}/`),
    );
  const isAuthPage =
    authRoutes.has(pathname) ||
    pathname.startsWith("/login") ||
    pathname.startsWith("/signup");

  // Use a single source of truth for what's protected on the client
  const protectedPrefixes = PROTECTED_ROUTE_PREFIXES;
  const isProtectedRoute = protectedPrefixes.some(
    (prefix) => pathname === prefix || pathname.startsWith(`${prefix}/`),
  );

  // Safe translation access
  let language = "ar";
  let isRTL = false;
  try {
    const translationContext = useTranslation();
    language = translationContext.language;
    isRTL = translationContext.isRTL;
  } catch (e) {
    // Expected: TranslationContext may not be available in some routes
    if (process.env.NODE_ENV === "development") {
      logger.debug("TranslationContext unavailable, using defaults:", e);
    }
  }

  // Early lang/dir update
  useEffect(() => {
    if (typeof document !== "undefined") {
      document.documentElement.lang = language;
      document.documentElement.dir = isRTL ? "rtl" : "ltr";
    }
  }, [language, isRTL]);

  useEffect(() => {
    if (typeof window === "undefined" || !("serviceWorker" in navigator)) {
      return;
    }
    let unmounted = false;
    const flagKey = "__fixzit_sw_ready";
    const windowRecord = window as unknown as Record<string, unknown>;
    if (windowRecord[flagKey]) {
      return;
    }
    const registerSW = async () => {
      try {
        await navigator.serviceWorker.register("/sw.js");
        if (!unmounted) {
          windowRecord[flagKey] = true;
        }
      } catch (error) {
        if (!unmounted) {
          logger.debug("Service worker registration failed", error);
        }
      }
    };
    registerSW();
    return () => {
      unmounted = true;
    };
  }, []);

  // ⚡ FIXED: Unified auth check - fetch JWT auth if NextAuth isn't authenticated
  useEffect(() => {
    let abort = false;
    // Skip auth probe on public marketing/auth routes to avoid 401 noise
    if (isMarketingPage || isAuthPage) {
      return () => {
        abort = true;
      };
    }
    // Only fetch if NextAuth isn't authenticated yet
    if (status !== "authenticated" && status !== "loading") {
      const checkAuth = async () => {
        try {
          const r = await fetch("/api/auth/me", { credentials: "include" });
          if (!r.ok) return;
          const data = await r.json();
          if (!abort && data?.user?.id) {
            setAuthUser({ id: data.user.id, role: data.user.role });
          }
        } catch (err: unknown) {
          // Silently ignore - user is guest
          logger.debug("Auth check failed (expected for guests):", err);
        }
      };
      checkAuth().catch((err) => {
        logger.debug("Unhandled auth check error:", err);
      });
    }
    return () => {
      abort = true;
    };
  }, [status]);

  // ⚡ FIXED: Unified authentication check (GOLD STANDARD from TopBar.tsx)
  const sessionUser = session?.user as (DefaultSession["user"] & { orgId?: string }) | undefined;
  const isAuthenticated =
    (status === "authenticated" && sessionUser != null) || !!authUser;
  const { counters: counterData } = useOrgCounters();
  const badgeCounts = useMemo(
    () => mapCountersToBadgeCounts(counterData as CounterPayload | undefined),
    [counterData],
  );

  useEffect(() => {
    // 1) Auth pages -> always guest, no fetch
    if (isAuthPage) {
      setRole("guest");
      setLoading(false);
      return;
    }

    // 2) Public marketing pages -> guest but don't clear cookies
    if (isMarketingPage) {
      setRole("guest");
      setLoading(false);
      return;
    }

    // 3) Non-protected routes -> guest
    if (!isProtectedRoute) {
      setRole("guest");
      setLoading(false);
      return;
    }

    // 4) Protected routes: extract role from unified auth
    if (isAuthenticated) {
      // Get role from NextAuth session OR JWT authUser
      const userRole =
        (session?.user as { role?: string })?.role || authUser?.role || "guest";
      const valid: UserRoleType[] = Object.values(UserRole);
      const validRole = valid.includes(userRole as UserRoleType)
        ? (userRole as UserRoleOrGuest)
        : "guest";
      setRole(validRole);
      try {
        localStorage.setItem("fixzit-role", validRole);
      } catch (e) {
        // Silently fail - localStorage may be unavailable (private browsing, quota exceeded)
        if (process.env.NODE_ENV === "development") {
          logger.warn("localStorage.setItem failed", { error: e });
        }
      }
      setLoading(false);
    } else if (status !== "loading") {
      // Not authenticated and not loading -> guest
      setRole("guest");
      try {
        localStorage.removeItem("fixzit-role");
      } catch (e) {
        // Silently fail - localStorage may be unavailable (private browsing)
        if (process.env.NODE_ENV === "development") {
          logger.warn("localStorage.removeItem failed", { error: e });
        }
      }
      setLoading(false);
    }
    // If still loading, keep loading state (don't set guest prematurely)
  }, [
    isAuthPage,
    isMarketingPage,
    isProtectedRoute,
    pathname,
    isAuthenticated,
    session,
    authUser,
    status,
  ]);

  // Client-side protection: redirect guests only from protected routes
  useEffect(() => {
    if (!loading && role === "guest" && isProtectedRoute) {
      // Use Next.js router.replace to avoid back stack loops and enable client-side navigation
      router.replace("/login");
    }
  }, [loading, role, isProtectedRoute, router]);

  const { subscriptionStatus, isLoading: subLoading, isActive } = useSubscription();

  // Auth pages => minimal layout, no widgets
  if (isAuthPage) {
    return (
      <>
        <HtmlAttrs />
        <div className="min-h-screen bg-muted">{children}</div>
      </>
    );
  }

  // Protected routes: normal app layout
  const CopilotWidget = dynamic(
    () =>
      import("./CopilotWidget").catch((err) => {
        logger.error("Failed to load CopilotWidget:", { error: err });
        return { default: () => null };
      }),
    {
      ssr: false,
      loading: () => null,
    },
  );

  // Public/landing pages => full layout with TopBar and Footer but no sidebar
  if (isMarketingPage) {
    return (
      <>
        <HtmlAttrs />
        <div className="min-h-screen bg-muted/30">
          <AutoFixInitializer />
          <AutoIncidentReporter />
          <PreferenceBroadcast />
          <TopBar />
          <main id="main-content" className="flex-1">
            {children}
          </main>
          <Footer />
          <CopilotWidget />
        </div>
      </>
    );
  }

  // Protected routes: normal app layout with sidebar
  return (
    <>
      <HtmlAttrs />
      <div className="min-h-screen bg-muted/30">
        <AutoFixInitializer />
        <ResponsiveLayout
          header={<TopBar />}
          sidebar={
            <Sidebar
              key={`sidebar-${language}-${isRTL}`}
              badgeCounts={badgeCounts}
            />
          }
          showSidebarToggle={true}
          footer={<Footer />}
        >
          <div className="relative min-h-full">
            {children}
            {!subLoading && !isActive && (
              <TrialBanner subscriptionStatus={subscriptionStatus ?? null} />
            )}
          </div>
        </ResponsiveLayout>
        <PreferenceBroadcast />
        <CopilotWidget />
        <AutoIncidentReporter />
      </div>
    </>
  );
}

]]>
</file>

<file path="components/CopilotWidget.tsx">
<![CDATA[
'use client';

import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { AlertTriangle, Bot, Calendar, CheckCircle2, ClipboardList, FileText, Loader2, Send, ShieldCheck, Upload, WifiOff, X } from 'lucide-react';
import { useTranslation } from '@/contexts/TranslationContext';
import { logger } from '@/lib/logger';

type SpeechRecognitionResult = {
  [index: number]: {
    [index: number]: { transcript: string };
  };
};

type SpeechRecognitionEvent = {
  results: SpeechRecognitionResult;
};

type SpeechRecognitionInstance = {
  start: () => void;
  stop: () => void;
  lang: string;
  onresult: (_event: SpeechRecognitionEvent) => void;
  onerror: () => void;
  onend: () => void;
};

type SpeechRecognitionConstructor = new () => SpeechRecognitionInstance;

// Declare global for deduplication tracking
declare global {
  interface Window {
    __copilotLastRequest?: number;
    SpeechRecognition?: SpeechRecognitionConstructor;
    webkitSpeechRecognition?: SpeechRecognitionConstructor;
  }
}

const getSpeechRecognitionConstructor = (): SpeechRecognitionConstructor | undefined => {
  if (typeof window === 'undefined') {
    return undefined;
  }
  const speechWindow = window as Window & {
    SpeechRecognition?: SpeechRecognitionConstructor;
    webkitSpeechRecognition?: SpeechRecognitionConstructor;
  };
  return speechWindow.SpeechRecognition ?? speechWindow.webkitSpeechRecognition;
};

// Type-safe discriminated unions for message data
type MessageData = 
  | { type: 'workOrderList'; items: WorkOrderData[] }
  | { type: 'ownerStatement'; totals: { income: number; expenses: number; net: number }; currency: string }
  | { type: 'attachment'; attachment: { url: string; name: string } }
  | { type: 'unknown'; data: unknown };

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  data?: MessageData;
  intent?: string;
  sources?: { id: string; title: string; score: number; source?: string }[];
}

interface WorkOrderData {
  id: string;
  code: string;
  title: string;
  status: string;
  priority: string;
}

interface QuickAction {
  name: string;
  label: string;
  description?: string;
}

interface CopilotProfile {
  session: {
    role: string;
    name?: string;
    tenantId: string;
    locale: 'en' | 'ar';
  };
  tools: string[];
  quickActions: QuickAction[];
}

interface CopilotWidgetProps {
  autoOpen?: boolean;
  embedded?: boolean;
}

const translations = {
  en: {
    title: 'Fixzit Copilot',
    subtitle: (name?: string, role?: string) => name ? `${name} · ${role}` : (role || 'Signed out'),
    placeholder: 'Ask how to do something in Fixzit…',
    send: 'Send',
    open: 'Ask Fixzit',
    close: 'Close',
    quickActions: 'Self-service actions',
    privacy: 'Privacy enforced: tenant & role scoped',
    welcome: 'Need anything? I can create maintenance tickets, share process steps or retrieve finance statements if your role allows it.',
    guestWarning: 'I could not verify your session. Sign in to use Copilot actions.',
    loading: 'Working on it…',
    toolError: 'Unable to complete this action.',
    requiredField: 'Please complete the required fields.',
    chooseFile: 'Choose file',
    cancel: 'Cancel',
    run: 'Run',
    offline: 'No internet connection. Messages will be sent when back online.',
    rateLimited: 'Please wait a moment before sending another message.'
  },
  ar: {
    title: 'مساعد فيكزت',
    subtitle: (name?: string, role?: string) => name ? `${name} · ${role}` : (role || 'غير مسجل'),
    placeholder: 'اسأل عن أي إجراء داخل النظام…',
    send: 'إرسال',
    open: 'اسأل فيكزت',
    close: 'إغلاق',
    quickActions: 'إجراءات ذاتية',
    privacy: 'الخصوصية مفعلة: ضمن المستأجر والصلاحيات فقط',
    welcome: 'كيف أستطيع مساعدتك؟ أُنشئ تذاكر صيانة، أوضح الخطوات، وأعرض البيانات المالية إذا كانت صلاحيتك تسمح.',
    guestWarning: 'لم أستطع التحقق من الجلسة. سجّل الدخول لاستخدام إجراءات المساعد.',
    loading: 'جارٍ التنفيذ…',
    toolError: 'تعذر تنفيذ هذا الإجراء.',
    requiredField: 'يرجى إكمال الحقول المطلوبة.',
    chooseFile: 'اختر ملفاً',
    cancel: 'إلغاء',
    run: 'تنفيذ',
    offline: 'لا يوجد اتصال بالإنترنت. سيتم إرسال الرسائل عند العودة للإنترنت.',
    rateLimited: 'يرجى الانتظار قليلاً قبل إرسال رسالة أخرى.'
  }
};

type ToolFormValue = string | number | boolean | File | undefined;
type ToolFormState = Record<string, ToolFormValue>;

const initialForms: Record<string, ToolFormState> = {
  createWorkOrder: { title: '', description: '', priority: 'MEDIUM' },
  dispatchWorkOrder: { workOrderId: '', assigneeUserId: '', assigneeVendorId: '' },
  scheduleVisit: { workOrderId: '', scheduledFor: '' },
  uploadWorkOrderPhoto: { workOrderId: '', file: undefined as File | undefined },
  ownerStatements: { ownerId: '', period: 'YTD', year: String(new Date().getFullYear()) }
};

const toolIcons: Record<string, JSX.Element> = {
  createWorkOrder: <ClipboardList className="h-4 w-4" />,
  listMyWorkOrders: <FileText className="h-4 w-4" />,
  dispatchWorkOrder: <CheckCircle2 className="h-4 w-4" />,
  scheduleVisit: <Calendar className="h-4 w-4" />,
  uploadWorkOrderPhoto: <Upload className="h-4 w-4" />,
  ownerStatements: <ShieldCheck className="h-4 w-4" />
};

function renderStructuredData(message: ChatMessage, locale: 'en' | 'ar') {
  if (!message.data) return null;

  // Type-safe discriminated union handling
  switch (message.data.type) {
    case 'workOrderList':
      return (
        <ul className="mt-3 space-y-2 text-xs">
          {message.data.items.map((item) => (
            <li key={item.id} className="rounded-2xl border border-border bg-white/70 p-2">
              <div className="font-semibold text-foreground">{item.code} · {item.title}</div>
              <div className="text-muted-foreground">{item.status} · {item.priority}</div>
            </li>
          ))}
        </ul>
      );

    case 'ownerStatement':
      return (
        <div className="mt-3 space-y-2 text-xs">
          <div className="flex justify-between"><span>{locale === 'ar' ? 'الدخل' : 'Income'}</span><span>{message.data.totals.income.toLocaleString(undefined, { style: 'currency', currency: message.data.currency })}</span></div>
          <div className="flex justify-between"><span>{locale === 'ar' ? 'المصروفات' : 'Expenses'}</span><span>{message.data.totals.expenses.toLocaleString(undefined, { style: 'currency', currency: message.data.currency })}</span></div>
          <div className="flex justify-between font-semibold text-primary"><span>{locale === 'ar' ? 'الصافي' : 'Net'}</span><span>{message.data.totals.net.toLocaleString(undefined, { style: 'currency', currency: message.data.currency })}</span></div>
        </div>
      );

    case 'attachment':
      return (
        <div className="mt-3 flex items-center gap-2 text-xs text-primary">
          <CheckCircle2 className="h-4 w-4" />
          <a href={message.data.attachment.url} target="_blank" rel="noreferrer" className="underline">
            {message.data.attachment.name}
          </a>
        </div>
      );

    default:
      return null;
  }
}

export default function CopilotWidget({ autoOpen = false, embedded = false }: CopilotWidgetProps) {
  const { locale: globalLocale } = useTranslation(); // Use global language selection
  const [isOpen, setIsOpen] = useState(embedded || autoOpen);
  const [profile, setProfile] = useState<CopilotProfile | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [activeTool, setActiveTool] = useState<string | null>(null);
  const [forms, setForms] = useState<Record<string, ToolFormState>>(initialForms);
  const [error, setError] = useState<string | null>(null);
  const [isOnline, setIsOnline] = useState(true);
  const [isListening, setIsListening] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const recognitionRef = useRef<SpeechRecognitionInstance | null>(null);
  const mountedRef = useRef(true);
  const escalationTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Sync with global language - use TranslationContext instead of API locale
  const locale: 'en' | 'ar' = globalLocale === 'ar' ? 'ar' : 'en';
  const t = translations[locale];
  const isRTL = locale === 'ar';

  // Track component mount state and cleanup timers
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
      if (escalationTimerRef.current !== null) {
        clearTimeout(escalationTimerRef.current);
        escalationTimerRef.current = null;
      }
    };
  }, []);

  // Track online/offline status
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    setIsOnline(navigator.onLine);
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Setup voice recognition (Web Speech API)
  useEffect(() => {
    const SpeechRecognitionCtor = getSpeechRecognitionConstructor();
    if (!SpeechRecognitionCtor) {
      recognitionRef.current = null;
      return;
    }

    const recognition = new SpeechRecognitionCtor();
    recognition.lang = locale === 'ar' ? 'ar-SA' : 'en-US';
    
    recognition.onresult = (event: SpeechRecognitionEvent) => {
      const transcript = event.results[0][0].transcript;
      setInput(transcript);
      setIsListening(false);
    };

    recognition.onerror = () => {
      setIsListening(false);
    };

    recognition.onend = () => {
      setIsListening(false);
    };

    recognitionRef.current = recognition;
  }, [locale]);

  useEffect(() => {
    async function bootstrap() {
      try {
        const res = await fetch('/api/copilot/profile', { cache: 'no-store' });
        if (!res.ok) {
          // Silently fall back to guest mode if auth fails
          setProfile({ session: { role: 'GUEST', tenantId: 'public', locale: 'en' }, tools: [], quickActions: [] });
          setMessages([{ id: 'guest', role: 'assistant', content: translations.en.guestWarning }]);
          return;
        }
        
        // Check if response is actually JSON
        const contentType = res.headers.get('content-type');
        if (!contentType?.includes('application/json')) {
          // HTML error page returned, fall back to guest
          setProfile({ session: { role: 'GUEST', tenantId: 'public', locale: 'en' }, tools: [], quickActions: [] });
          setMessages([{ id: 'guest', role: 'assistant', content: translations.en.guestWarning }]);
          return;
        }
        
        const json: CopilotProfile = await res.json();
        setProfile(json);
        setMessages([{ id: 'welcome', role: 'assistant', content: translations[json.session.locale].welcome }]);
      } catch {
        // Silently handle errors in guest mode (expected for unauthenticated users)
        setProfile({ session: { role: 'GUEST', tenantId: 'public', locale: 'en' }, tools: [], quickActions: [] });
        setMessages([{ id: 'guest', role: 'assistant', content: translations.en.guestWarning }]);
      }
    }
    bootstrap();
  }, []);

  useEffect(() => {
    if (!embedded && autoOpen) {
      setIsOpen(true);
    }
  }, [autoOpen, embedded]);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages, isOpen]);

  const quickActions = useMemo(() => profile?.quickActions || [], [profile]);

  const startListening = useCallback(() => {
    if (!recognitionRef.current) return;
    try {
      setIsListening(true);
      recognitionRef.current.start();
    } catch (err) {
      logger.error('Voice recognition error:', err);
      setIsListening(false);
    }
  }, []);

  const appendAssistantMessage = useCallback((content: string, data?: ChatMessage['data'], intent?: string, sources?: ChatMessage['sources']) => {
    setMessages(prev => [...prev, { id: `a-${Date.now()}`, role: 'assistant', content, data, intent, sources }]);
  }, []);

  const sendMessage = useCallback(async () => {
    if (!input.trim() || loading) return;
    
    // Rate limiting: prevent rapid-fire requests
    const now = Date.now();
    if (window.__copilotLastRequest && now - window.__copilotLastRequest < 1000) {
      setError(t.rateLimited);
      return;
    }
    window.__copilotLastRequest = now;

    // Check online status
    if (!isOnline) {
      setError(t.offline);
      return;
    }

    const userMessage: ChatMessage = { id: `u-${Date.now()}`, role: 'user', content: input };
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setError(null);
    setLoading(true);

    // Simple sentiment detection for escalation hints
    const negativePhrases = /(frustrated|angry|problem|issue|bad|worst|not working|broken|terrible)/i;
    if (negativePhrases.test(input)) {
      const escalationHint = locale === 'ar' 
        ? 'يبدو أنك تواجه مشكلة. يمكنني مساعدتك بإنشاء تذكرة دعم عاجلة أو توجيهك إلى خدمة العملاء.'
        : 'You seem frustrated. I can help create a priority support ticket or direct you to customer care.';
      // Clear any pending escalation timer
      if (escalationTimerRef.current) {
        clearTimeout(escalationTimerRef.current);
      }
      escalationTimerRef.current = setTimeout(() => {
        if (mountedRef.current) {
          appendAssistantMessage(escalationHint, undefined, 'escalation_hint');
        }
      }, 500);
    }

    // Cancel any pending request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('/api/copilot/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: userMessage.content,
          history: messages.slice(-6).map(({ role, content }) => ({ role, content })),
          locale
        }),
        signal: abortControllerRef.current.signal
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.reply || data?.error || t.toolError);
      }
      appendAssistantMessage(data.reply, data.data, data.intent, data.sources);
    } catch (err: unknown) {
      // Ignore abort errors (user cancelled)
      if (err instanceof Error && err.name === 'AbortError') {
        return;
      }
      
      const error = err as Error;
      import('../lib/logger')
        .then(({ logError }) => {
          logError('Copilot chat error', error, {
            component: 'CopilotWidget',
            action: 'handleSendMessage',
            locale,
            messageLength: input.length,
          });
        })
        .catch((logErr) => {
          logger.error('Failed to log error:', { error: logErr });
        });
      
      // Report critical errors to incident system
      if (typeof window !== 'undefined' && error?.message && !error.message.includes('401')) {
        try {
          const blob = new Blob([JSON.stringify({
            code: 'UI-COPILOT-CHAT-ERR',
            message: error.message,
            details: error.stack,
            context: { locale, messageLength: input.length }
          })], { type: 'application/json' });
          navigator.sendBeacon?.('/api/support/incidents', blob);
        } catch {/* ignore reporting errors */}
      }
      
      setError(error?.message || t.toolError);
      setMessages(prev => [...prev, { id: `s-${Date.now()}`, role: 'system', content: error?.message || t.toolError }]);
    } finally {
      setLoading(false);
      abortControllerRef.current = null;
    }
  }, [appendAssistantMessage, input, loading, locale, messages, t.toolError, t.rateLimited, t.offline, isOnline]);

  const cloneInitialState = (tool: string): ToolFormState => ({ ...(initialForms[tool] ?? {}) });

  const updateForm = (tool: string, field: string, value: ToolFormValue) => {
    setForms((prev) => {
      const previousState = prev[tool] ?? cloneInitialState(tool);
      const nextState: ToolFormState = { ...previousState, [field]: value };
      return { ...prev, [tool]: nextState };
    });
  };

  const stringValue = (value: ToolFormValue, fallback = ''): string =>
    typeof value === 'string' ? value : fallback;

  const resetForm = (tool: string) => {
    setForms((prev) => ({ ...prev, [tool]: cloneInitialState(tool) }));
    // Clear any file inputs
    if (tool === 'uploadWorkOrderPhoto') {
      const fileInput = document.querySelector(`input[type="file"]`) as HTMLInputElement;
      if (fileInput) fileInput.value = '';
    }
  };

  const runTool = async (tool: string, args: Record<string, unknown>) => {
    // Check online status
    if (!isOnline) {
      setError(t.offline);
      return;
    }

    setLoading(true);
    setError(null);
    
    // Cancel any pending request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      let res: Response;
      if (tool === 'uploadWorkOrderPhoto') {
        const fd = new FormData();
        fd.append('tool', tool);
        fd.append('workOrderId', String(args.workOrderId));
        fd.append('file', args.file as File);
        res = await fetch('/api/copilot/chat', { 
          method: 'POST', 
          body: fd,
          signal: abortControllerRef.current.signal
        });
      } else {
        res = await fetch('/api/copilot/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tool: { name: tool, args }, locale }),
          signal: abortControllerRef.current.signal
        });
      }
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data?.reply || data?.error || t.toolError);
      }
      appendAssistantMessage(data.reply, data.data, data.intent);
      resetForm(tool);
      setActiveTool(null);
    } catch (err: unknown) {
      // Ignore abort errors
      if (err instanceof Error && err.name === 'AbortError') {
        return;
      }

      const error = err as Error;
      import('../lib/logger')
        .then(({ logError }) => {
          logError('Tool error', error, {
            component: 'CopilotWidget',
            action: 'handleSubmitTool',
            tool,
            locale,
          });
        })
        .catch((logErr) => {
          logger.error('Failed to log error:', { error: logErr });
        });
      
      // Report tool errors to incident system
      if (typeof window !== 'undefined' && error?.message && !error.message.includes('401')) {
        try {
          const blob = new Blob([JSON.stringify({
            code: 'UI-COPILOT-TOOL-ERR',
            message: error.message,
            details: error.stack,
            context: { tool, locale }
          })], { type: 'application/json' });
          navigator.sendBeacon?.('/api/support/incidents', blob);
        } catch {/* ignore reporting errors */}
      }

      setError(error?.message || t.toolError);
    } finally {
      setLoading(false);
      abortControllerRef.current = null;
    }
  };

  const submitTool = (tool: string) => {
    const values: ToolFormState = forms[tool] ?? cloneInitialState(tool);
    if (tool === 'uploadWorkOrderPhoto') {
      if (!values.workOrderId || !values.file) {
        setError(t.requiredField);
        return;
      }
      runTool(tool, values);
      return;
    }

    const requiredMissing = Object.entries(values).some(([key, val]) => {
          if (['description', 'assigneeUserId', 'ownerId', 'assigneeVendorId'].includes(key)) return false;
      return !val;
    });
    if (requiredMissing) {
      setError(t.requiredField);
      return;
    }
    runTool(tool, values);
  };

  const renderForm = (tool: string) => {
    const values: ToolFormState = forms[tool] ?? cloneInitialState(tool);
    switch (tool) {
      case 'createWorkOrder':
        return (
          <div className="space-y-3">
            <input value={stringValue(values.title)} onChange={(e) => updateForm(tool, 'title', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'عنوان المشكلة' : 'Issue title'} />
            <textarea value={stringValue(values.description)} onChange={(e) => updateForm(tool, 'description', e.target.value)} rows={3} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'تفاصيل إضافية' : 'Additional details'} />
            <select value={stringValue(values.priority, 'LOW')} onChange={(e) => updateForm(tool, 'priority', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary">
              <option value="LOW">{locale === 'ar' ? 'منخفض' : 'Low'}</option>
              <option value="MEDIUM">{locale === 'ar' ? 'متوسط' : 'Medium'}</option>
              <option value="HIGH">{locale === 'ar' ? 'مرتفع' : 'High'}</option>
              <option value="URGENT">{locale === 'ar' ? 'عاجل' : 'Urgent'}</option>
            </select>
          </div>
        );
      case 'dispatchWorkOrder':
        return (
          <div className="space-y-3">
            <input value={stringValue(values.workOrderId)} onChange={(e) => updateForm(tool, 'workOrderId', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'معرف أمر العمل' : 'Work order ID'} />
            <input value={stringValue(values.assigneeUserId)} onChange={(e) => updateForm(tool, 'assigneeUserId', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'معرف الفني (اختياري)' : 'Technician ID (optional)'} />
            <input value={stringValue(values.assigneeVendorId)} onChange={(e) => updateForm(tool, 'assigneeVendorId', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'معرف المورد (اختياري)' : 'Vendor ID (optional)'} />
          </div>
        );
      case 'scheduleVisit':
        return (
          <div className="space-y-3">
            <input value={stringValue(values.workOrderId)} onChange={(e) => updateForm(tool, 'workOrderId', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'معرف أمر العمل' : 'Work order ID'} />
            <input type="datetime-local" value={stringValue(values.scheduledFor)} onChange={(e) => updateForm(tool, 'scheduledFor', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" />
          </div>
        );
      case 'uploadWorkOrderPhoto':
        return (
          <div className="space-y-3">
            <input value={stringValue(values.workOrderId)} onChange={(e) => updateForm(tool, 'workOrderId', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'معرف أمر العمل' : 'Work order ID'} />
            <label className="flex cursor-pointer flex-col items-center justify-center rounded-2xl border-2 border-dashed border-border px-4 py-6 text-center text-sm text-muted-foreground hover:border-primary">
              <Upload className="mb-2 h-5 w-5 text-primary" />
              <span>{values.file instanceof File ? values.file.name : t.chooseFile}</span>
              <input type="file" className="hidden" accept="image/*" onChange={(e) => updateForm(tool, 'file', e.target.files?.[0])} />
            </label>
          </div>
        );
      case 'ownerStatements':
        return (
          <div className="space-y-3">
            <input value={stringValue(values.ownerId)} onChange={(e) => updateForm(tool, 'ownerId', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'معرف المالك (اختياري)' : 'Owner ID (optional)'} />
            <select value={stringValue(values.period, 'Q1')} onChange={(e) => updateForm(tool, 'period', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary">
              <option value="YTD">{locale === 'ar' ? 'منذ بداية العام' : 'Year to date'}</option>
              <option value="Q1">Q1</option>
              <option value="Q2">Q2</option>
              <option value="Q3">Q3</option>
              <option value="Q4">Q4</option>
            </select>
            <input value={stringValue(values.year)} onChange={(e) => updateForm(tool, 'year', e.target.value)} className="w-full rounded-2xl border border-border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary" placeholder={locale === 'ar' ? 'السنة' : 'Year'} />
          </div>
        );
      default:
        return null;
    }
  };

  const panel = (
    <motion.div
      initial={embedded ? undefined : { opacity: 0, scale: 0.92, y: 16 }}
      animate={embedded ? undefined : { opacity: 1, scale: 1, y: 0 }}
      exit={embedded ? undefined : { opacity: 0, scale: 0.92, y: 16 }}
      transition={{ duration: 0.2 }}
      className={`overflow-hidden rounded-2xl border border-border bg-card shadow-2xl ${embedded ? 'w-full' : 'w-[360px] max-w-[90vw]'}`}
    >
      <div className="flex items-start justify-between bg-primary px-4 py-3 text-white">
        <div>
          <div className="flex items-center gap-2 font-semibold"><Bot className="h-5 w-5" />{t.title}</div>
          <p className="text-xs opacity-80">{t.subtitle(profile?.session.name, profile?.session.role)}</p>
        </div>
        {!embedded && (
          <button type="button" onClick={() => setIsOpen(false)} className="rounded-full p-1 hover:bg-white/10" aria-label={t.close}>
            <X className="h-4 w-4" />
          </button>
        )}
      </div>

      <div className="flex items-center justify-between gap-2 border-b border-border bg-muted px-4 py-2 text-[11px] text-muted-foreground">
        <div className="flex items-center gap-2">
          <ShieldCheck className="h-4 w-4 text-success" />
          {t.privacy}
        </div>
        {!isOnline && (
          <div className="flex items-center gap-1 text-amber-600" role="status" aria-live="polite">
            <WifiOff className="h-3 w-3" />
            <span>{locale === 'ar' ? 'بدون اتصال' : 'Offline'}</span>
          </div>
        )}
      </div>

      {/* Message container with aria-live for screen reader announcements */}
      <div 
        ref={scrollRef} 
        className="max-h-[320px] overflow-y-auto px-4 py-4 space-y-3"
        aria-live="polite"
        aria-atomic="false"
        role="log"
        aria-label={locale === 'ar' ? 'سجل المحادثة' : 'Chat conversation log'}
      >
        {messages.map(message => (
          <div key={message.id} className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}>
            <div className={`max-w-[85%] rounded-2xl px-4 py-3 text-sm shadow-sm ${message.role === 'user' ? 'bg-success text-white' : message.role === 'system' ? 'bg-amber-50 text-amber-800' : 'border border-border bg-card text-foreground'}`}>
              <div className="whitespace-pre-wrap leading-relaxed">{message.content}</div>
              {renderStructuredData(message, locale)}
              {message.sources && message.sources.length > 0 && (
                <div className="mt-3 border-t border-border pt-2 text-[11px] text-muted-foreground">
                  <div className="mb-1 font-semibold text-muted-foreground">{locale === 'ar' ? 'المراجع' : 'Sources'}</div>
                  <ul className="space-y-1">
                    {message.sources.map(src => (
                      <li key={src.id} className="flex items-center gap-1">
                        <FileText className="h-3 w-3" />
                        <span>{src.title}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </div>
        ))}
        {loading && (
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Loader2 className="h-4 w-4 animate-spin" />
            {t.loading}
          </div>
        )}
        {error && (
          <div className="flex items-center gap-2 rounded-2xl border border-amber-300 bg-amber-50 px-3 py-2 text-xs text-amber-700">
            <AlertTriangle className="h-4 w-4" />
            {error}
          </div>
        )}
      </div>

      {quickActions.length > 0 && (
        <div className="border-t border-border bg-muted px-4 py-3">
          <div className="mb-2 text-xs font-semibold text-muted-foreground">{t.quickActions}</div>
          <div className="flex flex-wrap gap-2">
            {quickActions.map(action => (
              <button
                key={action.name}
                onClick={() => setActiveTool(prev => prev === action.name ? null : action.name)}
                className={`flex items-center gap-2 rounded-full border px-3 py-1.5 text-xs transition ${activeTool === action.name ? 'border-primary bg-primary/10 text-primary' : 'border-border bg-card text-foreground hover:border-primary hover:text-primary'}`}
              >
                {toolIcons[action.name] || <ClipboardList className="h-4 w-4" />}
                {action.label}
              </button>
            ))}
          </div>
          <AnimatePresence>
            {activeTool && (
              <motion.div
                key={activeTool}
                initial={{ height: 0, opacity: 0 }}
                animate={{ height: 'auto', opacity: 1 }}
                exit={{ height: 0, opacity: 0 }}
                className="mt-3 rounded-2xl border border-border bg-card p-3"
              >
                <div className="mb-2 text-xs font-semibold text-muted-foreground">{quickActions.find(a => a.name === activeTool)?.label}</div>
                {renderForm(activeTool)}
                <div className="mt-3 flex items-center justify-end gap-2">
                  <button type="button" onClick={() => { resetForm(activeTool); setActiveTool(null); }} className="rounded-full px-3 py-1.5 text-xs text-muted-foreground hover:bg-muted">
                    {t.cancel}
                  </button>
                  <button type="button" onClick={() => submitTool(activeTool)} className="rounded-full bg-primary px-4 py-1.5 text-xs font-semibold text-white hover:bg-primary-dark">
                    {t.run}
                  </button>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      )}

      <div className="border-t border-border bg-card px-4 py-3">
        <div className="flex items-center gap-2">
          {recognitionRef.current && (
            <button
              type="button"
              onClick={startListening}
              disabled={isListening || loading || !isOnline}
              className={`flex h-10 w-10 items-center justify-center rounded-full shadow transition disabled:cursor-not-allowed disabled:opacity-50 ${
                isListening 
                  ? 'animate-pulse bg-amber-500 text-white' 
                  : 'bg-muted text-muted-foreground hover:bg-muted-dark hover:text-foreground'
              }`}
              aria-label={locale === 'ar' ? 'إدخال صوتي' : 'Voice input'}
              title={isListening ? (locale === 'ar' ? 'جارٍ الاستماع...' : 'Listening...') : (locale === 'ar' ? 'إدخال صوتي' : 'Voice input')}
            >
              <svg className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clipRule="evenodd" />
              </svg>
            </button>
          )}
          <input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }}
            placeholder={t.placeholder}
            className="flex-1 rounded-full border border-border px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary"
            disabled={loading}
          />
          <button
            onClick={sendMessage}
            disabled={!input.trim() || loading || !isOnline}
            className="flex h-10 w-10 items-center justify-center rounded-full bg-success text-white shadow transition hover:bg-success-dark disabled:cursor-not-allowed disabled:opacity-50"
            aria-label={t.send}
            title={!isOnline ? t.offline : t.send}
          >
            {loading ? <Loader2 className="h-4 w-4 animate-spin" /> : <Send className="h-4 w-4" />}
          </button>
        </div>
      </div>
    </motion.div>
  );

  if (embedded) {
    return (
      <div dir={isRTL ? 'rtl' : 'ltr'} className="w-full">
        {panel}
      </div>
    );
  }

  return (
    <div dir={isRTL ? 'rtl' : 'ltr'}>
      <div className="fixed bottom-6 end-6 z-50 flex flex-col items-end gap-3">
        <AnimatePresence>
          {isOpen && panel}
        </AnimatePresence>
        <motion.button
          whileTap={{ scale: 0.94 }}
          onClick={() => setIsOpen(prev => !prev)}
          className="flex h-14 w-14 items-center justify-center rounded-full bg-primary text-white shadow-xl transition hover:bg-primary-dark"
          aria-label={isOpen ? t.close : t.open}
        >
          {isOpen ? <X className="h-6 w-6" /> : <Bot className="h-6 w-6" />}
        </motion.button>
      </div>
    </div>
  );
}

]]>
</file>

<file path="components/CustomCursor.tsx">
<![CDATA[
"use client";

import React, { useEffect, useRef, useState } from 'react';

const TRAIL_COUNT = 8; // number of trailing particles (adjust 5–10 as needed)

interface Position {
  x: number;
  y: number;
}

/**
 * Check if an element or any of its ancestors is an interactive element.
 * Used to determine when to show hover state on the custom cursor.
 */
const isInteractiveElement = (el: HTMLElement | null): boolean => {
  while (el) {
    const tag = el.tagName.toLowerCase();
    const role = el.getAttribute('role') || '';
    if (
      tag === 'a' ||
      tag === 'button' ||
      tag === 'input' ||
      tag === 'select' ||
      tag === 'textarea' ||
      el.hasAttribute('data-cursor-interactive') ||
      role === 'button' ||
      role === 'link' ||
      role === 'menuitem' ||
      role === 'checkbox' ||
      role === 'switch'
    ) {
      return true;
    }
    el = el.parentElement;
  }
  return false;
};

/**
 * CustomCursor component
 * 
 * A floating custom cursor with trailing anti-gravity particles using Fixzit brand colors.
 * - Disabled on touch devices for responsiveness
 * - Glows on interactive elements (buttons, links, inputs)
 * - Uses brand colors: #0061A8 (blue), #00A859 (green), #FFB400 (gold)
 */
const CustomCursor: React.FC = () => {
  // State for client-side detection (prevents SSR hydration mismatch)
  const [shouldRender, setShouldRender] = useState(false);
  
  // Refs for cursor elements
  const mainDotRef = useRef<HTMLDivElement>(null);
  const trailRefs = useRef<HTMLDivElement[]>([]);
  // Pointer position and trailing positions
  const pointerPos = useRef<Position>({ x: 0, y: 0 });
  const trailPositions = useRef<Position[]>(
    Array.from({ length: TRAIL_COUNT }, () => ({ x: 0, y: 0 }))
  );
  // Animation frame handle
  const rafId = useRef<number | null>(null);
  // Track if component is mounted (for SSR safety)
  const isMounted = useRef(false);

  // Determine if cursor should render (client-side only to prevent SSR mismatch)
  useEffect(() => {
    if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
      setShouldRender(true);
      return;
    }

    const reduceMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    const finePointerQuery = window.matchMedia('(any-pointer: fine)');
    const fallbackFinePointerQuery = window.matchMedia('(pointer: fine)');

    const addMediaListener = (query: MediaQueryList, handler: () => void) => {
      if (typeof query.addEventListener === 'function') {
        query.addEventListener('change', handler);
      } else if (typeof query.addListener === 'function') {
        query.addListener(handler);
      }
    };

    const removeMediaListener = (query: MediaQueryList, handler: () => void) => {
      if (typeof query.removeEventListener === 'function') {
        query.removeEventListener('change', handler);
      } else if (typeof query.removeListener === 'function') {
        query.removeListener(handler);
      }
    };

    const updateShouldRender = () => {
      const prefersReducedMotion = reduceMotionQuery.matches;
      const hasFinePointer = finePointerQuery.matches || fallbackFinePointerQuery.matches;
      const touchOnlyDevice =
        typeof navigator.maxTouchPoints === 'number'
          ? navigator.maxTouchPoints > 0 && !hasFinePointer
          : !hasFinePointer;

      setShouldRender(!prefersReducedMotion && !touchOnlyDevice);
    };

    const handlePointerDetected = (event: PointerEvent) => {
      if (reduceMotionQuery.matches) return;
      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
        setShouldRender(true);
      }
    };

    updateShouldRender();

    addMediaListener(reduceMotionQuery, updateShouldRender);
    addMediaListener(finePointerQuery, updateShouldRender);
    addMediaListener(fallbackFinePointerQuery, updateShouldRender);
    window.addEventListener('pointermove', handlePointerDetected);
    window.addEventListener('pointerdown', handlePointerDetected);

    return () => {
      removeMediaListener(reduceMotionQuery, updateShouldRender);
      removeMediaListener(finePointerQuery, updateShouldRender);
      removeMediaListener(fallbackFinePointerQuery, updateShouldRender);
      window.removeEventListener('pointermove', handlePointerDetected);
      window.removeEventListener('pointerdown', handlePointerDetected);
    };
  }, []);

  useEffect(() => {
    if (!shouldRender) return;
    
    isMounted.current = true;

    const body = document.body;
    body.classList.add('custom-cursor-active'); // add class for custom cursor styling

    // Initialize positions to center of viewport (fallback until first mouse move)
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    pointerPos.current = { x: centerX, y: centerY };
    trailPositions.current = Array.from({ length: TRAIL_COUNT }, () => ({ x: centerX, y: centerY }));

    // Pointer move handler: update target pointer coordinates
    const handlePointerMove = (e: MouseEvent) => {
      pointerPos.current.x = e.clientX;
      pointerPos.current.y = e.clientY;
    };

    // Hover handlers for interactive elements (cursor glow)
    const handlePointerOver = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (!target) return;
      if (isInteractiveElement(target) && mainDotRef.current) {
        mainDotRef.current.classList.add('cursor--hover');
      }
    };

    const handlePointerOut = (e: MouseEvent) => {
      if (!mainDotRef.current) return;
      const related = e.relatedTarget as HTMLElement;
      // If moving to another interactive element, do not remove glow yet
      if (related && isInteractiveElement(related)) {
        return;
      }
      // Otherwise, remove hover class
      mainDotRef.current.classList.remove('cursor--hover');
    };

    // Animation loop for cursor trailing effect
    const animate = () => {
      if (!isMounted.current) return;
      
      const { x: currentX, y: currentY } = pointerPos.current;
      const positions = trailPositions.current;
      // Update first trailing position (index 0) to move towards pointer
      positions[0].x += (currentX - positions[0].x) * 0.2;
      positions[0].y += (currentY - positions[0].y) * 0.2;
      // Apply slight upward drift for anti-gravity feel
      positions[0].y -= 0.5;
      // Update subsequent trailing positions to follow the one ahead
      for (let i = 1; i < TRAIL_COUNT; i++) {
        positions[i].x += (positions[i - 1].x - positions[i].x) * 0.2;
        positions[i].y += (positions[i - 1].y - positions[i].y) * 0.2;
        positions[i].y -= 0.5; // upward drift
      }
      // Position main cursor at exact pointer
      if (mainDotRef.current) {
        const translate = `translate3d(${currentX}px, ${currentY}px, 0) translate(-50%, -50%)`;
        mainDotRef.current.style.transform = translate;
      }
      // Position trailing dots
      trailRefs.current.forEach((dot, index) => {
        if (!dot) return;
        const pos = positions[index];
        const translate = `translate3d(${pos.x}px, ${pos.y}px, 0) translate(-50%, -50%)`;
        dot.style.transform = translate;
      });
      rafId.current = requestAnimationFrame(animate);
    };

    // Start tracking
    document.addEventListener('mousemove', handlePointerMove);
    document.addEventListener('pointerover', handlePointerOver);
    document.addEventListener('pointerout', handlePointerOut);
    rafId.current = requestAnimationFrame(animate);

    return () => {
      // Cleanup on unmount
      isMounted.current = false;
      body.classList.remove('custom-cursor-active');
      document.removeEventListener('mousemove', handlePointerMove);
      document.removeEventListener('pointerover', handlePointerOver);
      document.removeEventListener('pointerout', handlePointerOut);
      if (rafId.current) cancelAnimationFrame(rafId.current);
    };
  }, [shouldRender]);

  // Don't render on server or when disabled
  if (!shouldRender) {
    return null;
  }

  // Render custom cursor elements
  return (
    <div className="custom-cursor-container" aria-hidden="true">
      <div ref={mainDotRef} className="cursor-dot cursor-main" />
      {Array.from({ length: TRAIL_COUNT }).map((_, i) => (
        <div
          key={i}
          ref={(el) => {
            if (el) trailRefs.current[i] = el;
          }}
          className="cursor-dot cursor-trail"
          // Inline styles for trailing dots (color/opacity vary by index)
          // Uses CSS variables defined in globals.css for maintainability
          style={{
            backgroundColor: i % 3 === 0 ? 'var(--cursor-primary)' : i % 3 === 1 ? 'var(--cursor-secondary)' : 'var(--cursor-accent)',
            opacity: 0.6 + (0.4 * (TRAIL_COUNT - i - 1)) / TRAIL_COUNT, // more faint for further particles
          }}
        />
      ))}
    </div>
  );
};

export default CustomCursor;

]]>
</file>

<file path="components/ErrorBoundary.tsx">
<![CDATA[
"use client";

import React, { type ReactNode } from "react";
import Link from "next/link";
import { AlertTriangle, Home, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { STORAGE_KEYS } from "@/config/constants";
import { logger } from "@/lib/logger";
import { useTranslation } from "@/contexts/TranslationContext";

type ErrorBoundaryProps = {
  children: ReactNode;
  fallback?: ReactNode;
};

type ErrorState = {
  hasError: boolean;
  errorId: string;
};

/**
 * ✅ REFACTORED ErrorBoundary Component
 *
 * ARCHITECTURE FIXES:
 * 1. ✅ REMOVED all dangerous "auto-fix" logic (e.g., localStorage.clear()).
 * 2. ✅ REMOVED all hardcoded colors and CSS variables.
 * 3. ✅ USES standard <Card> and <Button> components.
 * 4. ✅ FULLY translatable with useTranslation (via ErrorFallbackUI).
 * 5. ✅ THEME-AWARE: Works in Light/Dark mode.
 * 6. ✅ REMOVED all insecure localStorage scraping for PII.
 * 7. ✅ Safely reports the incident.
 */
export default class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  ErrorState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, errorId: "" };
  }

  static getDerivedStateFromError(): ErrorState {
    const errorId = `ERR-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    return { hasError: true, errorId };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    const { errorId } = this.state;
    // Use logger instead of console for production-safe error reporting
    if (typeof window !== "undefined") {
      import("../lib/logger")
        .then(({ logError }) => {
          logError(`ErrorBoundary caught error ${errorId}`, error, {
            component: "ErrorBoundary",
            errorId,
            componentStack: errorInfo.componentStack,
          });
        })
        .catch((err) => {
          logger.error("Failed to import logger:", err);
        });
    }

    // --- Safe Incident Reporting ---
    try {
      // ✅ FIX: Safely get non-PII user context
      const userSession = localStorage.getItem(STORAGE_KEYS.userSession);
      const user = userSession ? JSON.parse(userSession) : null;
      // [CODE REVIEW]: Use id only (frontend schema consistency)
      const safeUser = user
        ? { userId: user.id, orgId: user.orgId }
        : undefined;

      const truncate = (s?: string, n = 2000) =>
        s && s.length > n ? `${s.slice(0, n)}…` : s;

      const payload = {
        code: "UI-RENDER-ERROR",
        correlationId: errorId,
        message: truncate(error.message, 500),
        details: truncate(error.stack, 2000),
        componentStack: truncate(errorInfo.componentStack || undefined, 2000),
        userContext: safeUser,
        clientContext: {
          url: window.location.href,
          userAgent: navigator.userAgent,
          locale: navigator.language,
          rtl: document.dir === "rtl",
          time: new Date().toISOString(),
        },
      };

      // Prevent duplicate submission
      if (typeof sessionStorage !== "undefined") {
        const last = sessionStorage.getItem("fxz_last_incident");
        if (last === errorId) return;
        sessionStorage.setItem("fxz_last_incident", errorId);
      }

      // Use sendBeacon for reliability
      const blob = new Blob([JSON.stringify(payload)], {
        type: "application/json",
      });
      navigator.sendBeacon("/api/support/incidents", blob);
    } catch (reportError: unknown) {
      // Use logger for incident reporting failures
      if (typeof window !== "undefined") {
        import("../lib/logger")
          .then(({ logError }) => {
            logError("Failed to send incident report", reportError as Error, {
              component: "ErrorBoundary",
              action: "sendIncidentReport",
            });
          })
          .catch((err) => {
            logger.error("Failed to import logger:", err);
          });
      }
    }
  }

  handleManualRefresh = () => {
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      // This Fallback UI is a separate functional component
      // so that it can safely use hooks (like useTranslation)
      // without crashing the class component.
      return (
        <ErrorFallbackUI
          errorId={this.state.errorId}
          onRefresh={this.handleManualRefresh}
        />
      );
    }

    return this.props.children;
  }
}

/**
 * This is a separate functional component that *can* use hooks.
 * This is the UI shown to the user *after* the crash.
 * We wrap it in its own try/catch in case the TranslationProvider crashed.
 */
const ErrorFallbackUI = ({
  errorId,
  onRefresh,
}: {
  errorId: string;
  onRefresh: () => void;
}) => {
  const { t } = useTranslation();

  return (
    <div className="min-h-screen flex items-center justify-center bg-background p-4">
      <Card className="max-w-xl w-full">
        <CardHeader>
          <div className="flex justify-center mb-4">
            {/* ✅ FIX: Use semantic colors */}
            <div className="w-16 h-16 bg-destructive/10 rounded-full flex items-center justify-center">
              <AlertTriangle className="w-8 h-8 text-destructive" />
            </div>
          </div>
          <CardTitle className="text-center text-2xl">
            {t("error.boundary.title", "An Error Occurred")}
          </CardTitle>
          <CardDescription className="text-center">
            {t(
              "error.boundary.desc",
              "We apologize for the inconvenience. Our team has been notified.",
            )}
          </CardDescription>
        </CardHeader>
        <CardContent className="text-center">
          <div className="mb-6 p-3 bg-muted rounded-lg">
            <p className="text-sm text-muted-foreground">
              {t("error.boundary.ref", "Error Reference ID")}:
            </p>
            <code className="font-mono text-base text-foreground">
              {errorId}
            </code>
          </div>

          {/* ✅ FIX: Use standard Button components */}
          <div className="flex gap-3 justify-center">
            <Button variant="outline" onClick={onRefresh}>
              <RefreshCw className="w-4 h-4 me-2" />
              {t("error.boundary.refresh", "Refresh Page")}
            </Button>
            <Button asChild>
              <Link href="/">
                <Home className="w-4 h-4 me-2" />
                {t("common.backToHome", "Back to Home")}
              </Link>
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

]]>
</file>

<file path="components/ErrorTest.tsx">
<![CDATA[
"use client";

import { useEffect, useState } from "react";

const QA_FLAG_KEY = "fxz.qa-tools";
const ALLOWED_QA_ROLES = ["SUPER_ADMIN", "QA", "DEVELOPER", "ADMIN"];

export default function ErrorTest() {
  const [showTest, setShowTest] = useState(false);
  const [qaEnabled, setQaEnabled] = useState(false);
  const [roleAuthorized, setRoleAuthorized] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }

    // Check user role authorization
    const checkRoleAuth = async () => {
      try {
        const response = await fetch("/api/auth/me", {
          credentials: "include",
        });
        if (response.ok) {
          const data = await response.json();
          const userRole = data.role;
          if (ALLOWED_QA_ROLES.includes(userRole)) {
            setRoleAuthorized(true);
          }
        }
      } catch {
        // Unable to verify user role for QA tools
      } finally {
        setIsLoading(false);
      }
    };

    checkRoleAuth();

    try {
      const params = new URLSearchParams(window.location.search);
      if (params.get("qa") === "1") {
        localStorage.setItem(QA_FLAG_KEY, "enabled");
        setQaEnabled(true);
        return;
      }

      if (localStorage.getItem(QA_FLAG_KEY) === "enabled") {
        setQaEnabled(true);
      }
    } catch {
      // Unable to initialize QA error test tools
    }
  }, []);

  // Only show QA tools if both enabled AND user has authorized role
  if (isLoading) {
    return null; // Or a loading spinner if you prefer
  }

  if (!qaEnabled || !roleAuthorized) {
    return null;
  }

  const triggerError = () => {
    // This will trigger the error boundary
    throw new Error("Test error triggered by user for error boundary testing");
  };

  const triggerAsyncError = async () => {
    // Simulate an async error
    await new Promise((resolve) => setTimeout(resolve, 1000));
    throw new Error("Async test error triggered by user");
  };

  const triggerJSONError = () => {
    // Simulate JSON parsing error
    JSON.parse("{invalid json}");
  };

  const triggerNetworkError = () => {
    // Simulate network error
    fetch("https://invalid-url-that-does-not-exist.com/api/test");
  };

  if (!showTest) {
    return (
      <button
        onClick={() => setShowTest(true)}
        className="fixed bottom-20 end-6 bg-destructive text-destructive-foreground px-4 py-2 rounded-2xl shadow-lg hover:bg-destructive/90 z-50"
      >
        🧪 Test Error Boundary
      </button>
    );
  }

  return (
    <div className="fixed bottom-20 end-6 bg-card border border-border rounded-2xl shadow-lg p-4 z-50 max-w-sm">
      <div className="flex justify-between items-center mb-3">
        <h3 className="font-semibold text-foreground">🧪 Error Testing</h3>
        <button
          onClick={() => setShowTest(false)}
          className="text-muted-foreground hover:text-muted-foreground"
        >
          ✕
        </button>
      </div>

      <div className="space-y-2">
        <button
          onClick={triggerError}
          className="w-full bg-destructive text-destructive-foreground px-3 py-2 rounded text-sm hover:bg-destructive/90"
        >
          🔴 Runtime Error
        </button>

        <button
          onClick={triggerAsyncError}
          className="w-full bg-warning text-warning-foreground px-3 py-2 rounded text-sm hover:bg-warning/90"
        >
          🟠 Async Error
        </button>

        <button
          onClick={triggerJSONError}
          className="w-full bg-secondary text-secondary-foreground px-3 py-2 rounded text-sm hover:bg-secondary/90"
        >
          🟡 JSON Parse Error
        </button>

        <button
          onClick={triggerNetworkError}
          className="w-full bg-primary text-primary-foreground px-3 py-2 rounded text-sm hover:bg-primary/90"
        >
          🔵 Network Error
        </button>
      </div>

      <div className="mt-3 pt-3 border-t border-border text-xs text-muted-foreground">
        <p>Click any button above to test the enhanced error boundary with:</p>
        <ul className="mt-1 space-y-1">
          <li>• Error ID generation</li>
          <li>• Copy to clipboard functionality</li>
          <li>• Automatic support ticket creation</li>
          <li>• Welcome email for guests</li>
        </ul>
      </div>
    </div>
  );
}

]]>
</file>

<file path="components/FlagIcon.tsx">
<![CDATA[
import * as React from "react";

type FlagCode = "gb" | "sa";

interface FlagIconProps {
  code: FlagCode;
  className?: string;
  title?: string;
}

const FLAG_TITLES: Record<FlagCode, string> = {
  gb: "United Kingdom",
  sa: "Saudi Arabia",
};

export const FlagIcon: React.FC<FlagIconProps> = ({
  code,
  className,
  title,
}) => {
  if (code === "sa") {
    return (
      <svg
        viewBox="0 0 24 16"
        className={className}
        aria-hidden={!title}
        role="img"
        focusable="false"
      >
        <title>{title ?? FLAG_TITLES[code]}</title>
        <rect width="24" height="16" fill="#006C35" />
        <path d="M6 6h12v2H6zM10 10h4v1h-4z" fill="#fff" />
      </svg>
    );
  }

  return (
    <svg
      viewBox="0 0 24 16"
      className={className}
      aria-hidden={!title}
      role="img"
      focusable="false"
    >
      <title>{title ?? FLAG_TITLES[code]}</title>
      <rect width="24" height="16" fill="#012169" />
      <path d="M0 0l24 16M24 0L0 16" stroke="#fff" strokeWidth="3" />
      <path d="M0 0l24 16M24 0L0 16" stroke="#C8102E" strokeWidth="1.6" />
      <rect x="10" width="4" height="16" fill="#fff" />
      <rect y="6" width="24" height="4" fill="#fff" />
      <rect x="11" width="2" height="16" fill="#C8102E" />
      <rect y="7" width="24" height="2" fill="#C8102E" />
    </svg>
  );
};

]]>
</file>

<file path="components/Footer.tsx">
<![CDATA[
"use client";
import React from "react";
import Link from "next/link";
import { useState, useEffect } from "react";
import { Home } from "lucide-react";
import SupportPopup from "@/components/SupportPopup";
import { useTranslation } from "@/contexts/TranslationContext";
import LanguageSelector from "@/components/i18n/LanguageSelector";
import CurrencySelector from "@/components/i18n/CurrencySelector";

/**
 * Responsive site footer component with company, legal, and support links.
 *
 * Features:
 * - Brand identity with "Back to Home" link
 * - Language and currency selectors (compact variants)
 * - Multi-column link grid (Company, Legal, Support)
 * - Support ticket popup integration
 * - Full RTL support with flex-row-reverse for proper layout mirroring
 * - Theme-consistent colors using Tailwind's brand color classes
 * - Accessibility-ready with semantic HTML
 *
 * RTL Enhancements:
 * - Uses flex-row-reverse for proper element ordering in RTL
 * - Text alignment respects reading direction
 * - Maintains visual hierarchy in both LTR and RTL modes
 *
 * @returns {JSX.Element} The footer JSX element.
 */
export default function Footer() {
  const [open, setOpen] = useState(false);
  const [currentYear, setCurrentYear] = useState("");

  // Use the translation context directly - it has its own fallback
  const { t, isRTL: translationIsRTL } = useTranslation();

  // Client-side hydration for current year to avoid SSR mismatch
  useEffect(() => {
    setCurrentYear(new Date().getFullYear().toString());
  }, []);

  return (
    <footer className="border-t bg-card/70 backdrop-blur">
      <div className="mx-auto max-w-7xl px-4 lg:px-6 py-6 space-y-6 text-sm">
        <div
          className={`flex flex-col gap-3 md:flex-row md:items-center md:justify-between ${translationIsRTL ? "md:flex-row-reverse" : ""}`}
        >
          <div className="font-semibold mb-2">
            {t("footer.brand", "Fixzit")}
          </div>
          <Link
            href="/"
            className="inline-flex items-center gap-2 text-primary hover:text-primary dark:text-primary/80 dark:hover:text-primary/60"
          >
            <Home className="h-4 w-4" />
            <span>{t("footer.backHome", "Back to Home")}</span>
          </Link>
          <div
            className={`flex items-center gap-3 ${translationIsRTL ? "flex-row-reverse" : ""}`}
          >
            <LanguageSelector variant="compact" />
            <CurrencySelector variant="compact" />
          </div>
        </div>
        <div className="grid gap-6 sm:grid-cols-2 md:grid-cols-4 text-sm">
          <div>
            <div className="font-semibold mb-2">
              {t("footer.company", "Company")}
            </div>
            <ul className="space-y-1 opacity-80">
              <li>
                <Link href="/about" className="hover:underline">
                  {t("footer.about", "About")}
                </Link>
              </li>
              <li>
                <Link href="/careers" className="hover:underline">
                  {t("footer.careers", "Careers")}
                </Link>
              </li>
              <li>
                <Link href="/pricing" className="hover:underline">
                  {t("footer.pricing", "Pricing & Trial")}
                </Link>
              </li>
            </ul>
          </div>
          <div>
            <div className="font-semibold mb-2">
              {t("footer.legal", "Legal")}
            </div>
            <ul className="space-y-1 opacity-80">
              <li>
                <Link href="/privacy" className="hover:underline">
                  {t("footer.privacy", "Privacy")}
                </Link>
              </li>
              <li>
                <Link href="/terms" className="hover:underline">
                  {t("footer.terms", "Terms")}
                </Link>
              </li>
            </ul>
          </div>
          <div>
            <div className="font-semibold mb-2">
              {t("footer.support", "Support")}
            </div>
            <ul className="space-y-1 opacity-80">
              <li>
                <Link href="/help" className="hover:underline">
                  {t("footer.help", "Help Center")}
                </Link>
              </li>
              <li>
                <button
                  type="button"
                  className="hover:underline text-start"
                  onClick={() => setOpen(true)}
                >
                  {t("footer.ticket", "Open a ticket")}
                </button>
              </li>
            </ul>
          </div>
        </div>
        <div className="flex flex-col gap-3 border-t border-border pt-4 text-xs opacity-80 md:flex-row md:items-center md:justify-between">
          <div className="space-y-1">
            <div>
              © {currentYear || "..."}{" "}
              {t("footer.copyright", "Fixzit. All rights reserved.")}
            </div>
            <nav
              aria-label={t("footer.breadcrumbLabel", "Fixzit trail")}
              className={`flex flex-wrap items-center gap-2 text-[11px] ${translationIsRTL ? "flex-row-reverse" : ""}`}
            >
              <span>{t("footer.crumb.fixzit", "Fixzit")}</span>
              <span aria-hidden>›</span>
              <span>{t("footer.crumb.platform", "Design System")}</span>
              <span aria-hidden>›</span>
              <span>{t("footer.crumb.version", "v2")}</span>
            </nav>
          </div>
          <div
            className={`flex gap-4 ${translationIsRTL ? "flex-row-reverse" : ""}`}
          >
            <Link href="/privacy" className="hover:underline">
              {t("footer.privacy", "Privacy")}
            </Link>
            <Link href="/terms" className="hover:underline">
              {t("footer.terms", "Terms")}
            </Link>
            <Link href="/support" className="hover:underline">
              {t("footer.support", "Support")}
            </Link>
          </div>
        </div>
      </div>
      {open && <SupportPopup open={open} onClose={() => setOpen(false)} />}
    </footer>
  );
}

]]>
</file>

<file path="components/GoogleMap.tsx">
<![CDATA[
"use client";
import { logger } from "@/lib/logger";
/// <reference types="google.maps" />

import { useEffect, useMemo, useRef, useState } from "react";
import { Loader as Spinner } from "lucide-react";

type LatLng = { lat: number; lng: number };
type MarkerInput = {
  position: LatLng;
  title?: string;
  info?: string;
};

type GoogleMapProps = {
  center: LatLng;
  zoom?: number;
  markers?: MarkerInput[];
  height?: string | number;
  onMapClick?: (lat: number, lng: number) => void;
  mapId?: string;
  libraries?: string[];
  language?: string;
  region?: string;
  fitToMarkers?: boolean;
  gestureHandling?: "cooperative" | "greedy" | "none" | "auto";
  disableDefaultUI?: boolean;
  onReady?: (map: google.maps.Map) => void;
};

declare global {
  interface Window {
    __gmapsPromise?: Promise<void>;
  }
}

function loadGoogleMapsOnce(opts: {
  apiKey: string;
  language?: string;
  region?: string;
  libraries?: string[];
}) {
  if (typeof window === "undefined") return Promise.resolve();

  if (window.google?.maps) return Promise.resolve();

  if (!window.__gmapsPromise) {
    const { apiKey, language, region, libraries } = opts;
    const params = new URLSearchParams({
      key: apiKey,
      v: "weekly",
    });
    if (language) params.set("language", language);
    if (region) params.set("region", region);
    if (libraries && libraries.length)
      params.set("libraries", libraries.join(","));

    window.__gmapsPromise = new Promise<void>((resolve, reject) => {
      const id = "gmaps-sdk";
      const existing = document.getElementById(id) as HTMLScriptElement | null;
      if (existing) {
        // Check if google maps API is already loaded
        if (typeof window.google !== "undefined" && window.google.maps) {
          resolve();
          return;
        }
        // Attach listeners for scripts still loading
        existing.addEventListener("load", () => resolve(), { once: true });
        existing.addEventListener(
          "error",
          () => reject(new Error("Google Maps script error")),
          { once: true },
        );
        return;
      }

      const script = document.createElement("script");
      script.id = id;
      script.src = `https://maps.googleapis.com/maps/api/js?${params.toString()}`;
      script.async = true;
      script.defer = true;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error("Google Maps script error"));
      document.head.appendChild(script);
    }).catch((e) => {
      window.__gmapsPromise = undefined;
      throw e;
    });
  }
  return window.__gmapsPromise;
}

function createInfoWindowContent(
  title?: string,
  info?: string,
): HTMLDivElement {
  const contentDiv = document.createElement("div");
  contentDiv.style.padding = "8px";
  contentDiv.style.maxWidth = "280px";

  if (title) {
    const strong = document.createElement("strong");
    strong.textContent = title;
    contentDiv.appendChild(strong);
    contentDiv.appendChild(document.createElement("br"));
  }
  if (info) {
    const span = document.createElement("span");
    span.textContent = info;
    contentDiv.appendChild(span);
  }
  return contentDiv;
}

export default function GoogleMap({
  center,
  zoom = 13,
  markers = [],
  height = 400,
  onMapClick,
  mapId,
  libraries = [],
  language,
  region = "SA",
  fitToMarkers = true,
  gestureHandling = "cooperative",
  disableDefaultUI = false,
  onReady,
}: GoogleMapProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const mapRef = useRef<google.maps.Map | null>(null);
  const markerRefs = useRef<google.maps.Marker[]>([]);
  const infoRefs = useRef<google.maps.InfoWindow[]>([]);
  const listenerRefs = useRef<google.maps.MapsEventListener[]>([]);
  const clickListenerRef = useRef<google.maps.MapsEventListener | null>(null);
  const onMapClickRef = useRef(onMapClick);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    onMapClickRef.current = onMapClick;
  }, [onMapClick]);

  const apiKey = useMemo(() => {
    const key = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;
    // Whitelist of known placeholders - return empty string only for exact matches
    const placeholders = [
      "your_api_key_here",
      "dev-google-maps-api-key",
      "YOUR_API_KEY",
      "YOUR_GOOGLE_MAPS_API_KEY",
    ];
    return key && !placeholders.includes(key) ? key : "";
  }, []);

  // Initialize map - runs once on mount. Props like apiKey, language, region, libraries, mapId,
  // gestureHandling, and disableDefaultUI are intentionally initialization-only and not included
  // in dependencies. Changing these at runtime would require full map teardown/recreation which
  // is not supported. center/zoom updates are handled by separate effects below.
  useEffect(() => {
    let cancelled = false;

    const init = async () => {
      if (!containerRef.current) return;
      if (!apiKey) {
        setError(
          "Google Maps requires a valid API key. Ask your admin to set NEXT_PUBLIC_GOOGLE_MAPS_API_KEY and enable billing.",
        );
        setLoading(false);
        return;
      }

      try {
        await loadGoogleMapsOnce({ apiKey, language, region, libraries });
        if (cancelled) return;

        const map = new google.maps.Map(containerRef.current, {
          center,
          zoom,
          mapId,
          zoomControl: true,
          streetViewControl: false,
          fullscreenControl: true,
          mapTypeControl: false,
          gestureHandling,
          disableDefaultUI,
        });

        mapRef.current = map;

        if (onMapClickRef.current) {
          clickListenerRef.current = map.addListener(
            "click",
            (e: google.maps.MapMouseEvent) => {
              if (e.latLng && onMapClickRef.current) {
                onMapClickRef.current(e.latLng.lat(), e.latLng.lng());
              }
            },
          );
        }

        setLoading(false);
        onReady?.(map);
      } catch (e) {
        logger.error("[GoogleMap] init error", { error: e });
        setError(
          "Failed to load Google Maps. Check API key, referrer restrictions, and billing status.",
        );
        setLoading(false);
      }
    };

    init();
    return () => {
      cancelled = true;
      infoRefs.current.forEach((iw) => iw.close());
      infoRefs.current = [];
      markerRefs.current.forEach((m) => {
        try {
          google.maps.event.clearInstanceListeners(m);
        } catch {
          /* noop */
        }
        m.setMap(null);
      });
      markerRefs.current = [];
      listenerRefs.current.forEach((l) => {
        try {
          google.maps.event.removeListener(l);
        } catch {
          /* noop */
        }
      });
      listenerRefs.current = [];
      if (clickListenerRef.current) {
        try {
          google.maps.event.removeListener(clickListenerRef.current);
        } catch {
          /* noop */
        }
        clickListenerRef.current = null;
      }
      mapRef.current = null;
    };
  }, []);

  useEffect(() => {
    if (mapRef.current) mapRef.current.setCenter(center);
  }, [center]);

  useEffect(() => {
    if (mapRef.current) mapRef.current.setZoom(zoom);
  }, [zoom]);

  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;

    infoRefs.current.forEach((iw) => iw.close());
    infoRefs.current = [];
    listenerRefs.current.forEach((l) => {
      try {
        google.maps.event.removeListener(l);
      } catch {
        /* noop */
      }
    });
    listenerRefs.current = [];
    markerRefs.current.forEach((m) => {
      try {
        google.maps.event.clearInstanceListeners(m);
      } catch {
        /* noop */
      }
      m.setMap(null);
    });
    markerRefs.current = [];

    if (!markers.length) return;

    const bounds = new google.maps.LatLngBounds();
    markers.forEach((m) => {
      const marker = new google.maps.Marker({
        position: m.position,
        map,
        title: m.title,
      });

      if (m.title || m.info) {
        const iw = new google.maps.InfoWindow({
          content: createInfoWindowContent(m.title, m.info),
        });
        const l = marker.addListener("click", () => iw.open(map, marker));
        infoRefs.current.push(iw);
        listenerRefs.current.push(l);
      }

      markerRefs.current.push(marker);
      bounds.extend(m.position as google.maps.LatLngLiteral);
    });

    if (fitToMarkers && markers.length > 1) {
      map.fitBounds(bounds, 40);
    } else if (fitToMarkers && markers.length === 1) {
      map.setCenter(markers[0].position);
    }
  }, [markers, fitToMarkers]);

  const wrapperStyle: React.CSSProperties = {
    height: typeof height === "number" ? `${height}px` : height,
  };

  if (error) {
    return (
      <div
        className="relative flex items-center justify-center bg-muted rounded-2xl border-2 border-border"
        style={wrapperStyle}
        data-testid="gmaps-error"
      >
        <div className="text-center p-6 max-w-md">
          <div className="mb-3">
            <svg
              className="w-12 h-12 text-muted-foreground mx-auto"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
          </div>
          <p className="text-foreground font-semibold mb-2">Map Unavailable</p>
          <p className="text-sm text-muted-foreground mb-3">{error}</p>
          <div className="bg-primary/5 border border-primary/20 rounded-2xl p-3">
            <p className="text-xs text-primary-foreground">
              <strong>For Developers:</strong> Set{" "}
              <code className="bg-primary/10 px-1 py-0.5 rounded">
                NEXT_PUBLIC_GOOGLE_MAPS_API_KEY
              </code>
              , restrict by HTTP referrer to your domains, and enable billing +
              Maps JavaScript API (and Places if used).
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="relative" style={wrapperStyle} data-testid="gmaps-wrapper">
      {loading && (
        <div
          className="absolute inset-0 flex items-center justify-center bg-muted rounded-2xl z-10"
          data-testid="gmaps-loading"
        >
          <div className="text-center">
            <Spinner className="w-8 h-8 animate-spin text-primary mx-auto mb-2" />
            <p className="text-sm text-muted-foreground">Loading map...</p>
          </div>
        </div>
      )}
      <div
        ref={containerRef}
        className="w-full h-full rounded-2xl"
        data-testid="gmaps-canvas"
      />
    </div>
  );
}

]]>
</file>

</batch_content>
