
You are the "Fixzit Memory Builder" for category: "routes".

You are given a batch of source files from the Fixzit codebase, wrapped in <file> tags
inside <batch_content>. Each <file> has a "path" attribute with the repository-relative
file path, and its contents are wrapped in CDATA.

YOUR TASK:
1. Read ALL files in <batch_content>.
2. For EACH file, extract architectural metadata using this schema:

[
  {
    "file": "repo-relative/path/to/file.ext",
    "category": "routes",
    "summary": "One-sentence technical summary of what this file does.",
    "exports": ["ExportedFunctionOrClassName", "..."],
    "dependencies": ["ImportedModuleOrPath", "..."]
  }
]

RULES:
- Return ONLY a valid JSON array.
- NO markdown, NO backticks, NO comments, NO extra text.
- Include an entry for every file in this batch.
- If a file has no exports, use "exports": [].
- If a file has no imports, use "dependencies": [].

<batch_content>

<file path="_artifacts/route-aliases.json">
<![CDATA[
{
  "generatedAt": "2025-12-09T07:57:33.534Z",
  "totals": {
    "aliasFiles": 2,
    "modules": 2,
    "reusedTargets": 0,
    "uniqueTargets": 2,
    "duplicateAliases": 0,
    "unresolvedAliases": 0
  },
  "modules": [
    {
      "module": "invoices",
      "aliases": 1,
      "missing": 0,
      "uniqueTargets": 1,
      "targets": [
        "app/fm/finance/invoices/page.tsx"
      ]
    },
    {
      "module": "reports",
      "aliases": 1,
      "missing": 0,
      "uniqueTargets": 1,
      "targets": [
        "app/fm/finance/reports/page.tsx"
      ]
    }
  ],
  "aliases": [
    {
      "module": "invoices",
      "aliasFile": "app/fm/invoices/page.tsx",
      "importTarget": "@/app/fm/finance/invoices/page",
      "resolvedPath": "app/fm/finance/invoices/page.tsx",
      "targetExists": true
    },
    {
      "module": "reports",
      "aliasFile": "app/fm/reports/page.tsx",
      "importTarget": "@/app/fm/finance/reports/page",
      "resolvedPath": "app/fm/finance/reports/page.tsx",
      "targetExists": true
    }
  ],
  "reuse": [],
  "insights": {
    "duplicateHistory": [],
    "averageResolutionDays": null,
    "routeHealth": []
  }
}
]]>
</file>

<file path="_artifacts/route-dup-history.json">
<![CDATA[
{}
]]>
</file>

<file path="app/admin/route-metrics/page.tsx">
<![CDATA[
"use client";

import { useState, useEffect, useMemo, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useAutoTranslator } from "@/i18n/useAutoTranslator";
import { toast } from "sonner";
import {
  BarChart,
  Activity,
  Target,
  AlertCircle,
  TrendingUp,
  RefreshCw,
  Loader2,
  Download,
} from "lucide-react";
import { logger } from "@/lib/logger";
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip as RechartsTooltip,
} from "recharts";
import type { TooltipProps } from "recharts";

type ModuleStat = {
  module: string;
  aliases: number;
  missing: number;
  uniqueTargets: number;
  targets: string[];
};

type ReuseEntry = {
  target: string;
  count: number;
  aliasFiles: string[];
  modules: string[];
};

type AliasRecord = {
  module: string;
  aliasFile: string;
  importTarget: string;
  resolvedPath: string | null;
  targetExists: boolean;
};

type DuplicateHistoryEntry = {
  target: string;
  firstSeen: string;
  lastSeen: string;
  resolvedAt: string | null;
  active: boolean;
};

type RouteHealthEntry = {
  target: string;
  pageViews: number;
  errorRate: number;
};

type RouteInsights = {
  duplicateHistory: DuplicateHistoryEntry[];
  averageResolutionDays: number | null;
  routeHealth: RouteHealthEntry[];
};

type RouteMetrics = {
  generatedAt: string;
  totals: {
    aliasFiles: number;
    modules: number;
    reusedTargets: number;
    uniqueTargets: number;
    duplicateAliases: number;
    unresolvedAliases: number;
  };
  modules: ModuleStat[];
  reuse: ReuseEntry[];
  aliases: AliasRecord[];
  insights?: RouteInsights;
};

const AUTO_REFRESH_MS = 5 * 60 * 1000;
const HISTORY_LIMIT = 20;
const HISTORY_GRADIENT_ID = "route-duplication-history";
const formatPercentLabel = (value: number | string) =>
  `${Number(value).toFixed(1)}%`;

type AliasState = {
  owner: string;
  resolved: boolean;
  updatedAt?: string;
};

type RouteHistoryChartDatum = {
  timestamp: string;
  label: string;
  fullLabel: string;
  rate: number;
};

type HistoryTooltipProps = TooltipProps<number, string> & {
  payload?: ReadonlyArray<{ payload?: RouteHistoryChartDatum }>;
};

export default function RouteMetricsPage() {
  const auto = useAutoTranslator("admin.routeMetrics");
  const [metrics, setMetrics] = useState<RouteMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const [moduleFilter, setModuleFilter] = useState<string>("all");
  const [aliasQuery, setAliasQuery] = useState("");
  const [lastViewedAt, setLastViewedAt] = useState<string | null>(null);
  const [duplicationTrend, setDuplicationTrend] = useState<{
    current: number | null;
    previous: number | null;
  }>({
    current: null,
    previous: null,
  });
  const [history, setHistory] = useState<
    Array<{ timestamp: string; rate: number }>
  >([]);
  const [aliasStates, setAliasStates] = useState<Record<string, AliasState>>(
    {},
  );
  const [workflowLoading, setWorkflowLoading] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") return;
    const stored = window.localStorage.getItem("routeMetricsLastRefresh");
    if (stored) {
      setLastViewedAt(stored);
    }
  }, []);

  const loadWorkflowStates = useCallback(async () => {
    setWorkflowLoading(true);
    try {
      const response = await fetch("/api/admin/route-aliases/workflow");
      if (!response.ok) throw new Error("Failed to load workflow state");
      const data = (await response.json()) as Record<string, AliasState>;
      setAliasStates(data);
    } catch {
      toast.error(
        auto("Failed to load workflow states", "aliases.workflow.loadError"),
      );
    } finally {
      setWorkflowLoading(false);
    }
  }, [auto, toast]);

  useEffect(() => {
    if (metrics) {
      void loadWorkflowStates();
    }
  }, [metrics, loadWorkflowStates]);

  const stageAliasState = useCallback(
    (aliasFile: string, updates: Partial<AliasState>) => {
      setAliasStates((prev) => {
        const base = prev[aliasFile] ?? { owner: "", resolved: false };
        return {
          ...prev,
          [aliasFile]: {
            ...base,
            ...updates,
          },
        };
      });
    },
    [],
  );

  const persistAliasState = useCallback(
    async (aliasFile: string) => {
      const current = aliasStates[aliasFile];
      if (!current) return;

      try {
        const response = await fetch("/api/admin/route-aliases/workflow", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            aliasFile,
            owner: current.owner,
            resolved: current.resolved,
          }),
        });

        if (!response.ok) throw new Error("Failed to persist workflow state");
        const saved = (await response.json()) as AliasState;
        setAliasStates((prev) => ({
          ...prev,
          [aliasFile]: saved,
        }));
      } catch (_error) {
        toast.error(
          auto("Failed to update workflow state", "aliases.workflow.error"),
        );
      }
    },
    [aliasStates, auto, toast],
  );

  const appendHistoryEntry = useCallback(
    (rate: number, generatedAt?: string) => {
      setHistory((prev) => {
        const timestamp = generatedAt ?? new Date().toISOString();
        const existingIndex = prev.findIndex(
          (entry) => entry.timestamp === timestamp,
        );
        let next = prev;
        if (existingIndex >= 0) {
          next = prev.map((entry, index) =>
            index === existingIndex ? { timestamp, rate } : entry,
          );
        } else {
          next = [...prev, { timestamp, rate }].slice(-HISTORY_LIMIT);
        }
        const last = next[next.length - 1] ?? null;
        const previous = next.length > 1 ? next[next.length - 2] : null;
        setDuplicationTrend({
          current: last?.rate ?? null,
          previous: previous?.rate ?? null,
        });
        return next;
      });
    },
    [],
  );

  const loadHistorySnapshots = useCallback(async () => {
    try {
      const response = await fetch("/api/admin/route-metrics?history=1");
      if (!response.ok) {
        throw new Error("Failed to load history");
      }
      const payload = await response.json();
      const normalized: Array<{ timestamp: string; rate: number }> =
        Array.isArray(payload.history)
          ? payload.history.map(
              (entry: { generatedAt: string; duplicateRate: number }) => ({
                timestamp: entry.generatedAt,
                rate: entry.duplicateRate ?? 0,
              }),
            )
          : [];
      setHistory(normalized);
      if (normalized.length > 0) {
        const last = normalized[normalized.length - 1];
        const previous =
          normalized.length > 1 ? normalized[normalized.length - 2] : null;
        setDuplicationTrend({
          current: last.rate,
          previous: previous?.rate ?? null,
        });
      } else {
        setDuplicationTrend({ current: null, previous: null });
      }
    } catch (err) {
      logger.error("[RouteMetrics] Failed to load history snapshots", err);
      toast.error(auto("Failed to load history", "history.error"));
    }
  }, [auto]);

  useEffect(() => {
    void loadHistorySnapshots();
  }, [loadHistorySnapshots]);

  const fetchMetrics = useCallback(
    async (
      forceRefresh = false,
      options?: { silent?: boolean; notify?: boolean },
    ) => {
      const silent = options?.silent ?? false;
      if (forceRefresh) {
        if (!silent) setRefreshing(true);
      } else if (!silent) {
        setLoading(true);
      }
      setError(null);
      try {
        const url = forceRefresh
          ? "/api/admin/route-metrics?refresh=1"
          : "/api/admin/route-metrics";
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to load metrics");
        const data = await response.json();
        setMetrics(data);
        if (typeof window !== "undefined") {
          const now = new Date().toISOString();
          window.localStorage.setItem("routeMetricsLastRefresh", now);
          setLastViewedAt(now);
        }
        const rate =
          data.totals.aliasFiles > 0
            ? (data.totals.duplicateAliases / data.totals.aliasFiles) * 100
            : 0;
        appendHistoryEntry(rate, data.generatedAt);
        if (options?.notify) {
          toast.success(
            auto("Metrics auto-refreshed", "notifications.autoRefreshed"),
          );
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
        if (options?.notify) {
          toast.error(
            auto("Auto-refresh failed", "notifications.autoRefreshError"),
          );
        }
      } finally {
        if (forceRefresh) {
          if (!silent) setRefreshing(false);
        } else if (!silent) {
          setLoading(false);
        }
      }
    },
    [auto, appendHistoryEntry],
  );

  useEffect(() => {
    const interval = setInterval(() => {
      void fetchMetrics(true, { silent: true, notify: true });
    }, AUTO_REFRESH_MS);
    return () => clearInterval(interval);
  }, [fetchMetrics]);

  useEffect(() => {
    void fetchMetrics();
  }, [fetchMetrics]);

  const aliasList = metrics?.aliases ?? [];
  const reuseEntries = metrics?.reuse ?? [];
  const modulesData = metrics?.modules ?? [];
  const insights = metrics?.insights;
  const duplicateHistory = insights?.duplicateHistory ?? [];
  const averageResolutionDays = insights?.averageResolutionDays ?? null;
  const routeHealth = insights?.routeHealth ?? [];

  const duplicationRateValue = metrics?.totals
    ? metrics.totals.aliasFiles > 0
      ? (metrics.totals.duplicateAliases / metrics.totals.aliasFiles) * 100
      : 0
    : 0;
  const duplicationRate = duplicationRateValue.toFixed(1);

  const topReused = useMemo(() => reuseEntries.slice(0, 10), [reuseEntries]);
  const duplicatedTargets = useMemo(
    () => new Set(reuseEntries.map((entry) => entry.target)),
    [reuseEntries],
  );

  const sortedAliases = useMemo(() => {
    return [...aliasList].sort((a, b) => {
      if (a.module === b.module) {
        return a.aliasFile.localeCompare(b.aliasFile);
      }
      return a.module.localeCompare(b.module);
    });
  }, [aliasList]);

  const moduleOptions = useMemo(
    () => modulesData.map((module) => module.module).sort(),
    [modulesData],
  );

  const filteredAliases = useMemo(() => {
    const normalized = aliasQuery.trim().toLowerCase();
    return sortedAliases.filter((alias) => {
      const matchesModule =
        moduleFilter === "all" || alias.module === moduleFilter;
      const matchesSearch =
        !normalized ||
        alias.aliasFile.toLowerCase().includes(normalized) ||
        (alias.resolvedPath?.toLowerCase().includes(normalized) ?? false) ||
        alias.importTarget.toLowerCase().includes(normalized);
      return matchesModule && matchesSearch;
    });
  }, [aliasQuery, moduleFilter, sortedAliases]);

  const duplicationDelta =
    duplicationTrend.previous !== null
      ? duplicationRateValue - duplicationTrend.previous
      : null;
  const trendMax =
    history.length > 0 ? Math.max(...history.map((entry) => entry.rate)) : 0;

  const routeHealthByTarget = useMemo(() => {
    const map = new Map<string, RouteHealthEntry>();
    for (const entry of routeHealth) {
      map.set(entry.target, entry);
    }
    return map;
  }, [routeHealth]);

  const historyChartData = useMemo<RouteHistoryChartDatum[]>(() => {
    return [...history]
      .sort(
        (a, b) =>
          new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime(),
      )
      .map((entry) => {
        const date = new Date(entry.timestamp);
        return {
          timestamp: entry.timestamp,
          label: date.toLocaleDateString(undefined, {
            month: "short",
            day: "numeric",
          }),
          fullLabel: date.toLocaleString(),
          rate: Number(entry.rate ?? 0),
        };
      });
  }, [history]);

  const renderHistoryTooltip = useCallback(
    (props: HistoryTooltipProps) => {
      if (!props.active || !props.payload?.length) {
        return null;
      }

      const datum = props.payload[0]?.payload as
        | RouteHistoryChartDatum
        | undefined;
      if (!datum) {
        return null;
      }

      return (
        <div className="rounded-lg border bg-background p-3 shadow-sm text-xs space-y-1">
          <div className="text-[0.70rem] uppercase text-muted-foreground">
            {auto("Generated at", "history.chart.tooltip.timestamp")}
          </div>
          <div className="font-semibold text-foreground">{datum.fullLabel}</div>
          <div className="text-[0.70rem] uppercase text-muted-foreground">
            {auto("Duplication rate", "history.chart.tooltip.rate")}
          </div>
          <div className="font-semibold">{formatPercentLabel(datum.rate)}</div>
        </div>
      );
    },
    [auto],
  );

  const highImpactDuplicates = useMemo(() => {
    return topReused
      .map((entry) => {
        const health = routeHealthByTarget.get(entry.target);
        const impact = health
          ? health.pageViews * (1 + health.errorRate * 10)
          : 0;
        return {
          target: entry.target,
          count: entry.count,
          pageViews: health?.pageViews ?? 0,
          errorRate: health?.errorRate ?? 0,
          impact,
        };
      })
      .filter((entry) => entry.pageViews > 0)
      .sort((a, b) => b.impact - a.impact)
      .slice(0, 5);
  }, [routeHealthByTarget, topReused]);

  const recentlyResolved = useMemo(() => {
    return duplicateHistory
      .filter((entry) => !entry.active && entry.resolvedAt)
      .sort(
        (a, b) =>
          new Date(b.resolvedAt ?? 0).getTime() -
          new Date(a.resolvedAt ?? 0).getTime(),
      )
      .slice(0, 3);
  }, [duplicateHistory]);

  const resolvedCount = aliasList.filter((alias) => alias.targetExists).length;
  const unresolvedCount = aliasList.length - resolvedCount;

  const topRiskModules = useMemo(() => {
    return modulesData
      .map((module) => ({
        ...module,
        duplicateAliases: module.aliases - module.uniqueTargets,
        riskScore:
          module.aliases > 0
            ? (module.aliases - module.uniqueTargets) / module.aliases
            : 0,
      }))
      .filter((module) => module.duplicateAliases > 0)
      .sort((a, b) => b.duplicateAliases - a.duplicateAliases)
      .slice(0, 3);
  }, [modulesData]);

  const remediationSuggestions = useMemo(() => {
    if (topRiskModules.length === 0) return [];
    return topRiskModules.map((module) => ({
      module: module.module,
      message: auto(
        "Create {{count}} dedicated pages to eliminate shared targets in {{module}}",
        "suggestions.createDedicatedPages",
        { count: module.duplicateAliases, module: module.module },
      ),
    }));
  }, [auto, topRiskModules]);

  const handleDownload = useCallback(() => {
    if (!metrics) return;
    const blob = new Blob([JSON.stringify(metrics, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `route-metrics-${new Date(metrics.generatedAt).toISOString()}.json`;
    link.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }, [metrics]);

  if (loading) {
    return (
      <div className="space-y-6">
        <h1 className="text-2xl font-bold">
          {auto("Route Metrics Dashboard", "header.title")}
        </h1>
        <div className="grid gap-4 md:grid-cols-4">
          {[1, 2, 3, 4].map((i) => (
            <Card key={i} className="animate-pulse">
              <CardContent className="p-6">
                <div className="h-4 bg-muted rounded w-3/4 mb-2" />
                <div className="h-8 bg-muted rounded w-1/2" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  if (error || !metrics) {
    return (
      <div className="space-y-6">
        <h1 className="text-2xl font-bold">
          {auto("Route Metrics Dashboard", "header.title")}
        </h1>
        <Card className="border-destructive">
          <CardContent className="p-6 text-center space-y-4">
            <AlertCircle className="w-12 h-12 mx-auto text-destructive" />
            <p className="text-destructive">
              {error || auto("Failed to load metrics", "error.load")}
            </p>
            <Button onClick={() => void fetchMetrics()}>
              {auto("Retry", "actions.retry")}
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between gap-4">
        <div>
          <div className="flex items-center gap-2">
            <BarChart className="w-6 h-6 text-primary" />
            <h1 className="text-2xl font-bold text-foreground">
              {auto("Route Metrics Dashboard", "header.title")}
            </h1>
          </div>
          <p className="text-muted-foreground">
            {auto(
              "Track route alias architecture and identify UX duplication",
              "header.subtitle",
            )}
          </p>
          {lastViewedAt && (
            <p className="text-xs text-muted-foreground">
              {auto("Last viewed {{time}} (local cache)", "meta.lastViewed", {
                time: new Date(lastViewedAt).toLocaleString(),
              })}
            </p>
          )}
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="secondary"
            onClick={handleDownload}
            disabled={!metrics}
          >
            <Download className="w-4 h-4 me-2" />
            {auto("Download JSON", "actions.download")}
          </Button>
          <Button
            onClick={() => void fetchMetrics(true)}
            variant="outline"
            disabled={refreshing}
          >
            {refreshing ? (
              <Loader2 className="w-4 h-4 me-2 animate-spin" />
            ) : (
              <RefreshCw className="w-4 h-4 me-2" />
            )}
            {refreshing
              ? auto("Refreshingâ€¦", "actions.refreshing")
              : auto("Refresh", "actions.refresh")}
          </Button>
        </div>
      </div>

      {/* Summary Cards */}
      <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-5">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {auto("Total Aliases", "cards.totalAliases")}
            </CardTitle>
            <Target className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.totals.aliasFiles}
            </div>
            <p className="text-xs text-muted-foreground">
              {auto("Across {{count}} modules", "cards.acrossModules", {
                count: metrics.totals.modules,
              })}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {auto("Unique Targets", "cards.uniqueTargets")}
            </CardTitle>
            <Target className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.totals.uniqueTargets}
            </div>
            <p className="text-xs text-muted-foreground">
              {auto("Dedicated implementations", "cards.dedicated")}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {auto("Reused Targets", "cards.reusedTargets")}
            </CardTitle>
            <Activity className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.totals.reusedTargets}
            </div>
            <p className="text-xs text-muted-foreground">
              {auto("Pages shared by multiple routes", "cards.sharedPages")}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {auto("Duplication Rate", "cards.duplicationRate")}
            </CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{duplicationRate}%</div>
            <p className="text-xs text-muted-foreground">
              {auto("Routes sharing implementations", "cards.routesSharing")}
              {duplicationDelta !== null && (
                <>
                  {" "}
                  <span
                    className={
                      duplicationDelta > 0
                        ? "text-destructive"
                        : "text-emerald-600"
                    }
                  >
                    {duplicationDelta > 0 ? "+" : ""}
                    {duplicationDelta.toFixed(1)}%
                  </span>
                  <span> {auto("vs last refresh", "cards.vsLast")}</span>
                </>
              )}
            </p>
            {history.length > 1 && trendMax > 0 && (
              <div className="mt-4">
                <div className="flex items-end gap-1 h-12">
                  {history.map((entry, index) => {
                    const normalized = entry.rate / trendMax;
                    return (
                      <div
                        key={`${entry.timestamp}-${index}`}
                        className="flex-1 rounded-t bg-primary/70"
                        style={{ height: `${Math.max(normalized * 100, 5)}%` }}
                        title={`${entry.rate.toFixed(1)}%`}
                      />
                    );
                  })}
                </div>
                <p className="text-xs text-muted-foreground mt-1">
                  {auto("History of duplication refreshes", "cards.trendHelp")}
                </p>
              </div>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {auto("Last Updated", "cards.lastUpdated")}
            </CardTitle>
            <RefreshCw className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-sm font-bold">
              {new Date(metrics.generatedAt).toLocaleString()}
            </div>
            <p className="text-xs text-muted-foreground">
              {auto("Metrics timestamp", "cards.timestamp")}
            </p>
          </CardContent>
        </Card>
      </div>

      <Card className="border border-border/60 shadow-sm">
        <CardHeader>
          <CardTitle>
            {auto("Historical Duplicate Rate", "history.chart.title")}
          </CardTitle>
          <p className="text-sm text-muted-foreground">
            {auto(
              "Snapshots captured from route metrics history archives",
              "history.chart.subtitle",
            )}
          </p>
        </CardHeader>
        <CardContent>
          {historyChartData.length === 0 ? (
            <div className="h-40 flex items-center justify-center px-6 text-center text-sm text-muted-foreground">
              {auto(
                "Snapshots populate automatically when you run npm run check:route-aliases. Rerun after major refactors to capture new data.",
                "history.chart.empty",
              )}
            </div>
          ) : (
            <div className="h-80">
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart
                  data={historyChartData}
                  margin={{ left: 0, right: 0, top: 10, bottom: 0 }}
                >
                  <defs>
                    <linearGradient
                      id={HISTORY_GRADIENT_ID}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop
                        offset="5%"
                        stopColor="hsl(var(--primary))"
                        stopOpacity={0.45}
                      />
                      <stop
                        offset="95%"
                        stopColor="hsl(var(--primary))"
                        stopOpacity={0}
                      />
                    </linearGradient>
                  </defs>
                  <CartesianGrid
                    strokeDasharray="3 3"
                    className="stroke-muted"
                  />
                  <XAxis
                    dataKey="label"
                    className="text-xs"
                    tick={{ fontSize: 12 }}
                    minTickGap={12}
                  />
                  <YAxis
                    className="text-xs"
                    tick={{ fontSize: 12 }}
                    tickFormatter={formatPercentLabel}
                    width={48}
                    domain={[0, "auto"]}
                  />
                  <RechartsTooltip content={renderHistoryTooltip} />
                  <Area
                    type="monotone"
                    dataKey="rate"
                    stroke="hsl(var(--primary))"
                    strokeWidth={2}
                    fill={`url(#${HISTORY_GRADIENT_ID})`}
                    dot={{ r: 3 }}
                    activeDot={{ r: 5 }}
                  />
                </AreaChart>
              </ResponsiveContainer>
              <p className="text-xs text-muted-foreground mt-2">
                {auto(
                  "Data source: reports/route-metrics/history/*.json",
                  "history.chart.caption",
                )}
              </p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Advanced Analytics */}
      <div className="grid gap-4 md:grid-cols-3">
        <Card>
          <CardHeader>
            <CardTitle>
              {auto("Alias Resolution", "analytics.resolutionTitle")}
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              {auto(
                "Resolved vs unresolved alias files",
                "analytics.resolutionSubtitle",
              )}
            </p>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-6">
              <div>
                <p className="text-xs uppercase text-muted-foreground">
                  {auto("Resolved", "analytics.resolved")}
                </p>
                <p className="text-2xl font-bold">{resolvedCount}</p>
              </div>
              <div>
                <p className="text-xs uppercase text-muted-foreground">
                  {auto("Unresolved", "analytics.unresolved")}
                </p>
                <p className="text-2xl font-bold text-destructive">
                  {unresolvedCount}
                </p>
              </div>
            </div>
            <div className="mt-4 h-2 rounded-full bg-muted">
              <div
                className="h-full rounded-full bg-primary transition-all"
                style={{
                  width: `${
                    resolvedCount === 0 && unresolvedCount === 0
                      ? 0
                      : (resolvedCount / (resolvedCount + unresolvedCount)) *
                        100
                  }%`,
                }}
              />
            </div>
          </CardContent>
        </Card>
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle>
              {auto("Highest Risk Modules", "analytics.riskTitle")}
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              {auto(
                "Modules still sharing implementations",
                "analytics.riskSubtitle",
              )}
            </p>
          </CardHeader>
          <CardContent className="space-y-3">
            {topRiskModules.length === 0 ? (
              <p className="text-sm text-muted-foreground">
                {auto("No duplication remaining ðŸŽ‰", "analytics.noRisk")}
              </p>
            ) : (
              topRiskModules.map((module) => (
                <div
                  key={module.module}
                  className="flex items-center justify-between rounded-lg border border-border p-3"
                >
                  <div>
                    <p className="font-semibold capitalize">{module.module}</p>
                    <p className="text-xs text-muted-foreground">
                      {auto(
                        "{{duplicates}} shared aliases",
                        "analytics.duplicates",
                        {
                          duplicates: module.duplicateAliases,
                        },
                      )}
                    </p>
                  </div>
                  <Badge
                    variant="outline"
                    className="text-orange-600 border-orange-600"
                  >
                    {Math.round(module.riskScore * 100)}%{" "}
                    {auto("risk", "analytics.riskLabel")}
                  </Badge>
                </div>
              ))
            )}
          </CardContent>
        </Card>
      </div>

      {averageResolutionDays !== null && (
        <Card>
          <CardHeader>
            <CardTitle>
              {auto("Resolution Velocity", "analytics.resolutionVelocity")}
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              {auto(
                "Average time to retire duplicated routes",
                "analytics.resolutionVelocitySubtitle",
              )}
            </p>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="text-3xl font-bold">
              {averageResolutionDays} {auto("days", "analytics.daysLabel")}
            </div>
            {recentlyResolved.length > 0 && (
              <div className="space-y-2">
                <p className="text-xs uppercase text-muted-foreground">
                  {auto("Recently resolved", "analytics.recentlyResolved")}
                </p>
                {recentlyResolved.map((entry) => (
                  <div
                    key={entry.target}
                    className="flex items-center justify-between text-sm"
                  >
                    <code className="text-xs bg-muted px-2 py-1 rounded border border-border/60">
                      {entry.target}
                    </code>
                    <span className="text-muted-foreground">
                      {new Date(entry.resolvedAt ?? "").toLocaleDateString()}
                    </span>
                  </div>
                ))}
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {highImpactDuplicates.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>
              {auto("High-Impact Duplicates", "analytics.highImpactTitle")}
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              {auto(
                "Prioritize routes with real traffic or error volume",
                "analytics.highImpactSubtitle",
              )}
            </p>
          </CardHeader>
          <CardContent className="space-y-3">
            {highImpactDuplicates.map((entry) => (
              <div
                key={entry.target}
                className="flex flex-wrap items-center justify-between rounded-lg border border-border/70 p-3"
              >
                <div>
                  <code className="text-xs bg-muted px-2 py-1 rounded border border-border/60">
                    {entry.target}
                  </code>
                  <p className="text-xs text-muted-foreground">
                    {auto(
                      "{{count}} aliases Â· {{views}} views",
                      "analytics.highImpactMeta",
                      {
                        count: entry.count,
                        views: entry.pageViews,
                      },
                    )}
                  </p>
                </div>
                <div className="text-end">
                  <p className="text-sm font-semibold">
                    {auto("Error rate", "analytics.errorRate")}:{" "}
                    {(entry.errorRate * 100).toFixed(2)}%
                  </p>
                </div>
              </div>
            ))}
          </CardContent>
        </Card>
      )}

      {metrics.totals.unresolvedAliases > 0 && (
        <Card className="border-destructive/30 bg-destructive/5">
          <CardContent className="p-4 flex flex-col gap-2">
            <div className="flex items-center gap-2 text-destructive">
              <AlertCircle className="w-4 h-4" />
              <p className="text-sm font-semibold">
                {auto(
                  "Some aliases do not resolve to targets",
                  "alerts.unresolvedTitle",
                )}
              </p>
            </div>
            <p className="text-sm text-muted-foreground">
              {auto(
                "{{count}} aliases are unresolved â€” regenerate the metrics and fix the pages",
                "alerts.unresolvedBody",
                {
                  count: metrics.totals.unresolvedAliases,
                },
              )}
            </p>
          </CardContent>
        </Card>
      )}

      {/* Top Reused Targets */}
      <Card>
        <CardHeader>
          <CardTitle>{auto("Most Reused Targets", "reused.title")}</CardTitle>
          <p className="text-sm text-muted-foreground">
            {auto(
              "Pages serving multiple routes (UX debt candidates)",
              "reused.subtitle",
            )}
          </p>
        </CardHeader>
        <CardContent>
          {topReused.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              {auto(
                "No reused targets found - all routes are dedicated!",
                "reused.empty",
              )}
            </div>
          ) : (
            <div className="space-y-3">
              {topReused.map((entry, index) => (
                <div
                  key={entry.target}
                  className="p-3 rounded-lg border border-border hover:bg-muted/50 transition-colors space-y-3"
                >
                  <div className="flex items-center justify-between gap-3">
                    <div className="flex items-center gap-3">
                      <Badge
                        variant={entry.count > 3 ? "destructive" : "secondary"}
                      >
                        #{index + 1}
                      </Badge>
                      <div>
                        <code className="text-sm font-mono">
                          {entry.target}
                        </code>
                        <p className="text-xs text-muted-foreground mt-1">
                          {auto(
                            "Serving {{count}} different routes",
                            "reused.servingCount",
                            {
                              count: entry.count,
                            },
                          )}
                        </p>
                      </div>
                    </div>
                    <Badge
                      variant={entry.count > 3 ? "destructive" : "default"}
                    >
                      {entry.count}Ã— {auto("reused", "reused.label")}
                    </Badge>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    {entry.modules.map((module) => (
                      <Badge
                        key={`${entry.target}-${module}`}
                        variant="outline"
                        className="uppercase tracking-wide"
                      >
                        {module}
                      </Badge>
                    ))}
                  </div>
                  <div>
                    <p className="text-xs font-semibold text-muted-foreground uppercase tracking-wide mb-2">
                      {auto("Alias Files", "reused.aliasFiles")}
                    </p>
                    <div className="flex flex-wrap gap-2">
                      {entry.aliasFiles.map((alias) => (
                        <code
                          key={`${entry.target}-${alias}`}
                          className="text-xs bg-muted px-2 py-1 rounded border border-border/70"
                        >
                          {alias}
                        </code>
                      ))}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Alias Inventory */}
      <Card>
        <CardHeader>
          <CardTitle>{auto("Alias Inventory", "aliases.title")}</CardTitle>
          <p className="text-sm text-muted-foreground">
            {auto(
              "Full list of /fm aliases and their resolved targets",
              "aliases.subtitle",
            )}
          </p>
          <p className="text-xs text-muted-foreground">
            {auto(
              "Owner & resolution states sync across admins automatically",
              "aliases.localStateHint",
            )}
          </p>
          {workflowLoading && (
            <p className="text-xs text-muted-foreground">
              {auto("Syncing workflow statesâ€¦", "aliases.workflow.loading")}
            </p>
          )}
        </CardHeader>
        <CardContent className="overflow-x-auto space-y-4">
          <div className="flex flex-wrap gap-3 items-center">
            <Select value={moduleFilter} onValueChange={setModuleFilter}>
              <SelectTrigger className="w-48">
                <SelectValue
                  placeholder={auto(
                    "Filter by module",
                    "aliases.filter.placeholder",
                  )}
                >
                  {moduleFilter === "all"
                    ? auto("All modules", "aliases.filter.all")
                    : moduleFilter}
                </SelectValue>
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">
                  {auto("All modules", "aliases.filter.all")}
                </SelectItem>
                {moduleOptions.map((module) => (
                  <SelectItem key={module} value={module}>
                    {module}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Input
              value={aliasQuery}
              onChange={(event) => setAliasQuery(event.target.value)}
              placeholder={auto(
                "Search alias or targetâ€¦",
                "aliases.search.placeholder",
              )}
              className="w-64"
            />
            <span className="text-xs text-muted-foreground">
              {auto("{{count}} aliases shown", "aliases.count", {
                count: filteredAliases.length,
              })}
            </span>
          </div>
          {sortedAliases.length === 0 ? (
            <p className="text-sm text-muted-foreground">
              {auto(
                "No alias files detected under app/fm â€” awesome!",
                "aliases.empty",
              )}
            </p>
          ) : (
            <table className="w-full text-sm">
              <thead>
                <tr className="text-xs uppercase tracking-wide text-muted-foreground">
                  <th className="px-2 py-1">
                    {auto("Module", "aliases.headers.module")}
                  </th>
                  <th className="px-2 py-1">
                    {auto("Alias File", "aliases.headers.alias")}
                  </th>
                  <th className="px-2 py-1">
                    {auto("Resolved Target", "aliases.headers.target")}
                  </th>
                  <th className="px-2 py-1">
                    {auto("Status", "aliases.headers.status")}
                  </th>
                  <th className="px-2 py-1">
                    {auto("Owner", "aliases.headers.owner")}
                  </th>
                  <th className="px-2 py-1">
                    {auto("Workflow", "aliases.headers.workflow")}
                  </th>
                </tr>
              </thead>
              <tbody>
                {filteredAliases.map((alias) => {
                  const isShared =
                    alias.resolvedPath &&
                    duplicatedTargets.has(alias.resolvedPath);
                  const aliasState = aliasStates[alias.aliasFile];
                  return (
                    <tr
                      key={alias.aliasFile}
                      className="border-t border-border/60"
                    >
                      <td className="px-2 py-2 font-medium capitalize">
                        {alias.module}
                      </td>
                      <td className="px-2 py-2">
                        <code className="text-xs bg-muted px-2 py-1 rounded border border-border/70">
                          {alias.aliasFile}
                        </code>
                      </td>
                      <td className="px-2 py-2">
                        {alias.resolvedPath ? (
                          <code className="text-xs text-muted-foreground">
                            {alias.resolvedPath}
                          </code>
                        ) : (
                          <span className="text-xs text-destructive">
                            {auto("Missing target", "aliases.targetMissing")}
                          </span>
                        )}
                      </td>
                      <td className="px-2 py-2">
                        <div className="flex flex-wrap gap-2">
                          <Badge
                            variant={
                              alias.targetExists ? "secondary" : "destructive"
                            }
                          >
                            {alias.targetExists
                              ? auto("Resolved", "aliases.status.resolved")
                              : auto("Missing", "aliases.status.missing")}
                          </Badge>
                          {isShared && (
                            <Badge
                              variant="outline"
                              className="text-orange-600 border-orange-600"
                            >
                              {auto("Shared target", "aliases.status.shared")}
                            </Badge>
                          )}
                        </div>
                      </td>
                      <td className="px-2 py-2">
                        <Input
                          value={aliasState?.owner ?? ""}
                          onChange={(event) =>
                            stageAliasState(alias.aliasFile, {
                              owner: event.target.value,
                            })
                          }
                          onBlur={() => void persistAliasState(alias.aliasFile)}
                          placeholder={auto(
                            "Assign ownerâ€¦",
                            "aliases.owner.placeholder",
                          )}
                        />
                      </td>
                      <td className="px-2 py-2">
                        <Button
                          size="sm"
                          variant={
                            aliasState?.resolved ? "secondary" : "outline"
                          }
                          onClick={() => {
                            stageAliasState(alias.aliasFile, {
                              resolved: !aliasState?.resolved,
                            });
                            void persistAliasState(alias.aliasFile);
                          }}
                        >
                          {aliasState?.resolved
                            ? auto("Resolved", "aliases.workflow.resolved")
                            : auto("Mark Resolved", "aliases.workflow.mark")}
                        </Button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          )}
        </CardContent>
      </Card>

      {/* Remediation Suggestions */}
      {remediationSuggestions.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>
              {auto("Remediation Suggestions", "suggestions.title")}
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              {auto(
                "Next steps to eliminate shared routes",
                "suggestions.subtitle",
              )}
            </p>
          </CardHeader>
          <CardContent className="space-y-3">
            {remediationSuggestions.map((suggestion) => (
              <div
                key={suggestion.module}
                className="flex items-center justify-between rounded-lg border border-border/60 p-3"
              >
                <div>
                  <p className="font-semibold capitalize">
                    {suggestion.module}
                  </p>
                  <p className="text-sm text-muted-foreground">
                    {suggestion.message}
                  </p>
                </div>
                <Badge variant="secondary">
                  {auto("Action", "suggestions.actionLabel")}
                </Badge>
              </div>
            ))}
          </CardContent>
        </Card>
      )}

      {/* Module Breakdown */}
      <Card>
        <CardHeader>
          <CardTitle>{auto("Module Breakdown", "modules.title")}</CardTitle>
          <p className="text-sm text-muted-foreground">
            {auto("Route counts by module", "modules.subtitle")}
          </p>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {metrics.modules.map((module) => {
              const duplicationRatio =
                module.aliases > 0
                  ? ((module.uniqueTargets / module.aliases) * 100).toFixed(0)
                  : "0";
              const hasDuplication = module.aliases > module.uniqueTargets;
              const uniquePercent =
                module.aliases > 0
                  ? Math.round((module.uniqueTargets / module.aliases) * 100)
                  : 0;

              return (
                <div
                  key={module.module}
                  className="flex items-center justify-between p-3 rounded-lg border border-border"
                >
                  <div className="space-y-1">
                    <div className="flex items-center gap-2">
                      <span className="font-semibold capitalize">
                        {module.module}
                      </span>
                      {hasDuplication && (
                        <Badge
                          variant="outline"
                          className="text-orange-600 border-orange-600"
                        >
                          {auto("Has Duplication", "modules.hasDuplication")}
                        </Badge>
                      )}
                    </div>
                    <p className="text-sm text-muted-foreground">
                      {auto(
                        "{{aliases}} aliases â†’ {{targets}} unique targets",
                        "modules.stats",
                        {
                          aliases: module.aliases,
                          targets: module.uniqueTargets,
                        },
                      )}
                    </p>
                    {module.missing > 0 && (
                      <p className="text-xs text-destructive">
                        {auto(
                          "{{count}} aliases missing targets",
                          "modules.missing",
                          {
                            count: module.missing,
                          },
                        )}
                      </p>
                    )}
                    <div className="mt-2">
                      <div className="h-2 rounded-full bg-muted">
                        <div
                          className="h-full rounded-full bg-primary transition-all"
                          style={{ width: `${uniquePercent}%` }}
                        />
                      </div>
                      <p className="text-xs text-muted-foreground mt-1">
                        {auto(
                          "{{percent}}% dedicated coverage",
                          "modules.progress",
                          {
                            percent: uniquePercent,
                          },
                        )}
                      </p>
                    </div>
                  </div>
                  <div className="text-end">
                    <div className="text-2xl font-bold">
                      {duplicationRatio}%
                    </div>
                    <p className="text-xs text-muted-foreground">
                      {auto("unique", "modules.unique")}
                    </p>
                  </div>
                </div>
              );
            })}
          </div>
        </CardContent>
      </Card>

      {/* Info Card */}
      <Card className="border-dashed">
        <CardContent className="p-6">
          <p className="text-sm text-muted-foreground">
            {auto(
              "Metrics generated on-demand (npm run check:route-aliases:json or Refresh)",
              "info.command",
            )}
          </p>
          <p className="text-sm text-muted-foreground mt-2">
            {auto(
              "Data source: _artifacts/route-aliases.json",
              "info.dataSource",
            )}
          </p>
        </CardContent>
      </Card>
    </div>
  );
}

]]>
</file>

<file path="app/api/admin/audit/export/route.ts">
<![CDATA[
/**
 * Audit Log Export API Route
 *
 * Streams audit logs as CSV to prevent memory exhaustion.
 * Supports date range filtering.
 *
 * Memory-safe implementation:
 * - Uses Node.js streams to process large datasets
 * - Chunks data in batches of 100 records
 * - No in-memory accumulation of all records
 */

import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import { connectToDatabase } from "@/lib/mongodb-unified";
import { AuditLogModel } from "@/server/models/AuditLog";
import { logger } from "@/lib/logger";

// Helper to escape CSV fields
function escapeCsvField(value: unknown): string {
  if (value === null || value === undefined) return "";
  const str = String(value);
  // Escape quotes and wrap in quotes if contains comma, quote, or newline
  if (str.includes(",") || str.includes('"') || str.includes("\n")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

// Convert audit log to CSV row
function auditToCsvRow(log: {
  _id: unknown;
  orgId: string;
  userId: string;
  userName?: string | null;
  userEmail?: string | null;
  action: string;
  entityType: string;
  entityId?: string | null;
  entityName?: string | null;
  timestamp: Date;
  context?: {
    ipAddress?: string | null;
    userAgent?: string | null;
    endpoint?: string | null;
    method?: string | null;
  } | null;
  result?: {
    success?: boolean | null;
    errorMessage?: string | null;
  } | null;
  metadata?: unknown;
}): string {
  return [
    escapeCsvField(log.timestamp.toISOString()),
    escapeCsvField(log.userEmail || log.userName || log.userId),
    escapeCsvField(log.userId),
    escapeCsvField(log.action),
    escapeCsvField(log.entityType),
    escapeCsvField(log.entityId),
    escapeCsvField(log.entityName),
    escapeCsvField(log.result?.success === false ? "FAILURE" : "SUCCESS"),
    escapeCsvField(log.context?.ipAddress),
    escapeCsvField(log.context?.userAgent),
    escapeCsvField(log.context?.endpoint),
    escapeCsvField(log.context?.method),
    escapeCsvField(log.result?.errorMessage),
    escapeCsvField(log.metadata ? JSON.stringify(log.metadata) : ""),
  ].join(",");
}

export async function GET(request: NextRequest) {
  try {
    // Check authentication
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check permissions (Super Admin or audit export permission)
    const isSuperAdmin = session.user.isSuperAdmin || false;
    const permissions = (session.user.permissions as string[]) || [];
    const canExport =
      isSuperAdmin ||
      permissions.includes("system:audit.export") ||
      permissions.includes("*");

    if (!canExport) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Parse query parameters
    const { searchParams } = new URL(request.url);
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const format = searchParams.get("format") || "csv";

    // Only CSV is supported for now
    if (format !== "csv") {
      return NextResponse.json(
        { error: "Only CSV format is supported" },
        { status: 400 },
      );
    }

    // Connect to database
    await connectToDatabase();

    // Build query
    const query: { timestamp?: { $gte?: Date; $lte?: Date } } = {};
    if (startDate || endDate) {
      query.timestamp = {};
      if (startDate) query.timestamp.$gte = new Date(startDate);
      if (endDate) query.timestamp.$lte = new Date(endDate);
    }

    // CSV header
    const csvHeader =
      [
        "Timestamp",
        "User Email",
        "User ID",
        "Action",
        "Entity Type",
        "Entity ID",
        "Entity Name",
        "Status",
        "IP Address",
        "User Agent",
        "Endpoint",
        "Method",
        "Error Message",
        "Metadata",
      ].join(",") + "\n";

    // Create streaming response
    const stream = new ReadableStream({
      async start(controller) {
        try {
          // Send CSV header
          controller.enqueue(new TextEncoder().encode(csvHeader));

          // Stream data in batches
          const BATCH_SIZE = 100;
          let skip = 0;
          let hasMore = true;

          while (hasMore) {
            // Fetch batch
            const logs = await AuditLogModel.find(query)
              .sort({ timestamp: -1 })
              .skip(skip)
              .limit(BATCH_SIZE)
              .lean()
              .exec();

            if (logs.length === 0) {
              hasMore = false;
              break;
            }

            // Convert batch to CSV rows
            const csvRows =
              logs
                .map((log: Parameters<typeof auditToCsvRow>[0]) =>
                  auditToCsvRow(log),
                )
                .join("\n") + "\n";
            controller.enqueue(new TextEncoder().encode(csvRows));

            skip += BATCH_SIZE;

            // Check if we've reached the end
            if (logs.length < BATCH_SIZE) {
              hasMore = false;
            }
          }

          // Close stream
          controller.close();
        } catch (error) {
          logger.error("[AuditExport] Stream error", error as Error);
          controller.error(error);
        }
      },
    });

    // Return streaming response
    const filename = `audit-logs-${new Date().toISOString().split("T")[0]}.csv`;
    return new NextResponse(stream, {
      headers: {
        "Content-Type": "text/csv; charset=utf-8",
        "Content-Disposition": `attachment; filename="${filename}"`,
        "Cache-Control": "no-cache",
      },
    });
  } catch (error) {
    logger.error("[AuditExport] Error", error as Error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/admin/audit-logs/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";

// Prevent prerendering/export of this API route (requires auth + database)
export const dynamic = "force-dynamic";
import { auth } from "@/auth";
import { AuditLogModel } from "@/server/models/AuditLog";
import { connectDb } from "@/lib/mongo";

import { logger } from "@/lib/logger";
import { smartRateLimit, buildOrgAwareRateLimitKey } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
/**
 * GET /api/admin/audit-logs
 *
 * Fetch audit logs with filters (Super Admin only)
 */
export async function GET(request: NextRequest) {
  try {
    const session = await auth();

    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check if user is Super Admin
    if (session.user.role !== "SUPER_ADMIN") {
      return NextResponse.json(
        { error: "Forbidden - Super Admin access required" },
        { status: 403 },
      );
    }

    await connectDb();

    // Get query parameters
    const { searchParams } = request.nextUrl;
    const userId = searchParams.get("userId");
    const entityType = searchParams.get("entityType");
    const action = searchParams.get("action");
    const startDateStr = searchParams.get("startDate");
    const endDateStr = searchParams.get("endDate");

    // Parse and validate pagination with safe defaults and caps
    let limit = parseInt(searchParams.get("limit") || "100", 10);
    let skip = parseInt(searchParams.get("skip") || "0", 10);

    // Validate and cap pagination values to prevent DoS
    if (!Number.isInteger(limit) || limit < 1) {
      limit = 100;
    }
    if (!Number.isInteger(skip) || skip < 0) {
      skip = 0;
    }
    // Cap limit at 1000 and skip at 100000 for safety
    limit = Math.min(limit, 1000);
    skip = Math.min(skip, 100000);

    // Validate and parse date parameters
    let startDate: Date | undefined;
    let endDate: Date | undefined;

    if (startDateStr) {
      const parsed = new Date(startDateStr);
      if (isNaN(parsed.getTime())) {
        return NextResponse.json(
          { error: "Invalid startDate parameter" },
          { status: 400 },
        );
      }
      startDate = parsed;
    }

    if (endDateStr) {
      const parsed = new Date(endDateStr);
      if (isNaN(parsed.getTime())) {
        return NextResponse.json(
          { error: "Invalid endDate parameter" },
          { status: 400 },
        );
      }
      endDate = parsed;
    }

    // SEC-001: Validate orgId exists for tenant isolation
    const orgId = session.user.orgId;
    if (!orgId || typeof orgId !== 'string' || orgId.trim() === '') {
      return NextResponse.json(
        { error: "Unauthorized: Invalid organization context" },
        { status: 403 }
      );
    }

    // Rate limiting (org-aware) to prevent abuse
    const rlKey = buildOrgAwareRateLimitKey(request, orgId, session.user.id ?? null);
    const rl = await smartRateLimit(rlKey, 60, 60_000);
    if (!rl.allowed) {
      return rateLimitError();
    }

    // Search logs
    const logs = await AuditLogModel.search({
      orgId,  // âœ… Validated orgId
      userId: userId || undefined,
      entityType: entityType || undefined,
      action: action || undefined,
      startDate,
      endDate,
      limit,
      skip,
    });

    return NextResponse.json({ logs });
  } catch (error) {
    logger.error("Failed to fetch audit logs:", error);
    return NextResponse.json(
      { error: "Failed to fetch audit logs" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/admin/billing/annual-discount/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { dbConnect } from "@/db/mongoose";
import DiscountRule from "@/server/models/DiscountRule";
import { requireSuperAdmin } from "@/lib/authz";

/**
 * @openapi
 * /api/admin/billing/annual-discount:
 *   patch:
 *     summary: Update annual prepayment discount
 *     description: Updates the discount percentage for annual prepayment. Super admin only.
 *     tags:
 *       - Admin
 *       - Billing
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               percentage:
 *                 type: number
 *                 example: 15
 *     responses:
 *       200:
 *         description: Discount updated successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Super admin only
 */
export async function PATCH(req: NextRequest) {
  await dbConnect();
  await requireSuperAdmin(req);
  const { percentage } = await req.json();

  const doc = await DiscountRule.findOneAndUpdate(
    { key: "ANNUAL_PREPAY" },
    { percentage },
    { upsert: true, new: true },
  );

  return NextResponse.json({ ok: true, discount: doc?.percentage });
}

]]>
</file>

<file path="app/api/admin/billing/benchmark/[id]/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { dbConnect } from "@/db/mongoose";
import Benchmark from "@/server/models/Benchmark";
import { requireSuperAdmin } from "@/lib/authz";

import { createSecureResponse } from "@/server/security/headers";

/**
 * @openapi
 * /api/admin/billing/benchmark/{id}:
 *   patch:
 *     summary: Update billing benchmark
 *     description: Updates a billing benchmark by ID. Super admin only.
 *     tags:
 *       - Admin
 *       - Billing
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Benchmark updated successfully
 *       404:
 *         description: Benchmark not found
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } },
) {
  await dbConnect();
  await requireSuperAdmin(req);
  const body = await req.json();

  // AUDIT-2025-12-08: Whitelist allowed fields to prevent mass assignment
  const allowedFields = ['name', 'description', 'category', 'value', 'unit', 'metadata', 'isActive'];
  const sanitizedBody: Record<string, unknown> = {};
  for (const key of allowedFields) {
    if (body[key] !== undefined) {
      sanitizedBody[key] = body[key];
    }
  }

  const doc = await Benchmark.findByIdAndUpdate(params.id, sanitizedBody, { new: true });
  if (!doc) {
    return createSecureResponse({ error: "NOT_FOUND" }, 404, req);
  }

  return createSecureResponse(doc, 200, req);
}

]]>
</file>

<file path="app/api/admin/billing/benchmark/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { connectToDatabase } from "@/lib/mongodb-unified";
import Benchmark from "@/server/models/Benchmark";
import { requireSuperAdmin } from "@/lib/authz";

import { smartRateLimit, buildOrgAwareRateLimitKey } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
import { createSecureResponse } from "@/server/security/headers";

/**
 * @openapi
 * /api/admin/billing/benchmark:
 *   get:
 *     summary: admin/billing/benchmark operations
 *     tags: [admin]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function GET(req: NextRequest) {
  // AuthZ + tenancy
  let authContext: { id: string; tenantId: string } | null = null;
  try {
    authContext = await requireSuperAdmin(req);
  } catch (error) {
    if (error instanceof Response) return error;
    return createSecureResponse({ error: "Authentication failed" }, 401, req);
  }

  const orgId = authContext?.tenantId?.trim();
  if (!orgId) {
    return createSecureResponse({ error: "Missing organization context" }, 400, req);
  }

  // Rate limiting (org + user aware)
  const key = buildOrgAwareRateLimitKey(req, orgId, authContext.id);
  const rl = await smartRateLimit(key, 100, 60_000);
  if (!rl.allowed) {
    return rateLimitError();
  }

  await connectToDatabase();
  // Scope benchmarks to tenant to avoid cross-tenant leakage
  const docs = await Benchmark.find({ tenantId: orgId }).lean();
  return createSecureResponse(docs, 200, req);
}

]]>
</file>

<file path="app/api/admin/billing/pricebooks/[id]/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { dbConnect } from "@/db/mongoose";
import PriceBook from "@/server/models/PriceBook";
import { requireSuperAdmin } from "@/lib/authz";

import { createSecureResponse } from "@/server/security/headers";

/**
 * @openapi
 * /api/admin/billing/pricebooks/{id}:
 *   patch:
 *     summary: Update pricebook
 *     description: Updates a pricebook configuration. Requires super admin access.
 *     tags:
 *       - Admin
 *       - Billing
 *     security:
 *       - cookieAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *     responses:
 *       200:
 *         description: Pricebook updated successfully
 *       404:
 *         description: Pricebook not found
 *       403:
 *         description: Forbidden - Super admin only
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } },
) {
  await dbConnect();
  await requireSuperAdmin(req);
  const body = await req.json();

  // AUDIT-2025-12-08: Whitelist allowed fields to prevent mass assignment
  const allowedFields = ['name', 'description', 'prices', 'currency', 'effectiveDate', 'expiryDate', 'isActive', 'metadata'];
  const sanitizedBody: Record<string, unknown> = {};
  for (const key of allowedFields) {
    if (body[key] !== undefined) {
      sanitizedBody[key] = body[key];
    }
  }

  const doc = await PriceBook.findByIdAndUpdate(params.id, sanitizedBody, { new: true });
  if (!doc) {
    return createSecureResponse({ error: "NOT_FOUND" }, 404, req);
  }

  return createSecureResponse(doc, 200, req);
}

]]>
</file>

<file path="app/api/admin/billing/pricebooks/route.ts">
<![CDATA[
import { NextRequest } from "next/server";
import { dbConnect } from "@/db/mongoose";
import PriceBook from "@/server/models/PriceBook";
import { requireSuperAdmin } from "@/lib/authz";

import { smartRateLimit } from "@/server/security/rateLimit";
import { rateLimitError } from "@/server/utils/errorResponses";
import { createSecureResponse } from "@/server/security/headers";
import { getClientIP } from "@/server/security/headers";

/**
 * @openapi
 * /api/admin/billing/pricebooks:
 *   post:
 *     summary: admin/billing/pricebooks operations
 *     tags: [admin]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function POST(req: NextRequest) {
  // Rate limiting
  const clientIp = getClientIP(req);
  const rl = await smartRateLimit(`${new URL(req.url).pathname}:${clientIp}`, 100, 60000);
  if (!rl.allowed) {
    return rateLimitError();
  }

  await dbConnect();
  await requireSuperAdmin(req);
  const body = await req.json();

  const doc = await PriceBook.create(body);
  return createSecureResponse(doc, 200, req);
}

]]>
</file>

<file path="app/api/admin/communications/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import { connectToDatabase, getDatabase } from "@/lib/mongodb-unified";
import { logger } from "@/lib/logger";
import { ObjectId } from "mongodb";
import { COLLECTIONS } from "@/lib/db/collections";

interface MatchStage {
  userId?: ObjectId;
  channel?: string;
  status?: string;
  createdAt?: { $gte?: Date; $lte?: Date };
  $or?: Array<Record<string, { $regex: string; $options: string }>>;
  [key: string]: unknown;
}

type PipelineStage =
  | { $match: MatchStage }
  | { $lookup: Record<string, unknown> }
  | { $unwind: Record<string, unknown> | string }
  | { $addFields: Record<string, unknown> }
  | { $sort: Record<string, number> }
  | { $skip: number }
  | { $limit: number }
  | { $facet: Record<string, PipelineStage[]> }
  | { $project: Record<string, number | string | Record<string, unknown>> };

/**
 * GET /api/admin/communications
 *
 * Fetch communication history with filtering and pagination
 *
 * Query Parameters:
 * - userId: Filter by user ID
 * - channel: Filter by channel (sms, email, whatsapp, otp, all)
 * - status: Filter by status (sent, delivered, failed, pending)
 * - startDate: Filter from date (ISO string)
 * - endDate: Filter to date (ISO string)
 * - limit: Number of records per page (default: 50)
 * - skip: Number of records to skip (default: 0)
 * - search: Search in recipient, subject, or message
 *
 * Response:
 * - 200: Communication logs with metadata
 * - 401: Unauthorized
 * - 403: Forbidden (not super admin)
 * - 500: Server error
 */
export async function GET(request: NextRequest) {
  try {
    // 1. Check authentication and authorization
    const session = await auth();

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 },
      );
    }

    // Check if user is super admin
    const isSuperAdmin = session.user.role === "SUPER_ADMIN";
    if (!isSuperAdmin) {
      return NextResponse.json(
        { success: false, error: "Forbidden: Super admin access required" },
        { status: 403 },
      );
    }

    // 2. Parse query parameters
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get("userId");
    const channel = searchParams.get("channel") || "all";
    const status = searchParams.get("status");
    const startDateParam = searchParams.get("startDate");
    const endDateParam = searchParams.get("endDate");
    const searchValue = searchParams.get("search")?.trim();
    const limitParam = Number.parseInt(searchParams.get("limit") || "", 10);
    const skipParam = Number.parseInt(searchParams.get("skip") || "", 10);

    const limit = Math.min(
      Number.isFinite(limitParam) && limitParam > 0 ? limitParam : 50,
      100,
    );
    const skip = Number.isFinite(skipParam) && skipParam >= 0 ? skipParam : 0;

    let startDate: Date | undefined;
    let endDate: Date | undefined;

    if (startDateParam) {
      const parsed = Date.parse(startDateParam);
      if (Number.isNaN(parsed)) {
        return NextResponse.json(
          { success: false, error: "Invalid startDate parameter" },
          { status: 400 },
        );
      }
      startDate = new Date(parsed);
    }

    if (endDateParam) {
      const parsed = Date.parse(endDateParam);
      if (Number.isNaN(parsed)) {
        return NextResponse.json(
          { success: false, error: "Invalid endDate parameter" },
          { status: 400 },
        );
      }
      endDate = new Date(parsed);
    }

    if (startDate && endDate && endDate < startDate) {
      return NextResponse.json(
        {
          success: false,
          error: "endDate must be greater than or equal to startDate",
        },
        { status: 400 },
      );
    }

    // 3. Connect to database
    await connectToDatabase();
    const db = await getDatabase();

    // 4. Build aggregation pipeline
    const pipeline: PipelineStage[] = [];

    // Match stage - filter by criteria
    const matchStage: MatchStage = {};

    if (userId) {
      if (!ObjectId.isValid(userId)) {
        return NextResponse.json(
          { success: false, error: "Invalid userId parameter" },
          { status: 400 },
        );
      }
      matchStage.userId = new ObjectId(userId);
    }

    if (channel && channel !== "all") {
      matchStage.channel = channel;
    }

    if (status) {
      matchStage.status = status;
    }

    if (startDate || endDate) {
      matchStage.createdAt = {};
      if (startDate) {
        matchStage.createdAt.$gte = new Date(startDate);
      }
      if (endDate) {
        matchStage.createdAt.$lte = new Date(endDate);
      }
    }

    if (searchValue) {
      const escapedSearch = searchValue.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      matchStage.$or = [
        { recipient: { $regex: escapedSearch, $options: "i" } },
        { subject: { $regex: escapedSearch, $options: "i" } },
        { message: { $regex: escapedSearch, $options: "i" } },
        { "metadata.email": { $regex: escapedSearch, $options: "i" } },
        { "metadata.phone": { $regex: escapedSearch, $options: "i" } },
      ];
    }

    if (Object.keys(matchStage).length > 0) {
      pipeline.push({ $match: matchStage });
    }

    // Lookup user details
    pipeline.push({
      $lookup: {
        from: "users",
        localField: "userId",
        foreignField: "_id",
        as: "user",
      },
    });

    pipeline.push({
      $unwind: {
        path: "$user",
        preserveNullAndEmptyArrays: true,
      },
    });

    // Add user details to result
    pipeline.push({
      $addFields: {
        userName: {
          $concat: [
            { $ifNull: ["$user.personal.firstName", ""] },
            " ",
            { $ifNull: ["$user.personal.lastName", ""] },
          ],
        },
        userEmail: "$user.email",
        userPhone: {
          $ifNull: ["$user.contact.phone", "$user.personal.phone"],
        },
      },
    });

    // Sort by creation date (newest first)
    pipeline.push({ $sort: { createdAt: -1 } });

    // Count total matching documents
    const countPipeline = [...pipeline, { $count: "total" }];
    const countResult = await db
      .collection(COLLECTIONS.COMMUNICATION_LOGS)
      .aggregate(countPipeline)
      .toArray();
    const total = countResult[0]?.total || 0;

    // Pagination
    pipeline.push({ $skip: skip });
    pipeline.push({ $limit: limit });

    // Project final fields
    pipeline.push({
      $project: {
        _id: 1,
        userId: 1,
        userName: 1,
        userEmail: 1,
        userPhone: 1,
        channel: 1,
        type: 1,
        recipient: 1,
        subject: 1,
        message: 1,
        status: 1,
        metadata: 1,
        createdAt: 1,
        updatedAt: 1,
        deliveredAt: 1,
        failedAt: 1,
        errorMessage: 1,
      },
    });

    // Execute aggregation
    const communications = await db
      .collection(COLLECTIONS.COMMUNICATION_LOGS)
      .aggregate(pipeline)
      .toArray();

    // 5. Get statistics
    const statsResult = await db
      .collection(COLLECTIONS.COMMUNICATION_LOGS)
      .aggregate([
        { $match: matchStage },
        {
          $group: {
            _id: null,
            totalSent: { $sum: 1 },
            totalDelivered: {
              $sum: { $cond: [{ $eq: ["$status", "delivered"] }, 1, 0] },
            },
            totalFailed: {
              $sum: { $cond: [{ $eq: ["$status", "failed"] }, 1, 0] },
            },
            totalPending: {
              $sum: { $cond: [{ $eq: ["$status", "pending"] }, 1, 0] },
            },
            smsCount: {
              $sum: { $cond: [{ $eq: ["$channel", "sms"] }, 1, 0] },
            },
            emailCount: {
              $sum: { $cond: [{ $eq: ["$channel", "email"] }, 1, 0] },
            },
            whatsappCount: {
              $sum: { $cond: [{ $eq: ["$channel", "whatsapp"] }, 1, 0] },
            },
            otpCount: {
              $sum: { $cond: [{ $eq: ["$channel", "otp"] }, 1, 0] },
            },
          },
        },
      ])
      .toArray();

    const stats = statsResult[0] || {
      totalSent: 0,
      totalDelivered: 0,
      totalFailed: 0,
      totalPending: 0,
      smsCount: 0,
      emailCount: 0,
      whatsappCount: 0,
      otpCount: 0,
    };

    // 6. Return response
    return NextResponse.json({
      success: true,
      data: {
        communications,
        pagination: {
          total,
          limit,
          skip,
          pages: Math.ceil(total / limit),
          currentPage: Math.floor(skip / limit) + 1,
        },
        statistics: {
          ...stats,
          deliveryRate:
            stats.totalSent > 0
              ? ((stats.totalDelivered / stats.totalSent) * 100).toFixed(2) +
                "%"
              : "0%",
          failureRate:
            stats.totalSent > 0
              ? ((stats.totalFailed / stats.totalSent) * 100).toFixed(2) + "%"
              : "0%",
        },
      },
    });
  } catch (error) {
    logger.error("[Admin] Get communications error", error as Error);
    return NextResponse.json(
      { success: false, error: "Internal server error" },
      { status: 500 },
    );
  }
}

]]>
</file>

<file path="app/api/admin/discounts/route.ts">
<![CDATA[
import { connectToDatabase } from "@/lib/mongodb-unified";
import { logger } from "@/lib/logger";
import DiscountRule from "@/server/models/DiscountRule";
import { NextRequest, NextResponse } from "next/server";
import { getUserFromToken } from "@/lib/auth";
import { smartRateLimit, buildOrgAwareRateLimitKey } from "@/server/security/rateLimit";
import {
  rateLimitError,
  zodValidationError,
} from "@/server/utils/errorResponses";
import { createSecureResponse } from "@/server/security/headers";
import { z } from "zod";
export const dynamic = "force-dynamic";

const discountSchema = z.object({
  value: z.number().min(0).max(100),
});

async function authenticateAdmin(req: NextRequest) {
  const token = req.headers
    .get("authorization")
    ?.replace("Bearer ", "")
    ?.trim();
  if (!token) {
    throw new Error("Authentication required");
  }

  const user = await getUserFromToken(token);
  if (!user) {
    throw new Error("Invalid token");
  }

  if (!["SUPER_ADMIN"].includes(user.role)) {
    throw new Error("Admin access required");
  }

  return user;
}

/**
 * @openapi
 * /api/admin/discounts:
 *   get:
 *     summary: admin/discounts operations
 *     tags: [admin]
 *     security:
 *       - cookieAuth: []
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Success
 *       401:
 *         description: Unauthorized
 *       429:
 *         description: Rate limit exceeded
 */
export async function GET(req: NextRequest) {
  try {
    const user = await authenticateAdmin(req);

    const orgId =
      (user as { orgId?: string; tenantId?: string }).orgId ||
      (user as { tenantId?: string }).tenantId ||
      null;

    if (!orgId) {
      return createSecureResponse(
        { error: "Organization context required" },
        400,
        req,
      );
    }

    // Rate limiting (org-aware) after authentication
    const key = buildOrgAwareRateLimitKey(req, orgId, user.id ?? null);
    const rl = await smartRateLimit(key, 100, 60_000);
    if (!rl.allowed) {
      return rateLimitError();
    }

    await connectToDatabase();
    // TENANCY: Discounts are tenant-scoped; require orgId
    const d = await DiscountRule.findOne({ key: "ANNUAL", orgId }).lean();
    return NextResponse.json(
      d || { key: "ANNUAL", percentage: 0, editableBySuperAdminOnly: true, orgId },
    );
  } catch (error: unknown) {
    if (error instanceof Error && error.message === "Authentication required") {
      return createSecureResponse(
        { error: "Authentication required" },
        401,
        req,
      );
    }
    if (error instanceof Error && error.message === "Invalid token") {
      return createSecureResponse({ error: "Invalid token" }, 401, req);
    }
    if (error instanceof Error && error.message === "Admin access required") {
      return createSecureResponse({ error: "Admin access required" }, 403, req);
    }
    logger.error(
      "Discount fetch failed:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return createSecureResponse({ error: "Internal server error" }, 500, req);
  }
}

export async function PUT(req: NextRequest) {
  try {
    const user = await authenticateAdmin(req);

    const orgId =
      (user as { orgId?: string; tenantId?: string }).orgId ||
      (user as { tenantId?: string }).tenantId ||
      null;

    if (!orgId) {
      return createSecureResponse(
        { error: "Organization context required" },
        400,
        req,
      );
    }

    // Rate limiting for admin operations
    const key = buildOrgAwareRateLimitKey(req, orgId, user.id ?? null);
    const rl = await smartRateLimit(key, 5, 60_000); // 5 requests per minute for discount changes
    if (!rl.allowed) {
      return createSecureResponse({ error: "Rate limit exceeded" }, 429, req);
    }

    await connectToDatabase();
    const body = discountSchema.parse(await req.json());

    const d = await DiscountRule.findOneAndUpdate(
      { key: "ANNUAL", orgId },
      {
        key: "ANNUAL",
        orgId,
        percentage: body.value,
        editableBySuperAdminOnly: true,
        updatedBy: user.id,
        updatedAt: new Date(),
      },
      { upsert: true, new: true },
    );
    return createSecureResponse(d, 200, req);
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return zodValidationError(error, req);
    }
    if (error instanceof Error && error.message === "Authentication required") {
      return createSecureResponse(
        { error: "Authentication required" },
        401,
        req,
      );
    }
    if (error instanceof Error && error.message === "Invalid token") {
      return createSecureResponse({ error: "Invalid token" }, 401, req);
    }
    if (error instanceof Error && error.message === "Admin access required") {
      return createSecureResponse({ error: "Admin access required" }, 403, req);
    }
    logger.error(
      "Discount update failed:",
      error instanceof Error ? error.message : "Unknown error",
    );
    return createSecureResponse({ error: "Internal server error" }, 500, req);
  }
}

]]>
</file>

<file path="app/api/admin/export/route.ts">
<![CDATA[
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import { logger } from "@/lib/logger";
import { z } from "zod";
import { connectToDatabase } from "@/lib/mongodb-unified";
import mongoose from "mongoose";

const ExportSchema = z.object({
  format: z.enum(["json", "csv"]).default("json"),
  collections: z.array(z.string()).optional(),
});

/**
 * Canonical collection definitions with correct org scope field.
 * STRICT v4.1: Uses orgId (camelCase) consistently per schema conventions.
 */
const COLLECTION_CONFIG: Record<string, { scopeField: "orgId"; maxDocs: number }> = {
  workorders: { scopeField: "orgId", maxDocs: 10000 },
  properties: { scopeField: "orgId", maxDocs: 5000 },
  vendors: { scopeField: "orgId", maxDocs: 5000 },
  units: { scopeField: "orgId", maxDocs: 10000 },
  invoices: { scopeField: "orgId", maxDocs: 10000 },
  users: { scopeField: "orgId", maxDocs: 5000 },
  tenancies: { scopeField: "orgId", maxDocs: 5000 },
  maintenancelogs: { scopeField: "orgId", maxDocs: 10000 },
  revenuelogs: { scopeField: "orgId", maxDocs: 10000 },
};

const ALL_EXPORTABLE = Object.keys(COLLECTION_CONFIG);
const MAX_COLLECTIONS_PER_REQUEST = 5;
const BATCH_SIZE = 500;

/**
 * ðŸ” SECURITY: Projections to exclude sensitive fields from exports
 * Even for SUPER_ADMIN, we don't export password hashes, tokens, or raw PII
 * Each collection has explicit field exclusions for compliance
 */
const DEFAULT_PROJECTION: Record<string, 0> = {
  password: 0,
  refreshToken: 0,
  accessToken: 0,
  apiKey: 0,
  apiSecret: 0,
  token: 0,
  phone: 0,
  email: 0,
  attachments: 0,
  attachmentUrls: 0,
  documents: 0,
  files: 0,
  bankAccount: 0,
  iban: 0,
  paymentIntentSecret: 0,
  idDocument: 0,
};

const COLLECTION_PROJECTIONS: Record<string, Record<string, 0>> = {
  users: {
    password: 0,
    personal: 0,
    refreshToken: 0,
    magicLinkToken: 0,
    resetToken: 0,
    resetPasswordToken: 0,
    resetPasswordExpires: 0,
    verificationToken: 0,
    twoFactorSecret: 0,
    backupCodes: 0,
    phone: 0,
    emergencyContact: 0,
  },
  vendors: {
    bankAccount: 0,
    iban: 0,
    taxCertificate: 0,
    contactPhone: 0,
    contactEmail: 0,
    paymentDetails: 0,
    apiKey: 0,
    apiSecret: 0,
  },
  invoices: {
    paymentIntentSecret: 0,
    payerEmail: 0,
    payerPhone: 0,
    stripeCustomerId: 0,
    paymentMethodId: 0,
  },
  workorders: {
    requesterPhone: 0,
    requesterEmail: 0,
    attachments: 0,  // May contain sensitive documents
  },
  properties: {
    ownerPhone: 0,
    ownerEmail: 0,
    bankDetails: 0,
    taxId: 0,
  },
  units: {
    tenantPhone: 0,
    tenantEmail: 0,
    accessCodes: 0,
    keyLocation: 0,
  },
  tenancies: {
    tenantPhone: 0,
    tenantEmail: 0,
    bankAccount: 0,
    emergencyContact: 0,
    idDocument: 0,
  },
  maintenancelogs: {
    technicianPhone: 0,
  },
  revenuelogs: {
    payerDetails: 0,
    bankReference: 0,
  },
};

/**
 * GET /api/admin/export
 * Export database collections to JSON or CSV format
 * SUPER_ADMIN only - scoped to organization with batching
 */
export async function GET(request: NextRequest) {
  try {
    const session = await auth();

    if (!session?.user || session.user.role !== "SUPER_ADMIN") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    const orgId = session.user.orgId;
    if (!orgId) {
      return NextResponse.json({ error: "Organization not found" }, { status: 400 });
    }

    // ðŸ” SECURITY: Validate orgId is a valid ObjectId to prevent injection
    if (!mongoose.Types.ObjectId.isValid(orgId)) {
      logger.warn("[Export] Invalid orgId format", { orgId, userId: session.user.id });
      return NextResponse.json({ error: "Invalid organization ID format" }, { status: 400 });
    }
    const orgObjectId = new mongoose.Types.ObjectId(orgId);

    const searchParams = request.nextUrl.searchParams;
    const format = searchParams.get("format") || "json";
    const collectionsParam = searchParams.get("collections");

    const parseResult = ExportSchema.safeParse({
      format,
      collections: collectionsParam ? collectionsParam.split(",") : undefined,
    });

    if (!parseResult.success) {
      return NextResponse.json(
        { error: "Validation failed", details: parseResult.error.issues.map((i) => i.message).join(", ") },
        { status: 400 }
      );
    }

    await connectToDatabase();

    // Normalize and validate requested collections
    const requestedRaw = parseResult.data.collections || ALL_EXPORTABLE;
    const requestedNormalized = requestedRaw.map((c) => c.toLowerCase().trim());
    const validCollections = requestedNormalized.filter((c) => ALL_EXPORTABLE.includes(c));

    if (validCollections.length === 0) {
      return NextResponse.json({ 
        error: "No valid collections specified",
        available: ALL_EXPORTABLE,
      }, { status: 400 });
    }

    // Limit collections per request to prevent memory exhaustion
    if (validCollections.length > MAX_COLLECTIONS_PER_REQUEST) {
      return NextResponse.json({
        error: `Maximum ${MAX_COLLECTIONS_PER_REQUEST} collections per request. Use multiple requests.`,
        requested: validCollections.length,
      }, { status: 400 });
    }

    const exportData: Record<string, unknown[]> = {};
    const truncatedCollections: string[] = [];

    // ðŸ” SECURITY: Dual filter to match orgId stored as string OR ObjectId
    // Some collections (e.g., souq_rmas) store orgId as string, others as ObjectId
    const orgFilter = { $in: [orgId, orgObjectId] };

    for (const collectionName of validCollections) {
      const config = COLLECTION_CONFIG[collectionName];
      if (!config) continue;

      const collection = mongoose.connection.collection(collectionName);
      const scopeQuery = { [config.scopeField]: orgFilter };
      
      // ðŸ” SECURITY: Apply projection to exclude sensitive fields
      const projection = {
        ...DEFAULT_PROJECTION,
        ...(COLLECTION_PROJECTIONS[collectionName] || {}),
      };
      
      // ðŸ”’ SECURITY: Use batched cursor with limit to prevent memory exhaustion
      const documents: unknown[] = [];
      const cursor = collection
        .find(scopeQuery, { projection })
        .batchSize(BATCH_SIZE)
        .limit(config.maxDocs);
      
      for await (const doc of cursor) {
        documents.push(doc);
      }

      if (documents.length === config.maxDocs) {
        truncatedCollections.push(collectionName);
      }

      exportData[collectionName] = documents;
      
      logger.info("Export collection fetched", {
        collection: collectionName,
        count: documents.length,
        maxDocs: config.maxDocs,
        orgId,
      });
    }

    if (parseResult.data.format === "csv") {
      // Convert to CSV format
      const csvData = convertToCSV(exportData);

      const headers: Record<string, string> = {
        "Content-Type": "text/csv; charset=utf-8",
        "Content-Disposition": `attachment; filename="export_${new Date().toISOString().split("T")[0]}.csv"`,
      };
      if (truncatedCollections.length > 0) {
        headers["X-Export-Truncated"] = truncatedCollections.join(",");
      }

      return new NextResponse(csvData, { headers });
    }

    // Return JSON
    const jsonBody = JSON.stringify(
      truncatedCollections.length
        ? { data: exportData, truncated: truncatedCollections }
        : exportData,
      null,
      2,
    );

    const headers: Record<string, string> = {
      "Content-Type": "application/json; charset=utf-8",
      "Content-Disposition": `attachment; filename="export_${new Date().toISOString().split("T")[0]}.json"`,
    };
    if (truncatedCollections.length > 0) {
      headers["X-Export-Truncated"] = truncatedCollections.join(",");
    }

    return new NextResponse(jsonBody, { headers });
  } catch (error) {
    logger.error("Error exporting data", error instanceof Error ? error : new Error(String(error)));
    return NextResponse.json(
      { error: `Export failed: ${error instanceof Error ? error.message : "Unknown error"}` },
      { status: 500 }
    );
  }
}

/**
 * Sanitize a value for CSV to prevent formula injection
 * Prefixes values starting with =, +, -, @ (including leading whitespace),
 * tab, or CR with a single quote
 */
function sanitizeCSVValue(value: string): string {
  const trimmed = value.trimStart();
  return /^[=+\-@]/.test(trimmed) || /^[\t\r]/.test(value) ? `'${value}` : value;
}

/**
 * Convert export data to CSV format
 * Each collection becomes a section in the CSV
 * ðŸ” SECURITY: Values are sanitized to prevent formula injection
 */
function convertToCSV(data: Record<string, unknown[]>): string {
  const lines: string[] = [];

  for (const [collectionName, documents] of Object.entries(data)) {
    if (documents.length === 0) continue;

    // Add collection header
    lines.push(`\n# ${collectionName.toUpperCase()}`);
    lines.push(`# Count: ${documents.length}`);

    // Get all unique headers from documents
    const headers = new Set<string>();
    documents.forEach((doc) => {
      if (doc && typeof doc === "object") {
        Object.keys(doc as Record<string, unknown>).forEach((key) => headers.add(key));
      }
    });

    const headerArray = Array.from(headers);

    // Add CSV header row
    lines.push(headerArray.map((h) => `"${h}"`).join(","));

    // Add data rows with CSV sanitization to prevent formula injection
    documents.forEach((doc) => {
      const row = headerArray.map((header) => {
        const value = (doc as Record<string, unknown>)[header];
        if (value === null || value === undefined) return "";
        if (typeof value === "object") {
          const jsonStr = JSON.stringify(value).replace(/"/g, '""');
          return `"${sanitizeCSVValue(jsonStr)}"`;
        }
        const strVal = String(value).replace(/"/g, '""');
        return `"${sanitizeCSVValue(strVal)}"`;
      });
      lines.push(row.join(","));
    });

    lines.push(""); // Empty line between collections
  }

  return lines.join("\n");
}

/**
 * POST /api/admin/export
 * Trigger an async export job for large datasets
 * SUPER_ADMIN only
 */
export async function POST(request: NextRequest) {
  try {
    const session = await auth();

    if (!session?.user || session.user.role !== "SUPER_ADMIN") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    const body = await request.json();
    const parseResult = ExportSchema.safeParse(body);

    if (!parseResult.success) {
      return NextResponse.json(
        { error: "Validation failed", details: parseResult.error.issues.map((i) => i.message).join(", ") },
        { status: 400 }
      );
    }

    // For now, redirect to GET endpoint
    // In production, this would queue a background job for large exports
    const url = new URL(request.url);
    url.searchParams.set("format", parseResult.data.format);
    if (parseResult.data.collections) {
      url.searchParams.set("collections", parseResult.data.collections.join(","));
    }

    return NextResponse.json({
      message: "Export job queued. Use GET endpoint for immediate download.",
      downloadUrl: `${url.pathname}?${url.searchParams.toString()}`,
    });
  } catch (error) {
    logger.error("Error queuing export", error instanceof Error ? error : new Error(String(error)));
    return NextResponse.json(
      { error: `Export failed: ${error instanceof Error ? error.message : "Unknown error"}` },
      { status: 500 }
    );
  }
}

]]>
</file>

</batch_content>
