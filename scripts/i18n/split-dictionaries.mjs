import fs from "node:fs/promises";
import path from "node:path";

const LOCALES = ["en", "ar"];
const SOURCE_DIR = path.join(process.cwd(), "i18n", "generated");
const OUTPUT_DIR = path.join(process.cwd(), "i18n", "chunks");
const NAMESPACE_SEGMENTS = 2;
const MIN_KEYS_PER_NAMESPACE = 30;
const PINNED_PREFIXES = ["auto"];

const header = `// Auto-generated by scripts/i18n/split-dictionaries.mjs
// Do not edit manually.
import type { Locale } from "../config";
import type { TranslationDictionary } from "../dictionaries/types";

export const chunkLoaders: Record<Locale, Record<string, () => Promise<{ default: TranslationDictionary }>>> = `;

function normalizeNamespace(key) {
  const parts = key.split(".").filter(Boolean);
  if (parts.length < 2) return "misc";
  const slice = parts.slice(0, Math.max(1, Math.min(NAMESPACE_SEGMENTS, parts.length)));
  return slice.join("/");
}

function sanitizeSegment(segment) {
  return segment.replace(/[^a-zA-Z0-9_-]/g, "-");
}

function safePath(namespace) {
  return namespace
    .split("/")
    .map((segment) => sanitizeSegment(segment) || "misc")
    .join("/");
}

async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}

async function loadDictionary(locale) {
  const filePath = path.join(SOURCE_DIR, `${locale}.dictionary.json`);
  const raw = await fs.readFile(filePath, "utf8");
  return JSON.parse(raw);
}

async function writeJson(filePath, data) {
  const dir = path.dirname(filePath);
  await ensureDir(dir);
  const sorted = Object.keys(data)
    .sort()
    .reduce((acc, key) => {
      acc[key] = data[key];
      return acc;
    }, {});
  await fs.writeFile(filePath, JSON.stringify(sorted, null, 2), "utf8");
}

async function main() {
  const manifest = {};
  const loaderMap = {};

  for (const locale of LOCALES) {
    const dictionary = await loadDictionary(locale);
    const namespaceMap = new Map();

    for (const [key, value] of Object.entries(dictionary)) {
      const ns = normalizeNamespace(key);
      const bucket = namespaceMap.get(ns) || {};
      bucket[key] = value;
      namespaceMap.set(ns, bucket);
    }

    // Bucket tiny namespaces into misc to avoid thousands of tiny chunks
    const misc = namespaceMap.get("misc") || {};
    for (const [namespace, entries] of namespaceMap.entries()) {
      if (namespace === "misc") continue;
      const isPinned = PINNED_PREFIXES.some((prefix) =>
        namespace.startsWith(prefix),
      );
      if (!isPinned && Object.keys(entries).length < MIN_KEYS_PER_NAMESPACE) {
        Object.assign(misc, entries);
        namespaceMap.delete(namespace);
      }
    }
    namespaceMap.set("misc", misc);

    const localeDir = path.join(OUTPUT_DIR, locale);
    await ensureDir(localeDir);
    manifest[locale] = [];
    loaderMap[locale] = {};

    for (const [namespace, entries] of namespaceMap.entries()) {
      const filenameSafe = safePath(namespace);
      const target = path.join(localeDir, `${filenameSafe}.json`);
      await writeJson(target, entries);
      const key = namespace;
      const importPath = `./${locale}/${filenameSafe}.json`;
      manifest[locale].push({ namespace: key, path: importPath });
      loaderMap[locale][key] = importPath;
    }
  }

  const loaders = Object.entries(loaderMap).reduce((acc, [locale, entries]) => {
    const pairs = Object.entries(entries).map(
      ([ns, importPath]) => `    "${ns}": () => import("${importPath}")`,
    );
    acc.push(`  ${JSON.stringify(locale)}: {\n${pairs.join(",\n")}\n  }`);
    return acc;
  }, []);

  const loaderFile = `${header}{\n${loaders.join(",\n")}\n} as const;\n\nexport const chunkManifest = ${JSON.stringify(
    manifest,
    null,
    2,
  )} as const;\n`;

  await fs.writeFile(path.join(OUTPUT_DIR, "loaders.ts"), loaderFile, "utf8");
  await fs.writeFile(
    path.join(OUTPUT_DIR, "manifest.json"),
    JSON.stringify(manifest, null, 2),
    "utf8",
  );
}

main().catch((err) => {
  console.error("Failed to split dictionaries", err);
  process.exit(1);
});
