#!/usr/bin/env tsx
/**
 * Security Event Monitoring Configuration
 * Adds logging hooks for rate limiting, CORS violations, and auth failures
 * 
 * Usage: pnpm tsx scripts/security/configure-monitoring.ts
 */

import { writeFileSync, readFileSync, existsSync } from 'fs';
import { join } from 'path';

const MONITORING_CONFIG = {
  rateLimit: {
    logLevel: 'warn',
    alertThreshold: 100, // Alert if 100+ rate limit hits in 5 minutes
    destinations: ['console', 'file', 'webhook']
  },
  cors: {
    logLevel: 'warn',
    alertThreshold: 50, // Alert if 50+ CORS violations in 5 minutes
    destinations: ['console', 'file']
  },
  auth: {
    logLevel: 'error',
    alertThreshold: 10, // Alert if 10+ auth failures in 5 minutes
    destinations: ['console', 'file', 'webhook']
  },
  mongodb: {
    logLevel: 'error',
    alertThreshold: 5, // Alert if 5+ connection failures in 5 minutes
    destinations: ['console', 'file', 'webhook']
  }
};

const MONITORING_MIDDLEWARE = `
/**
 * Security event monitoring middleware
 * Auto-generated by scripts/security/configure-monitoring.ts
 */

import { logger } from '@/lib/logger';
import { NextRequest, NextResponse } from 'next/server';

// Rate limit event tracking
const rateLimitHits = new Map<string, number[]>();
const corsViolations = new Map<string, number[]>();
const authFailures = new Map<string, number[]>();

const WINDOW_MS = 5 * 60 * 1000; // 5 minutes
const ALERT_THRESHOLDS = ${JSON.stringify(MONITORING_CONFIG, null, 2)};

function cleanOldEntries(map: Map<string, number[]>, windowMs: number): void {
  const cutoff = Date.now() - windowMs;
  for (const [key, timestamps] of map.entries()) {
    const filtered = timestamps.filter(t => t > cutoff);
    if (filtered.length === 0) {
      map.delete(key);
    } else {
      map.set(key, filtered);
    }
  }
}

function trackEvent(
  map: Map<string, number[]>,
  key: string,
  eventType: string,
  threshold: number
): void {
  cleanOldEntries(map, WINDOW_MS);
  
  const timestamps = map.get(key) || [];
  timestamps.push(Date.now());
  map.set(key, timestamps);
  
  if (timestamps.length >= threshold) {
    logger.warn(\`[\${eventType}] Alert threshold exceeded\`, {
      key,
      count: timestamps.length,
      windowMs: WINDOW_MS,
      threshold
    });
    
    // Emit webhook if configured
    if (process.env.SECURITY_ALERT_WEBHOOK) {
      fetch(process.env.SECURITY_ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          event: eventType,
          key,
          count: timestamps.length,
          threshold,
          timestamp: new Date().toISOString()
        })
      }).catch(err => logger.error('[Webhook] Failed to send alert', err));
    }
  }
}

export function trackRateLimitHit(identifier: string, endpoint: string): void {
  const key = \`\${identifier}:\${endpoint}\`;
  trackEvent(rateLimitHits, key, 'RateLimit', ALERT_THRESHOLDS.rateLimit.alertThreshold);
  
  logger.warn('[RateLimit] Request blocked', {
    identifier,
    endpoint,
    timestamp: new Date().toISOString()
  });
}

export function trackCorsViolation(origin: string, endpoint: string): void {
  const key = \`\${origin}:\${endpoint}\`;
  trackEvent(corsViolations, key, 'CORS', ALERT_THRESHOLDS.cors.alertThreshold);
  
  logger.warn('[CORS] Origin blocked', {
    origin,
    endpoint,
    timestamp: new Date().toISOString()
  });
}

export function trackAuthFailure(identifier: string, reason: string): void {
  trackEvent(authFailures, identifier, 'Auth', ALERT_THRESHOLDS.auth.alertThreshold);
  
  logger.error('[Auth] Authentication failed', {
    identifier,
    reason,
    timestamp: new Date().toISOString()
  });
}

export function getSecurityMetrics() {
  return {
    rateLimitHits: rateLimitHits.size,
    corsViolations: corsViolations.size,
    authFailures: authFailures.size,
    windowMs: WINDOW_MS
  };
}
`;

const ENHANCED_RATE_LIMIT_MIDDLEWARE = `
/**
 * Enhanced rate limiting with monitoring
 * Based on lib/security/rate-limit.ts
 */

import { NextRequest, NextResponse } from 'next/server';
import { rateLimit } from '@/server/security/rateLimit';
import { rateLimitError } from '@/server/utils/errorResponses';
import { getClientIP } from '@/server/security/headers';
import { trackRateLimitHit } from '@/lib/security/monitoring';

export type RateLimitOptions = {
  identifier?: string;
  keyPrefix?: string;
  requests?: number;
  windowMs?: number;
};

export function enforceRateLimit(
  request: NextRequest,
  options: RateLimitOptions = {}
): NextResponse | null {
  const identifier = options.identifier ?? getClientIP(request);
  const prefix = options.keyPrefix ?? new URL(request.url).pathname;
  const key = \`\${prefix}:\${identifier}\`;

  const result = rateLimit(key, options.requests ?? 30, options.windowMs ?? 60_000);
  
  if (!result.allowed) {
    // Track rate limit event for monitoring
    trackRateLimitHit(identifier, prefix);
    return rateLimitError();
  }

  // Add rate limit headers
  const response = NextResponse.next();
  response.headers.set('X-RateLimit-Limit', String(options.requests ?? 30));
  response.headers.set('X-RateLimit-Remaining', String(result.remaining));
  response.headers.set('X-RateLimit-Reset', String(Date.now() + (options.windowMs ?? 60_000)));
  
  return null;
}
`;

const ENHANCED_CORS_MIDDLEWARE = `
/**
 * Enhanced CORS middleware with monitoring
 * Updates middleware.ts CORS handling
 */

import { NextRequest, NextResponse } from 'next/server';
import { isOriginAllowed, resolveAllowedOrigin } from '@/lib/security/cors-allowlist';
import { trackCorsViolation } from '@/lib/security/monitoring';

export function handleCorsRequest(request: NextRequest): NextResponse | null {
  const origin = request.headers.get('origin');
  const pathname = new URL(request.url).pathname;
  
  // Check if origin is allowed
  if (origin && !isOriginAllowed(origin)) {
    // Track CORS violation for monitoring
    trackCorsViolation(origin, pathname);
    
    return new NextResponse('Forbidden: Origin not allowed', {
      status: 403,
      headers: {
        'Content-Type': 'text/plain'
      }
    });
  }
  
  // Origin is allowed - add CORS headers
  const allowedOrigin = resolveAllowedOrigin(origin);
  
  if (request.method === 'OPTIONS') {
    return new NextResponse(null, {
      status: 204,
      headers: {
        'Access-Control-Allow-Origin': allowedOrigin || '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Tenant-ID, X-Org-ID',
        'Access-Control-Max-Age': '86400',
        'Access-Control-Allow-Credentials': 'true'
      }
    });
  }
  
  return null;
}

export function addCorsHeaders(response: NextResponse, origin: string | null): NextResponse {
  const allowedOrigin = resolveAllowedOrigin(origin);
  
  if (allowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', allowedOrigin);
    response.headers.set('Access-Control-Allow-Credentials', 'true');
  }
  
  return response;
}
`;

console.log('ðŸ”§ Configuring security monitoring...\n');

// Create monitoring middleware file
const monitoringPath = join(process.cwd(), 'lib/security/monitoring.ts');
writeFileSync(monitoringPath, MONITORING_MIDDLEWARE.trim());
console.log('âœ… Created lib/security/monitoring.ts');

// Create enhanced rate limit middleware
const enhancedRateLimitPath = join(process.cwd(), 'lib/middleware/enhanced-rate-limit.ts');
writeFileSync(enhancedRateLimitPath, ENHANCED_RATE_LIMIT_MIDDLEWARE.trim());
console.log('âœ… Created lib/middleware/enhanced-rate-limit.ts');

// Create enhanced CORS middleware
const enhancedCorsPath = join(process.cwd(), 'lib/middleware/enhanced-cors.ts');
writeFileSync(enhancedCorsPath, ENHANCED_CORS_MIDDLEWARE.trim());
console.log('âœ… Created lib/middleware/enhanced-cors.ts');

// Create environment variables template
const envTemplate = `
# Security Monitoring Configuration
# Add these to your .env.local file

# Webhook for security alerts (optional)
SECURITY_ALERT_WEBHOOK=https://your-monitoring-service.com/webhook

# Log level for security events (debug, info, warn, error)
SECURITY_LOG_LEVEL=warn

# Enable security monitoring (true/false)
ENABLE_SECURITY_MONITORING=true
`;

const envTemplatePath = join(process.cwd(), '.env.security.template');
writeFileSync(envTemplatePath, envTemplate.trim());
console.log('âœ… Created .env.security.template');

// Create monitoring dashboard query examples
const dashboardQueries = `
# Security Monitoring Dashboard Queries
# Use these with your logging/monitoring service (DataDog, New Relic, etc.)

## Rate Limit Events
\`\`\`
service:fixzit event:RateLimit
| group by identifier, endpoint
| count
| top 10
\`\`\`

## CORS Violations
\`\`\`
service:fixzit event:CORS
| group by origin, endpoint
| count
| where count > 10
\`\`\`

## Authentication Failures
\`\`\`
service:fixzit event:Auth status:failed
| group by identifier, reason
| count
| where count > 5
\`\`\`

## Security Metrics (Last 24 Hours)
\`\`\`
service:fixzit (event:RateLimit OR event:CORS OR event:Auth)
| timeseries sum(count) by event
| timeframe last_24h
\`\`\`
`;

const dashboardPath = join(process.cwd(), 'docs/security/MONITORING_QUERIES.md');
writeFileSync(dashboardPath, dashboardQueries.trim());
console.log('âœ… Created docs/security/MONITORING_QUERIES.md');

// Create integration instructions
const integrationInstructions = `
# Security Monitoring Integration Guide

## Step 1: Update Rate-Limited Routes

For each rate-limited route, replace the import:

\`\`\`typescript
// OLD:
import { enforceRateLimit } from '@/lib/middleware/rate-limit';

// NEW:
import { enforceRateLimit } from '@/lib/middleware/enhanced-rate-limit';
\`\`\`

The enhanced version includes automatic monitoring hooks.

## Step 2: Update Middleware.ts

Update your \`middleware.ts\` file to use enhanced CORS:

\`\`\`typescript
import { handleCorsRequest, addCorsHeaders } from '@/lib/middleware/enhanced-cors';

export async function middleware(request: NextRequest) {
  // Handle CORS with monitoring
  const corsResponse = handleCorsRequest(request);
  if (corsResponse) return corsResponse;
  
  // ... rest of middleware logic
  
  // Add CORS headers to response
  const response = NextResponse.next();
  return addCorsHeaders(response, request.headers.get('origin'));
}
\`\`\`

## Step 3: Configure Environment Variables

Copy \`.env.security.template\` to \`.env.local\` and fill in values:

\`\`\`bash
cp .env.security.template .env.local.security
# Edit .env.local.security with your values
# Then append to .env.local:
cat .env.local.security >> .env.local
\`\`\`

## Step 4: Set Up Alerting Webhook (Optional)

Configure a webhook URL to receive security alerts:

### Option A: Slack
1. Create a Slack webhook: https://api.slack.com/messaging/webhooks
2. Set SECURITY_ALERT_WEBHOOK to your Slack webhook URL

### Option B: Discord
1. Create a Discord webhook in your server settings
2. Set SECURITY_ALERT_WEBHOOK to your Discord webhook URL

### Option C: Custom Service
1. Deploy a webhook receiver (see examples/webhook-receiver.ts)
2. Set SECURITY_ALERT_WEBHOOK to your service URL

## Step 5: Test Monitoring

Run the security test suite to generate events:

\`\`\`bash
pnpm tsx scripts/security/run-all-security-tests.sh
\`\`\`

Check your logs for security events:

\`\`\`bash
grep "RateLimit\|CORS\|Auth" logs/*.log
\`\`\`

## Step 6: Set Up Dashboard (Optional)

Use the queries in \`docs/security/MONITORING_QUERIES.md\` with your monitoring service.

### DataDog
1. Create a new dashboard
2. Add widgets using the provided queries
3. Set up monitors for alert thresholds

### New Relic
1. Create a new dashboard
2. Add NRQL queries based on the templates
3. Set up alert policies

### Grafana
1. Create a new dashboard
2. Add panels with LogQL/PromQL queries
3. Configure alerting rules

## Monitoring Metrics

The following metrics are tracked:

- **Rate Limit Hits:** Count of 429 responses per endpoint
- **CORS Violations:** Count of blocked origins per endpoint
- **Auth Failures:** Count of failed authentications per user
- **Alert Triggers:** Count of threshold breaches

## Alert Thresholds (Configurable)

- Rate Limit: 100 hits in 5 minutes
- CORS Violations: 50 blocks in 5 minutes
- Auth Failures: 10 failures in 5 minutes

Adjust these in \`lib/security/monitoring.ts\` as needed.
`;

const integrationPath = join(process.cwd(), 'docs/security/MONITORING_INTEGRATION.md');
writeFileSync(integrationPath, integrationInstructions.trim());
console.log('âœ… Created docs/security/MONITORING_INTEGRATION.md');

console.log('\nâœ… Security monitoring configuration complete!\n');
console.log('Next steps:');
console.log('1. Review .env.security.template and add values to .env.local');
console.log('2. Follow docs/security/MONITORING_INTEGRATION.md to integrate');
console.log('3. Run pnpm tsx scripts/security/run-all-security-tests.sh');
console.log('4. Set up monitoring dashboard with provided queries\n');
